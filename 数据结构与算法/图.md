# 图

## 图的表示

> 「**图graph**」跟树相似，他们都是非线性数据结构。但是树有根，图没有。
>
> 图中每个节点叫「**顶点vertex**」。
>
> 每一个顶点可以与任意其他顶点建立连接关系，这种连接关系叫「**边edge**」。
>
> <img src="https://gitee.com/wangigor/typora-images/raw/master/image-20210615215831429.png" alt="image-20210615215831429" style="zoom:50%;" />
>
> 生活中有很多这样的例子，比如社交网络。
>
> 把每个用户看作一个顶点，两个用户之间建立了好友关系，就在两个顶点之间建立一条边。一个顶点有几条边，叫做这个顶点的「**度degree**」，也就是这个用户的好友个数。
>
> 再复杂一点。如果A关注了B，且B没有关注A。就需要在图中引入「**方向**」概念。如果A关注了B，就在图中画一条A --> B的边；如果B也关注了A，就再在图中画一条B --> A的边。这样有方向的图叫「**有向图**」，没有方向的图叫「无向图」。
>
> <img src="https://gitee.com/wangigor/typora-images/raw/master/image-20210615222223858.png" alt="image-20210615222223858" style="zoom:50%;" />
>
> 在有向图中，把度分为「**入度in-degree**」和「**出度out-degree**」。
>
> 入度表示有多少边指向这个顶点，也就是「粉丝数」。
>
> 出度表示从这个顶点出发了几条边，也就是「关注数」。
>
> 再复杂一点。社交关系比较复杂，还会记录两个用户的「亲密度」。这样每条边都有「权重weight」的图叫「**带权图weighted-graph**」。
>
> <img src="https://gitee.com/wangigor/typora-images/raw/master/image-20210615223258827.png" alt="image-20210615223258827" style="zoom:50%;" />

以上是图的概念。作为数据结构，图还是有很多表现形式的。

### 邻接矩阵

> 邻接矩阵底层依赖二维数组。
>
> - 无向图
>
>   <img src="https://gitee.com/wangigor/typora-images/raw/master/image-20210616101343310.png" alt="image-20210616101343310" style="zoom:50%;" />
>
>   如果顶点i和顶点j之间有边，就把A\[i\]\[j\]和A\[j\]\[i\]都记为1。
>
>   $A=\left\{\begin{matrix}0&1&1&0\\1&0&1&1\\1&1&0&1\\0&1&1&0\end{matrix}\right\}$
>
> - 有向图
>
>   <img src="https://gitee.com/wangigor/typora-images/raw/master/image-20210616102401003.png" alt="image-20210616102401003" style="zoom:50%;" />
>
>   如果有一条边从顶点i指向顶点j，就把A\[i]\[j\]记为1。
>
>   $A=\left\{\begin{matrix}0&1&0&0\\0&0&1&0\\1&1&0&0\\0&1&1&0\end{matrix}\right\}$
>
> - 带权无向图
>
>   <img src="https://gitee.com/wangigor/typora-images/raw/master/image-20210616103403204.png" alt="image-20210616103403204" style="zoom:50%;" />
>
>   如果顶点i和顶点j边的权重是5，就把A\[i\]\[j\]和A\[j\]\[i\]都记为5.
>
>   $A=\left\{\begin{matrix}0&5&3&0\\5&0&2&6\\3&2&0&1\\0&6&1&0\end{matrix}\right\}$

对于无向图，其实有一半的空间是浪费的。另外，如果存储的是「**稀疏图Sparse Matrix**」，也就是顶点很多，但是边不是很多。举个例子：「微信好友」所有的微信用户几亿人，但是一个用户的好友列表只有几百人。显然不能创建一个几亿的矩阵。

但邻接矩阵法也不是没有意义。

- 他有数组的高效访问。

- 他有矩阵运算带来的方便之处。

  比如最短路径里的Floyd-Warshall算法就是利用矩阵循环相乘若干次得到结果。

### 邻接表

> 邻接表底层是散列思想。但是由于数据的特殊性，需要避免顶点数据之间的散列冲突。
>
> 以上图的有向图为例，组成的邻接表可以是：
>
> <img src="https://gitee.com/wangigor/typora-images/raw/master/image-20210616110804032.png" alt="image-20210616110804032" style="zoom:50%;" />
>
> 但是也不限于只是这样。这是一种典型的用时间换空间的思想，而且链表本身就对缓存不友好。
>
> 那么为了解决链表查找的时间慢问题，可以运用之前的一些数据结构：
>
> - 平衡二叉树：红黑树。
> - 跳跃链表
> - 或者可以改成有序数组进行二分搜索。
> - ……

上面是顶点i关注了哪些人。那么，怎么通过邻接表查找顶点i的粉丝数呢。

> 显然全部数据遍历是一件不可取的操作。
>
> 可以建立「逆邻接表」。也就是「关注」和「被关注」做成两个邻接表。

且还有一个优点：

> 在海量数据时代，可能邻接表更加好用一些。比如数据分片。

## 深度和广度搜索

## 拓扑排序

## 最短路径

## 向量空间

## A*搜索

