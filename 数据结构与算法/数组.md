# 数组

数组「Array」是一种**线性表**「Linear List」数据结构。
它用一块**连续**的空间「不只是内存空间」，存储具有**相同类型**「定长」的数据。

 - **线性表**

数据排成「一条线」的结构。数据在该结构中，**最多只有前/后两个方向。**
数组、链表、队列、栈 都是线性表。
而 树、堆、图等 都是**非线性表。**
 在非线性表中，数据不止是简单的前/后关系。

- **连续空间** 和 **相同类型**

    这两个特性决定了，数组可以进行**随机访问**。

    <img src="https://wangigor-typora-images.oss-cn-chengdu.aliyuncs.com/数组int a.png" alt="image-20201116215800609" style="zoom:50%;" />

> 计算机会给每一个内存单元分配一个内存地址，计算机通过内存地址访问内存的数据。
>
> 如上图，创建了一个长度为10的int数组，分配了初始内存地址1000「base_address」，每个int大小为4字节「type_size」。
>
> 这样通过下标的访问就可以通过
>
> ```伪代码
> a[i]的初始地址 = base_address + i * type_size
> ```
>
> 这样的公式取得下标为i的数组元素的起始位置，然后向后读取data_type_size就可以得到i元素的数据。

这也就解释了**为什么数组下标要从0开始？**

> 如果按照人的习惯从1开始，a[i]的地址计算公式就会变为
>
> ```伪代码
> a[i]的初始地址 = base_address + (i-1) * type_size
> ```
>
> 对于cpu来说，就是增加了一次减法运算。

**数组更易于查找，查找的时间复杂度为O(1)?**

> 不对。或者说不准确。
>
> 如果通过元素进行匹配，即使是排序好的数组，通过二分法查找时间复杂度也是O(logn)。
>
> 应该说，**数组支持随机访问，通过下标随机访问的时间复杂度为O(1)。**





数组这样的结构带来了快速的随机访问，也带来了「低效」的插入和删除。

## 低效的插入

> 假设有一个长度为n的数组，现在需要将一个新元素插入第k个位置。

- 为了给k位置腾出空间，需要将原k到n-1的元素后移。

- 如果插入的k位置是数组**尾部**，其他元素不需要移动，此时的时间复杂度为O(1)。

- 如果插入的位置是数组**头部**，所有元素都需要移动，此时的时间复杂度为O(n)。

- 如果数组满了，需要新开辟一个更大的空间，把原数组对象全部迁移过去，再完成插入，此时的时间复杂度为O(n)。

- k位置是0~n-1的**随机位置**，在每个位置上移动的元素个数不同。尾部为0，倒数第一为1，倒数第二为2……直到开头n-1.

  概率是一样的，都是1/n，加权平均数为

  ```公式
  1 * (1/n) + 2 * (1/n) + 3 * (1/n) + …… + n-1 * (1/n)
  = (n * (n-1))/2 * (1/n)  = O(n)
  ```

如果数组是有序的，就需要按照上面的步骤进行插入。

但是如果数组是无序的，数组只是被当做一个存放容器。为了减少数据迁移，最简单的方法是**把原k位置的元素放入队尾，新元素插入k位置**。

<img src="https://wangigor-typora-images.oss-cn-chengdu.aliyuncs.com/数组快速插入.png" alt="image-20201117094437670" style="zoom:50%;" />

这样，时间复杂度就降为O(1)。**「快速排序中有用到。」**



## 删除操作

> 删除操作，跟插入操作一样，在k位置删除元素时，为了保持数组数据的连续性，需要将k~n-1的数据进行迁移。
>
> - k在数组尾部，不需要迁移，时间复杂度O(1)。
> - k在数组头部，需要迁移全部数据，时间复杂度O(n)。
> - 平均时间复杂度也是O(n)。

为了对删除进行优化，可以采用「**空间换时间**」的方式。

![image-20201117101550868](https://wangigor-typora-images.oss-cn-chengdu.aliyuncs.com/数组删除.png)

假设有一个长度为10的数组，现有8个与元素，需要删除A、B、D、E四个元素。

为了避免C、F、G、H被多次搬运，先把四个元素标记为已删除。

当数组没有空间存放新元素时：再把ABDE，一起清除，只搬运一次。

> 数据结构是相通的，是方法论。
>
> 上面对删除的优化，像不像JVM的垃圾回收？
>
> - 只删除ABDE，其他元素原地不动 ≈ 「**标记-清除算法**」
> - 删除ABDE，对其他元素重排序 ≈ 「**标记-压缩算法**」
> - 把未清除的CFGH，搬运到一个新的数组存放，原数组全部清除 ≈「**标记-复制算法**」

## 数组下标越界



```java
int[] a = new int[3];
a[10]
```

对于java，会抛出**java.lang.ArrayIndexOutOfBoundsException**异常。

是因为java对于这样越界的访问，做了限制。

> 而C语言中就不是，数组越界在c语言中是一种未决行为。只要不是访问受限的内存，所有内存空间都是可以自由访问的。
>
> ```c
> int main(int argc, char* argv[]){ 
>   int i = 0; 
>   int arr[3] = {0}; 
>   for(; i<=3; i++){ 
>     arr[i] = 0; 
>     printf("hello world\n"); 
>   } 
>   return 0;
> }
> ```
>
> 这样的代码「可能」会进入**无限循环。**
>
> 因为函数内部变量分配在栈帧上，对于不同的编译器，在内存分配时，会按照内存地址递增或递减的方式进行分配。
>
> 如果内存地址分配是递减的。
>
> ![image-20201117120307135](https://wangigor-typora-images.oss-cn-chengdu.aliyuncs.com/数组-越界-栈帧分配.png)
>
> 先在一个8M的栈帧尾部「8388604-8388607」分配了i。
>
> 再在「8388591-8388603」分配了a[3]。
>
> a[3]按照下标随机访问，其实就读到了i，再将i赋值0，循环又重新开始。

