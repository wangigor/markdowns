# 过滤

## 位图

> 对于数据是否重复，最简单的就是整数数据。
>
> 比如，**有1亿个正整数集合，范围在0~10亿之间。判断一个外来的正整数x是否在前面的集合中。**
>
> 根据前面的散列思想，「可以」创建一个10亿的boolean集合保存原数据集合，这样只需要判断array[x]的true/false就可以知道x是否存在在集合中了。这里有两个问题。
>
> - 理论上boolean类型只有true和false两种结果，只需要使用0/1一个bit位标识就可以了。
>
>   但是java对于boolean底层使用int存储，也就是4byte=32bit。
>
>   10亿个数据需要3.7Gbyte，如果可能用bit存储则只需要120Mbyte。
>
> - 如果是包装类或者带精度/符号…的基本数据类型等等的基础数据。上面的方式就很难有行得通。
>
> 对于第二个问题，可以**使用哈希函数**对基础机型hashcode计算，再放入整数集合中。那么就会迎来下一个问题，**哈希冲突**。也就是不相等的两个数据，计算出来的hashcode相同。
>
> 这个问题也好解决，就是使用**多个哈希函数**。比如使用三个哈希函数进行计算，判断这个x元素是否在集合中需要判断三个hashcode在的位置是否同时为true即可。
>
> 虽然这也会发生错误的判断。
>
> <img src="https://gitee.com/wangigor/typora-images/raw/master/image-20210628102743463.png" alt="image-20210628102743463" style="zoom:50%;" />
>
> 比如这样的情况，x不在集合中，但是出现了错误判断。
>
> 虽然这样的情况会存在，但是我们认为这样的情况可以接受「或者说是，只可以做到绝大多数的过滤，但是如果返回false就一定不存在。」。
>
> 再来解决第一个问题。我们可以使用char类型数组进行底层存储，一个char占2个字节也就是16位，一个char保存了16个数据位。这样就可以了。
>
> <img src="https://gitee.com/wangigor/typora-images/raw/master/image-20210628104308505.png" alt="image-20210628104308505" style="zoom:50%;" />

java的某些工具类提供了这样的数据结构，叫做**位图**。

还有专门用来数据过滤的**布隆过滤器**。

### BitSet-jdk源码解析

```java
/**
 * The internal field corresponding to the serialField "bits".
 */
private long[] words;

/**
 * The number of words in the logical size of this BitSet.
 */
private transient int wordsInUse = 0;
```

使用了long数组进行数据存储，没个「word」存储64个bit。

```java
//2^6=64方便进行位运算
private final static int ADDRESS_BITS_PER_WORD = 6;
//每个word包含64个bit
private final static int BITS_PER_WORD = 1 << ADDRESS_BITS_PER_WORD;
//63 index最大值
private final static int BIT_INDEX_MASK = BITS_PER_WORD - 1;

//用于取值的「卡尺」
private static final long WORD_MASK = 0xffffffffffffffffL;
```

> 两种构造器，指定大小「大小由用户管理」或者不指定大小

```java
/**
 * 创建默认大小64位的BitSet
 */
public BitSet() {
  	//根据要求大小创建long[]数组
    initWords(BITS_PER_WORD);
    sizeIsSticky = false;//用户不控制
}

/**
 * 初始化一个 可以容纳nbits个bit的BitSet
 */
public BitSet(int nbits) {
    // nbits can't be negative; size 0 is OK
    if (nbits < 0)
        throw new NegativeArraySizeException("nbits < 0: " + nbits);
		//根据要求大小创建long[]数组
    initWords(nbits);
    sizeIsSticky = true;//用户控制
}
```

```java
//根据初始化bit数创建long数组
private void initWords(int nbits) {
  	//wordIndex(nbits-1) + 1 这个就相当于HashMap的tableSizeFor
  	//计算一个n*64刚刚大于nbits的n。
  	//63->1 64->1 65->2
    words = new long[wordIndex(nbits-1) + 1];
}
```

```java
private static int wordIndex(int bitIndex) {
  	//bitIndex / 64
    return bitIndex >> ADDRESS_BITS_PER_WORD;
}
```

```java
/**
 * Sets the bit at the specified index to {@code true}.
 *
 * @param  bitIndex a bit index
 * @throws IndexOutOfBoundsException if the specified index is negative
 * @since  JDK1.0
 */
// 按序号把bitIndex设置为true
public void set(int bitIndex) {
    if (bitIndex < 0)
        throw new IndexOutOfBoundsException("bitIndex < 0: " + bitIndex);
		//bitIndex在哪一个long对象中。
    int wordIndex = wordIndex(bitIndex);
  	//扩容
    expandTo(wordIndex);
		
  	// 对应标为1 true
    words[wordIndex] |= (1L << bitIndex); // Restores invariants
		//成员检查
    checkInvariants();
}
```

```java
/**
 * Returns the value of the bit with the specified index. The value
 * is {@code true} if the bit with the index {@code bitIndex}
 * is currently set in this {@code BitSet}; otherwise, the result
 * is {@code false}.
 *
 * @param  bitIndex   the bit index
 * @return the value of the bit with the specified index
 * @throws IndexOutOfBoundsException if the specified index is negative
 */
public boolean get(int bitIndex) {
    if (bitIndex < 0)
        throw new IndexOutOfBoundsException("bitIndex < 0: " + bitIndex);

    checkInvariants();

    int wordIndex = wordIndex(bitIndex);
  	//超过范围返回0
  	//返回位置bit跟1或运算的结果是不是0
    return (wordIndex < wordsInUse)
        && ((words[wordIndex] & (1L << bitIndex)) != 0);
}
```

```java
/**
 * Sets the bit at the specified index to the complement of its
 * current value.
 *
 * @param  bitIndex the index of the bit to flip
 * @throws IndexOutOfBoundsException if the specified index is negative
 * @since  1.4
 */
//翻转 bitIndex位置0->1 1->0
public void flip(int bitIndex) {
    if (bitIndex < 0)
        throw new IndexOutOfBoundsException("bitIndex < 0: " + bitIndex);

    int wordIndex = wordIndex(bitIndex);
    expandTo(wordIndex);
		
  	//进行1异或运算
    words[wordIndex] ^= (1L << bitIndex);

    recalculateWordsInUse();
    checkInvariants();
}
```

基本原理就是这样，他是对于基础数据为long的位图的操作。其他方式是一些bitset之间的操作、扩容、检查、初始化、序列化等等。

### BloomFilter-guava源码解析



