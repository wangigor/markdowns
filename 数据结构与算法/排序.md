# 排序



## 衡量标准

### 执行效率

之前的算法时间复杂度分析，都是基于**数据量**，反应数据量n很大时候的增长趋势。

但是排序稍有不同，数据**有序性**的不同也会导致时间复杂度的不同『比如一组完全有序的数据，「经过」排序算法的时间复杂度可能是O(n)，因为只有一次遍历；而一组倒序的数据，「经过」排序算法的时间复杂度可能是O($n^2$)』。

以冒泡排序为例「假设数据需要从小到大排列」，n个数据的排列组合方式有 $n!$ 种，使用之前的平均分析，计算每种情况的时间复杂度，再求解平均时间复杂度的方式就会很麻烦，需要涉及到数据推理和大量计算。

> **有序度**和**逆序度**
>
> **有序度**是数据中具有有序关系的数据对个数。以从小到大排序为例，有序关系的数据对可以表示为
>
> ```逻辑公式
> 当i<j时：a[i] <= a[j]
> ```
>
> ```示例
> 「2、4、3、1、5、6」这组数据中，有序的数据对有：
> 「2、4」「2、3」「2、5」「2、6」
> 「4、5」「4、6」
> 「3、5」「3、6」
> 「1、5」「1、6」
> 「5、6」
> 共有11对，所有这组数据的有序度为11。
> ```
>
> ```示例
> 「1、2、3、4、5、6」这组数据，是满有序度，n*(n-1)/2。15。
> 「6、5、4、3、2、1」这组数据，没有一个有序对，0。
> ```
>
> 交换次数总是 **「满有序度-初始有序度」**
>
> ```示例
> 「2、4、3、1、5、6」初始有序度为11，满有序度为15。使用冒泡排序。
> 第一次交换：「2、『3、4』、1、5、6」
> 第二次交换：「2、3、『1、4』、5、6」
> 第三次次交换：「2、『1、3』、4、5、6」
> 第四次次交换：「『1、2』、3、4、5、6」
> 最后一次遍历不交换数据，总共15-11=4次交换。
> ```
>
> **逆序度**跟有序度刚好相反。
>
> ```逻辑公式
> 当i<j时：a[j] > a[j]
> ```
>
> **满有序度 = 逆序度 + 有序度**。排序就是一个增加有序度，减小逆序度的过程。

以冒泡排序为例，经过一次**交换**，**有序度加一**。

- 最好情况：有序度为满有序度，不需要进行交换。

- 最坏情况：有序度为0，需要进行$n(n-1)/2$次交换。
- 平均情况：最好情况和最坏情况取平均值，$n(n-1)/4$

也就是，**冒泡排序的平均时间复杂度为O($n^2$)**。当然这种分析方式并不严格「比较操作比交换操作要多」，但是比起概率论的复杂计算和分析来看，更加实用。

### 空间消耗

这里说的是额外的空间消耗。

- **原地排序**时间复杂度为O(1)。冒泡排序、插入排序、选择排序都是原地排序算法。

### 稳定性

如果存在值相等的元素，经过交换后，他们的先后顺序是否发生改变。

假设有2，9，3，4，8，3一组数据，排序完成后2，3，3，4，8，9。有两个3，如果他们的前后顺序发生变化就是**不稳定排序**；如果前后顺序一致是**稳定排序**。

> 乍一看没什么讲究，但是对于日常的数据排序极为重要。
>
> 假如对订单进行排序，希望按照订单金额从大到小排序，相同订单金额的订单按照下单时间从大到小排序。
>
> - 如果使用不稳定排序：需要对订单金额进行分组，组内按照下单时间排序，然后再对组进行金额排序。比较复杂。
> - 如果使用稳定排序：先按照下单时间排序一遍，再按照订单金额排序一遍，就可以完成。

## 「已排序空间|未排序空间」类型

### 冒泡排序

> 逐个比较相邻的两个元素「i < j」
>
> - 存在 a[i] > a[j]，交换
> - 否则不交换
>
> 一次冒泡，至少会让一个元素移动到它应该在的位置。n个数据，至多经过n次冒泡完成排序。

假设对4，5，6，3，2，1从小到大进行排序，下面是一次冒泡过程

![一次冒泡](https://gitee.com/wangigor/typora-images/raw/master/数据结构与算法-排序-一次冒泡.png)

经过**一次冒泡**之后，6已经处在正确的位置。那么经过6次排序之后，完成排序。

![image-20201207102759331](https://gitee.com/wangigor/typora-images/raw/master/数据结构与算法-排序-6次冒泡.png)

6个数据排序6次，不是一个**必要终止排序条件**。

冒泡排序的排序终止条件，应当设为「**当前这一次冒泡是否有数据交换**」，没有数据交换就终止排序。比如下面这组数据：

![image-20201207103731910](https://gitee.com/wangigor/typora-images/raw/master/数据结构与算法-排序-4次冒泡.png)

没有数据交换，就代表已经达到完全有序的状态。

```java
/**
 * 数组冒泡排序「从小到大」
 *
 * @param array 元素数组
 * @param <T>   实现comparable接口的元素类
 */
private <T extends Comparable> void arrayBubbleSort(T[] array) {

    int array_length = array.length;
    if (array_length <= 1) {
        return;
    }
		//外层最多n次冒泡
    for (int i = 0; i < array_length; i++) {
        boolean changed = false;

        for (int j = 0; j < array_length - 1; j++) {
          	//大于才交换
            if (array[j].compareTo(array[j + 1]) > 0) {
                //需要交换
                T temp = array[j];
                array[j] = array[j + 1];
                array[j + 1] = temp;
                changed = true;//有交换
            }
        }
        if (!changed) {
            return;//当前循环无交换，退出排序
        }
    }

}
```

> 冒泡排序的衡量：
>
> - 时间复杂度为O($n^2$)
> - 空间复杂度为O(1)，只使用了一个temp的外部空间，是原地排序。
> - 是稳定排序。如果「array[j].compareTo(array[j + 1]) > 0」改为「>=0」，相同的元素，还是稳定排序吗？「依然是，但是会冗余一些交换操作」。

### 插入排序

> 插入排序借由有序数据插入数据而得名。
>
> ![image-20201208100513609](https://gitee.com/wangigor/typora-images/raw/master/数据结构与算法-排序-有序数据插入元素.png)
>
> 在已有的有序数据中插入新数据，需要将**元素插入指定位置，其他元素后移**。
>
> 由此就有了插入排序算法：将无序数据的第一个数据作为「有序数据」，往后遍历每一个元素，插入有序数据中。
>
> ![image-20201208101903861](https://gitee.com/wangigor/typora-images/raw/master/数据结构与算法-排序-插入排序.png)
>
> 可以看到：数据满有序度为15，初始有序度为5，总共移动「交换」了10次。**数据交换「移动」次数就是逆序度。**

```java
private <T extends Comparable> void insertionSort(T[] array){
    int array_length=array.length;
    if(array_length<=1) {
        return;
    }

    for (int i = 1; i < array_length; i++) {

        T current=array[i];
        int j=i-1;

        while (j>=0){
            if(array[j].compareTo(current)>0){
                array[j+1]=array[j];//后移
                j--;//比较指针迁移
            }else{
                break;
            }
        }
        //找到位置，插入元素
        array[j+1]=current;
    }
}
```

> 插入排序的衡量：
>
> - 是原地排序。空间复杂度为O(1).
> - 可以是稳定排序。在比较移动时，可以选择在相等元素的后面插入不掉换位置。但不一定是稳定排序
> - 时间复杂度为O($n^2$)。
>
> todo：插入排序有一个希尔排序的优化

### 选择排序

> 选择排序跟插入排序类似。
>
> - 插入排序是，看下一个元素需要插入到有序集合部分的什么位置。
> - 选择排序是，每次从无序集合部分找出最小数据，追加「替换」到有序集合部分。
>
> ![image-20201208105746068](https://gitee.com/wangigor/typora-images/raw/master/数据结构与算法-排序-选择排序.png)
>
> 这里的逆序度是，最小元素交换了几个位置，依次为跨了3、4、2、0、1、0，逆序度为10.

```java
public <T extends Comparable> void selectionSort(T[] array) {
    int array_length = array.length;
    if (array_length <= 1) {
        return;
    }

    //最后一个就不排了
    for (int i = 0; i < array_length-1; i++) {

        T min=array[i];
        int index_min=i;//最小值节点的下标
        //找到最小值
        for (int j=i;j<array_length;j++){
            T current=array[j];
            if(min.compareTo(current)>0){
                min=current;
                index_min=j;
            }
        }
        //交换
        //如果是自己没必要交换
        if(i!=index_min){
            array[index_min]=array[i];
            array[i]=min;
        }
    }
}
```

> 选择排序的衡量：
>
> - 时间复杂度为O($n^2$)。「即便是最好情况」
> - 空间复杂度O(1)。是原地排序。
> - 是**非稳定排序**。假设「5、2、5、1」这样的数据，首先交换了1和5，两个5的位置就发生了变化。

不使用选择排序，因为**选择排序是非稳定排序**。

**冒泡排序和插入排序，从效率上选择插入排序。**虽然他们的时间复杂度一样，但是交换方式不同：

```java
//插入排序-交换
array[j+1]=array[j];
//冒泡排序-交换
T temp = array[j];
array[j] = array[j + 1];
array[j + 1] = temp;
```

**随着数据量越来越大，性能差距会越来越明显。**

> 我在本机测试结果：
>
> 1000个随机数字排序「原数据相同」
>
> 插入排序：6ms
>
> 冒泡排序：23ms

## 「分治思想」类型

### 归并排序

> 归并排序是一种**分治思想**和**递归技巧**的结合。把一个长集合的排序简化为**子集合**的排序，最小转化为两个**子元素的交换**，再对子集合**合并**。
>
> ![image-20201209154729325](https://gitee.com/wangigor/typora-images/raw/master/数据结构与算法-排序-归并排序.png)
>
> - 递推公式
>
> ```逻辑
> mergeSort(array,q,p) = merge( mergeSort(array,q,r) , mergeSort(array,r+1,p) );
> # q和p是当前集合的起始下标，r是(q+p)/2的中间下标
> # mergeSort是归并排序公式
> # merge是合并公式
> ```
>
> - 递归终止条件
>
> ```逻辑
> q >= p;
> ```
>
> - merge合并函数
>
> 肯定不能采用元素交换实现。
>
> 需要开辟 temp[q-p]的临时空间，存储排序后的集合。
>
> ![image-20201209163430911](https://gitee.com/wangigor/typora-images/raw/master/数据结构与算法-排序-归并排序-merge.png)
>
> 最后再将排列好的数据，替换到[q,p]中。

```java
public static <T extends Comparable> void mergeSort(T[] array, int q, int p) {
    //递归终止
    if (q >= p) {
        return;
    }

    //分解
    int r = (q + p) / 2;
    mergeSort(array, q, r);
    mergeSort(array, r + 1, p);

    //合并
    merge(array, q, r, p);
}

private static <T extends Comparable> void merge(T[] array, int q, int r, int p) {
    //临时空间
    T[] temp = (T[]) new Comparable[p - q + 1];
    int left_index = q;
    int right_index = r + 1;

    //排序
    int i = 0;
    while (left_index <= r && right_index <= p) {
        if (array[left_index].compareTo(array[right_index]) > 0) {
            temp[i++] = array[right_index++];
        } else {
            temp[i++] = array[left_index++];
        }
    }

    //数组长度不相等的其余部分
    //优化「这里可以给两个数组都在最后追加一个MAX_VALUE哨兵位，可以省略下面代码」
    while (left_index <= r) {
        temp[i++] = array[left_index++];
    }
    while (right_index <= p) {
        temp[i++] = array[right_index++];
    }

    //覆盖回原数组
    for (int j = 0; j < temp.length; j++) {
        array[q++] = temp[j];
    }
}
```

> 归并排序的衡量：
>
> - 是稳定排序。
>
>   只有在merge方法中涉及到元素位置互换，而我们的方法是「**相等取左边集合元素**」。保证了相等数据原来的顺序。
>
> - 时间复杂度是O($nlogn$)。
>
>   假设对n个元素进行排序，所需时间为T(n)，拆分出来的两个子排序的时间就是T(n/2)。
>
>   对总长度为n的数据merge合并，时间复杂度是O(n)，所需时间也就是n。
>
>   当n=1时，T(1)=一个常量。
>
>   ```公式
>   T(n) = 2*T(n/2) + n
>        = 2*(2*T(n/4)+n/2)+n = 4*T(n/4)+2*n
>        = 4*(2*T(n/8)+n/4) +2*n= 8*T(n/8)+3*n
>        ...
>        = 2^k * T(n/ 2^k) + k*n
>   当n/ 2^k = 1时，
>   有k = logn。
>   T(n) = 2^k * T(n/ 2^k) + k*n
>        = n*T(1) + nlogn
>        = C*n + nlogn
>   ```
>
>   时间复杂度为O(nlogn)
>
> - 空间复杂度是O(n)。
>
>   空间复杂度O(n)有两种理解方式:
>
>   - 可以直接创建一个长度为n的临时数组，用于merge。
>   - 程序在执行时，每一次merge，都会创建一个临时数组，用完销毁，再用再创建。不会同时存在，且，大小都不会超过n

### 快速排序

> 快速排序和归并排序都是分治递归。
>
> 但是却**「完全相反」**，归并排序是在递归合并『回溯』的时候，把已经排序好的集合进行合并。而快速排序是把一个大集合逐步分成多个小集合完成排序，没有回溯环节。
>
> ![image-20201210160226124](https://gitee.com/wangigor/typora-images/raw/master/数据结构与算法-排序-快速排序.png)
>
> 过程：在集合中，找到一个随机的「**分界点**（简单的使用最后一个节点作为分界点）」pivot。遍历整个集合，把小于分界点的数据节点移到分界点左侧；把大于分界点的数据节点移到分界点右侧。然后分别对左右两个子集合进行快速排序。
>
> 根据分界点对集合进行拆分的方法「partition」，在快速排序中是一个空间复杂度为O(1)的方法，比归并排序更优化。
>
> ![image-20201210163510750](https://gitee.com/wangigor/typora-images/raw/master/数据结构与算法-排序-快速排序-partition.png)
>
> 两个指针，一个分界指针「q」,一个遍历指针「p」
>
> - 当遍历到的元素**小于**分界元素「pivot」时，说明这个元素应该在分解元素左侧，**分界指针右移**。
>
>   并**交换**遍历元素和分解指针指向的元素「如果是同一个元素，可以不交换，比如4」。
>
> - 当遍历到的元素**大于等于**分界元素「pivot」时，说明这个元素应该在分解元素右侧，**分解指针不动**。
>
> - 最后**交换pivot和分界**指向的两个元素。

```java
public static <T extends Comparable> void quickSort(T[] array, int start, int end) {

    //只有一个元素或者没有元素就不排了
    if (end - start < 1) {
        return;
    }
    
    int pivot = partition(array, start, end);

    quickSort(array, start, pivot - 1);
    quickSort(array, pivot + 1, end);
}

public static <T extends Comparable> int partition(T[] array, int start, int end) {
    int i = start, j = start;
    T pivot = array[end];
    for (; i < end; i++) {
        if (array[i].compareTo(pivot) < 0) {
            if(i!=j) {//同一个元素不需要交换
                T temp = array[i];
                array[i] = array[j];
                array[j] = temp;
            }
            j++;
        }
    }
  	
    array[end] = array[j];
    array[j] = pivot;
    return j;
}
```

> 快速排序的衡量：
>
> - 时间复杂度为O(nlogn)。跟归并排序一样。
> - 空间复杂度为O(1)。是原地排序。
> - 是**不稳定排序**。比如「6、7、6、3、4、5」，经过第一次partition之后，两个6前后位置变化。
>
> 快速排序有因为我们每次都选择最后一个节点作为分界点，如果原数据是有序的或者接近有序的，快速排序的时间复杂度最坏，是O($n^2$)。**分界点的选择不合理**。理想情况下，选出来的分界点应该在中间位置。
>
> - 三数取中法
>
>   从区间的首、尾、中间，分别取出一个数，然后对比大小，取这 3 个数的中间值作为分区点。这样每间隔某个固定的长度，取数据出来比较，将中间值作为分区点的分区算法，肯定要比单纯取某一个数据更好。但是，如果要排序的数组比较大，那“三数取中”可能就不够了，可能要“五数取中”或者“十数取中”。
>
> - 随机法
>
>   随机法就是每次从要排序的区间中，随机选择一个元素作为分区点。这种方法并不能保证每次分区点都选的比较好，但是从概率的角度来看，也不大可能会出现每次分区点都选得很差的情况，所以平均情况下，这样选的分区点是比较好的。时间复杂度退化为最糟糕的 O(n2) 的情况，出现的可能性不大。

==**寻找无序数组的第N大元素**==

就可以使用这种思路:

- 定一个随机点。
- 左侧区间为小于随机点的子集合，右侧为大于随机点的子集合。
- 判断随机点下标跟N的关系，得出第N大元素所在子集合。
- 递归开始，直到找到N。

时间复杂度为$n+n/2+n/4+n/8+...+1$=2n-1。也就是O(n)。

> 这个O(n)还是跟使用选择排序思想的O(n)不一样，选择排序思想，每次取一个最大值，直到取到第N大元素，时间复杂度为O(N*n)。**只有当N小于等于2时，使用选择排序思想才有可能比快排的查找时间复杂度低。**

***

**分治思想还可以体现在一些外部大文件排序上。**

比如一个10G的文件，要对里面的数据进行排序。

- 顺序读取，拆分成20个512M的小文件。
- 在内存中对每个小文件中的数据进行排序。
- 排序完成后，在内存中创建一个长度为20的数组。
- 从每一个文件中，读取一条数据放入内存数组中。
- 比较内存数组中数据大小，取最小值，写入新文件。
- 再从获取到最小值的文件中，读取一条数据，放入集合，在进行比较。
- 依次执行下去，直到所有文件读完。

## 「线性排序」类型

> 线性排序，本质也是基于分治思想的排序，但不像前面的基于集合区间的分治方式，而是采用按照类型区分分治。同时可以不是基于数据比较的排序方式。时间复杂度为O(n)。
>
> 但是线性排序对数据有严格的要求。

### 桶排序

> ![image-20201211145746410](https://gitee.com/wangigor/typora-images/raw/master/数据结构与算法-排序-桶排序.png)
>
> 将全部数据按照排序字段，划分出多个桶，比如已知排序订单金额大小在0-50万区间。
>
> - 划分出[0-9]、[10-19]、[20-29]、[30-39]、[40-49]五个桶
> - 遍历所有数据，对应放入桶中。
> - 再逐个对桶中的数据进行排序，比如快速排序。
> - 依次按照桶顺序读取数据。
>
> 跟前面分治算法处理10G数据文件不同的是，桶本身就有上下限的限制，桶是有序的。
>
> 假设n个数据分了k个桶。那么k个桶内的数据排序的时间复杂度是O($n/k*logn/k$)，加上遍历n个数据的时间复杂度O(n)，总时间复杂度为  $k*O(n/k*logn/k)+O(n)$。k越大越接近n时，总时间复杂度约等于O(n)。
>
> 有两个问题：
>
> - 如果一个桶中的数据太多，则需要再对桶的槽位进行更细划分。
> - 如果不确定数据上下线，需要遍历得到上下线。
>
> **桶排序比较适用于外部排序。**
>
> 桶排序的衡量：
>
> - 不是原地排序。空间复杂度为O(n)。
> - 可以是稳定排序。取决于桶内数据排序方式。
> - 时间复杂度。O(n)

### 计数排序

> **计数排序是桶排序的特例**，当数值区间不是段而是点的时候，就是计数排序。
>
> 计数排序适用于一些特殊数据的排序，比如年龄、成绩等等。
>
> 以成绩为例：10个学生，成绩是0~5分，有数据[2、4、5、2、3、4、5、3、2、0]
>
> ![image-20201211152934236](https://gitee.com/wangigor/typora-images/raw/master/数据结构与算法-排序-计数排序-原数据.png)
>
> - 创建一个长度为6的数组。分别对应0~5分的成绩。
> - **遍历**数据，对每个成绩分值进行**计数**。
>
> ![image-20201211153009897](https://gitee.com/wangigor/typora-images/raw/master/数据结构与算法-排序-计数排序-计数.png)
>
> - 数组遍历，**顺序求和**。
>
> ![image-20201211153243697](https://gitee.com/wangigor/typora-images/raw/master/数据结构与算法-排序-计数排序-顺序求和.png)
>
> ​		数组中的每一个数据代表了：**小于等于当前元素的数量。**
>
> - 遍历原数据，根据数据所在数组的计数，将数据移入新数组。
>
>   比如第一个数据2，在数组中对应4「说明小于等于2的数据有四个」，在新数组中2应该放在「4-1」的下标中。然后数组中对应计数减一「标识下一个2再来的时候，需要放在「3-1」的位置」
>
> ![image-20201211160630880](https://gitee.com/wangigor/typora-images/raw/master/数据结构与算法-排序-计数排序.png)

```java
/**
 * 对学生成绩的计数排序
 * 成绩：0~5分
 *
 * @param students
 */
private Student[] countingSort4Score(Student[] students) {

    //初始化计数数组
    int[] countingArray = new int[6];

    //计数
    for (int i = 0; i < students.length; i++) {
        countingArray[students[i].getScore()]++;
    }

    //数组顺序求和
    for (int i = 1; i < countingArray.length; i++) {
        countingArray[i] += countingArray[i - 1];
    }

    //放入新数组,倒序遍历
    Student[] orderedStudents = new Student[students.length];
    for (int i = students.length-1; i >=0; i++) {
        int index = countingArray[students[i].getScore()]-- - 1;
        orderedStudents[index] = students[i];
    }

    return orderedStudents;
}

@Data
@AllArgsConstructor
class Student {
    private String name;
    private int score;
}
```

计数排序只能用在**数据范围不大的场景**中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，**转化为非负整数**。

> 计数排序的衡量：
>
> - 不是原地排序。空间复杂度是O(k).
> - 可以是稳定排序。在最后放进新数组时，需要倒序遍历。
> - 时间复杂度为O(n)

### 基数排序

> 桶排序和计数排序，是排序字段在一定范围的情况。
>
> **基数排序是，排序字段是若干个在一定范围内的字段的组合。**比如电话号码「每一位都在0-9范围内」、单词「每一位都在a-z范围内」等等，他们有一个共同特点，就是从前往后元素的同一位比另一元素大，那么这个元素就大。
>
> 以电话号码来说，不可能给每一种可能的数字排列方式都创建一个计数器。但是电话是每一位都在0-9区间内的11位数字。
>
> 那么，按照10-0的顺序从后往前进行11次排序，采用时间复杂度为O(n)的桶排序「稳定排序」，就可以完成整个排序。

```java
/**
 * 电话号码排序
 *
 * @param telephoneNumbers
 */
private String[] arrayRadixSort(String[] telephoneNumbers) {

    //11次计数排序
    for (int i = 10; i >= 0; i--) {
        telephoneNumbers = countingSort(telephoneNumbers, i);
    }

    return telephoneNumbers;
}

/**
 * 基于下标的计数排序
 * @param telephoneNumbers
 * @param index 下标
 * @return
 */
private String[] countingSort(String[] telephoneNumbers, int index) {
    String[] results = new String[telephoneNumbers.length];
    int[] countingArray = new int[10];

    for (int i = 0; i < telephoneNumbers.length; i++) {
        int currentNum = getIntByIndex(telephoneNumbers[i],index);
        countingArray[currentNum]++;
    }

    for (int i = 1; i < countingArray.length; i++) {
        countingArray[i] += countingArray[i - 1];
    }

    for (int i = telephoneNumbers.length - 1; i >= 0; i--) {
        int currentNum = getIntByIndex(telephoneNumbers[i],index);
        int currentIndex = countingArray[currentNum]-- - 1;
        results[currentIndex] = telephoneNumbers[i];
    }

    return results;
}

private int getIntByIndex(String str, int index) {
    return Integer.valueOf(String.valueOf(str.charAt(index)));
}
```

> 基数排序的衡量：
>
> - 空间复杂度：O(n)。每个维度排序都要创建一个同等大小的空间。
> - 时间复杂度：O(n)。其实是O(n)*维度。
> - 可以是稳定排序。取决于每个维度的排序算法的稳定度。

但是对于单词排序，因为每个单词长度不同。

可以选择使每个单词都用右侧补零的方式变成一样长度的单词「字母的ascII码都大于0」。

## 排序选择

| 算法名称 | 时间复杂度     | 空间复杂度   | 是否稳定排序 |
| -------- | -------------- | ------------ | ------------ |
| 冒泡排序 | O($n^2$)       | O(1)原地排序 | 是           |
| 插入排序 | O($n^2$)       | O(1)原地排序 | 是           |
| 选择排序 | O($n^2$)       | O(1)原地排序 | 不是         |
| 归并排序 | O(nlogn)       | O(n)         | 是           |
| 快速排序 | O(nlogn)       | O(1)原地排序 | 不是         |
| 桶排序   | O(n)           | O(n)         | 是           |
| 计数排序 | O(n+k) k是范围 | O(n)         | 是           |
| 基数排序 | O(k*n) k是维度 | O(n)         | 是           |

### 递归深度问题

> 假如我们选择了不稳定的快速排序方法作为通用数据排序，还需要解决的是递归深度的问题。递归层级过深可能会导致栈溢出。
>
> 可以使用手动实现栈来代替递归操作。

```java
/**
 * 「快速排序」自定义栈实现递归
 */
public static <T extends Comparable> void customStackQuickSort(T[] array, int start, int end) {
    //定义一个栈
    Stack<Integer> indexStack = new Stack<>();
  	//按照左区间、右区间的顺序，把下标压入栈。
    indexStack.push(start);
    indexStack.push(end);
    while (!indexStack.isEmpty()) {
      	//按右区间、左区间方式，获取区间下标
        int right = indexStack.pop();
        int left = indexStack.pop();
				
      	//只处理有长度的部分
        if (right > left) {
          	//获取分界点
            int pivot = partition(array, left, right);
          	//小于分界点的下标入栈
            indexStack.push(left);
            indexStack.push(pivot-1);
          	//大于分界点的下标入栈
            indexStack.push(pivot + 1);
            indexStack.push(right);
        }
    }
}
```

### Arrays.sort/Collections.sort源码解析

> 因为线性排序使用场景较少，作为通用数据排序肯定不会选择线性排序。
>
> 那么O(nlogn)的快速排序和递归排序，因为稳定度不同，jdk也作出了不同的策略选择：
>
> - 基础数据类型以**快速排序**为主，且使用了**双轴快排**
> - 其他数据类型「实现了Comparable接口的」以**归并排序**为主
>
> 并且根据数据量大小，使用了了O($n^2$)的**插入排序**「原地排序」等进行性能优化。

#### 基础数据类型

```java
public static void sort(int[] a) {
  	//双轴快排
    DualPivotQuicksort.sort(a, 0, a.length - 1, null, 0, 0);
}
```

##### 有序检测和归并

```java
/**
 * a :要排序的数组
 * left :要排序数组的起始下标
 * right :要排序数组的最后元素下标
 * work :工作数组「也就是进行快排的temp数组，可以率先指定，如果不指定会自动创建」
 * workBase :工作数组可用区间的起始下标
 * workLen :工作数组可用长度
 */
static void sort(int[] a, int left, int right,
                 int[] work, int workBase, int workLen) {
    //排序长度小于286的使用双轴快速排序
    if (right - left < QUICKSORT_THRESHOLD) {
        sort(a, left, right, true);
        return;
    }

		//先查看数据是否基本有序
  	//比如8、5、3、2、9、6、4、1、2、4、6、8这样的数据，从第一个数据开始找到降序组/升序组
  	//「8、5、3、2」『9、6、4、1』是两个降序组，降序组翻转『2、3、5、8』『1、4、6、9』
  	//「2、4、6、8」是升序组 升序组不变
  	//进行这样的升序降序分组之后，会变成锯齿形分段升序
  	//如果基本有序「升序组数小于68次」：使用归并排序
  	//如果基本无序「升序组数大于68次」：采用双轴快排
    int[] run = new int[MAX_RUN_COUNT + 1];
    int count = 0; run[0] = left;

    //开始68轮进行是否有序检测
    for (int k = left; k < right; run[count] = k) {
      	//升序组
      	//记录升序组的最远下标
        if (a[k] < a[k + 1]) {
            while (++k <= right && a[k - 1] <= a[k]);
        //降序组
        //记录降序组的最远下标
        //并反转降序组为升序组
        } else if (a[k] > a[k + 1]) {
            while (++k <= right && a[k - 1] >= a[k]);
            for (int lo = run[count] - 1, hi = k; ++lo < --hi; ) {
                int t = a[lo]; a[lo] = a[hi]; a[hi] = t;
            }
        //有相等数据
        //相等的数据长度有32个就直接使用双轴快排
        } else {
            for (int m = MAX_RUN_LENGTH; ++k <= right && a[k - 1] == a[k]; ) {
                if (--m == 0) {
                    sort(a, left, right, true);
                    return;
                }
            }
        }
				//升序组个数到达68，说明基本无序，使用双轴快排
        if (++count == MAX_RUN_COUNT) {
            sort(a, left, right, true);
            return;
        }
    }

  
    // 特殊情况处理
    // 如果最后一个降序组只包含一个元素，为数组添加一个right++的哨兵
  	//run[0]一定是0，count是right+1
  	//8、5、3、2、9、6、4、1、2、4、6、8...这样的数据对应的run是[0，4，8，12...]
    if (run[count] == right++) {
        run[++count] = right;
    //如果只有一个降序组，说明已经有序了。
    } else if (count == 1) {
        return;
    }

    //确定count是2的奇偶次幂
  	//8是2的3次幂 odd=0
  	//9「16」是2的4次幂 odd=1
  	//因为只有一个temp数组。两两合并时，最后是要把temp合并到a，那奇数次方需要从temp到a开始。
  	//而偶数次方需要从a合并到temp开始
  	//比方有8个降序组，奇数，先把整个8个降序组合并到4个降序组「temp->a」,再把4个降序组合并到2个降序组「a->temp」,再把两个降序组合并成一个「temp->a」
    byte odd = 0;
    for (int n = 1; (n <<= 1) < count; odd ^= 1);

    
    int[] b;                 // 临时合并数组
    int ao, bo;              // array offsets from 'left'
    int blen = right - left; // 排序数据全长
  	//如果work空间不足，创建一个等长O(n)的数组「为了合并数据使用」
    if (work == null || workLen < blen || workBase + blen > work.length) {
        work = new int[blen];
        workBase = 0;
    }
  
    if (odd == 0) {
      	//把整个要排序对象a，拷贝进排序空间work中
        System.arraycopy(a, left, work, workBase, blen);
        b = a;//b指向原数据a
        bo = 0;
        a = work;//a指向工作空间
        ao = workBase - left;
    } else {
        b = work;//b指向工作空间，a不动
        ao = 0;
        bo = workBase - left;
    }

    // 归并
  	// 外层循环直到count=1，只剩一个降序组时完成排序
  	// 把a中的数据合并到b中。
    for (int last; count > 1; count = last) {
      	//内层循环将相邻两个降序组合并
        for (int k = (last = 0) + 2; k <= count; k += 2) {
          	//合并k-1和k-2
            int hi = run[k], mi = run[k - 1];
          	//p是k-2组的遍历指针 初始为k-2的最小值
          	//q是k-1组的遍历指针 初始为k-1的最小值
            for (int i = run[k - 2], p = i, q = mi; i < hi; ++i) {
              	//合并到b中「长度不齐的也在这里」
                if (q >= hi || p < mi && a[p + ao] <= a[q + ao]) {
                    b[i + bo] = a[p++ + ao];
                } else {
                    b[i + bo] = a[q++ + ao];
                }
            }
          	//在run中记录当前这一次k-1和k-2合并完成的最大下标也就是run[k]
            run[++last] = hi;
        }
      	//如果count是奇数
        if ((count & 1) != 0) {
          	//把剩余的那个降序组移入b中
            for (int i = right, lo = run[count - 1]; --i >= lo;
                b[i + bo] = a[i + ao]
            );
            run[++last] = right;
        }
      	//调换a/b
      	//调换ao/bo
        int[] t = a; a = b; b = t;
        int o = ao; ao = bo; bo = o;
    }
}
```

##### 双轴快排

```java
/**
 * 对要排序数组的指定区间进行双轴快排
 * @param a 要排序数组
 * @param left 起始下标
 * @param right 末尾下标
 * @param leftmost 要排序段是不是位于a最左侧
 */
private static void sort(int[] a, int left, int right, boolean leftmost) {
  	//排序数组全长
    int length = right - left + 1;

    // 小于47个元素，使用插入排序
    if (length < INSERTION_SORT_THRESHOLD) {
      	//如果要排序段位于a最左侧
        if (leftmost) {
            //使用传统的插入排序
            for (int i = left, j = i; i < right; j = ++i) {
                int ai = a[i + 1];
                while (ai < a[j]) {
                    a[j + 1] = a[j];
                    if (j-- == left) {
                        break;
                    }
                }
                a[j + 1] = ai;
            }
        } else {
            //跳过开始部分最长的升序端
            do {
                if (left >= right) {
                    return;
                }
            } while (a[++left] >= a[left - 1]);
						//从left取出两个元素
          	//因为主要涉及元素移动，为了减少移动次数，两个两个元素的移动，这就需要左侧有数据。
            for (int k = left; ++left <= right; k = ++left) {
                int a1 = a[k], a2 = a[left];

              	//比较大的元素是a1
                if (a1 < a2) {
                    a2 = a1; a1 = a[left];
                }
              	//先把较大的元素移动到对的位置
                while (a1 < a[--k]) {
                    a[k + 2] = a[k];
                }
                a[++k + 1] = a1;
								
              	//再把较小的元素移动到正确的位置
                while (a2 < a[--k]) {
                    a[k + 1] = a[k];
                }
                a[k + 1] = a2;
            }
          
          	//最后一个元素移动到正确位置「奇数个会移动，偶数个不需要」
            int last = a[right];
            while (last < a[--right]) {
                a[right + 1] = a[right];
            }
            a[right + 1] = last;
        }
        return;
    }

    // length / 7的近似算法版本（length* 9/64  + 1）。「todo 真没看懂」
    int seventh = (length >> 3) + (length >> 6) + 1;

		
  	//整个要排序数组7「不等分」
  	// +---------------------------------------+
  	// | 1.5/7 | 1/7 | 1/7 | 1/7 | 1/7 | 1.5/7 |
  	// e0      e1    e2    e3    e4    e5      e6
  	// +---------------------------------------+
  	//中间总共取5个指针,左右e0和e5总共占3/7
    int e3 = (left + right) >>> 1; // The midpoint
    int e2 = e3 - seventh;
    int e1 = e2 - seventh;
    int e4 = e3 + seventh;
    int e5 = e4 + seventh;

    //手动对这五个点的数据进行排序
    if (a[e2] < a[e1]) { int t = a[e2]; a[e2] = a[e1]; a[e1] = t; }

    if (a[e3] < a[e2]) { int t = a[e3]; a[e3] = a[e2]; a[e2] = t;
        if (t < a[e1]) { a[e2] = a[e1]; a[e1] = t; }
    }
    if (a[e4] < a[e3]) { int t = a[e4]; a[e4] = a[e3]; a[e3] = t;
        if (t < a[e2]) { a[e3] = a[e2]; a[e2] = t;
            if (t < a[e1]) { a[e2] = a[e1]; a[e1] = t; }
        }
    }
    if (a[e5] < a[e4]) { int t = a[e5]; a[e5] = a[e4]; a[e4] = t;
        if (t < a[e3]) { a[e4] = a[e3]; a[e3] = t;
            if (t < a[e2]) { a[e3] = a[e2]; a[e2] = t;
                if (t < a[e1]) { a[e2] = a[e1]; a[e1] = t; }
            }
        }
    }

    // Pointers
    int less  = left;  // The index of the first element of center part
    int great = right; // The index before the first element of right part

    if (a[e1] != a[e2] && a[e2] != a[e3] && a[e3] != a[e4] && a[e4] != a[e5]) {
        //取e2和e4作为两个pivot
        int pivot1 = a[e2];
        int pivot2 = a[e4];
				//可以理解为两个null节点，最后还得替换回去
        a[e2] = a[left];
        a[e4] = a[right];

        //找到左侧天然小于pivot1的区间 和 右侧天然大于pivot2的区间
        while (a[++less] < pivot1);
        while (a[--great] > pivot2);

        /*
         * Partitioning:
         *
         *   left part           center part                   right part
         * +--------------------------------------------------------------+
         * |  < pivot1  |  pivot1 <= && <= pivot2  |    ?    |  > pivot2  |
         * +--------------------------------------------------------------+
         *               ^                          ^       ^
         *               |                          |       |
         *              less                        k     great
         *
         * Invariants:
         *
         *              all in (left, less)   < pivot1
         *    pivot1 <= all in [less, k)     <= pivot2
         *              all in (great, right) > pivot2
         *
         * Pointer k is the first index of ?-part.
         */
      	//遍历less到great中间的部分
      	//使用less和great两个活动的pivot「轴」，从两端开始，把整个要排序区间划为「...less...great...」三个区间
        outer:
        for (int k = less - 1; ++k <= great; ) {
            int ak = a[k];
          	//如果元素小于pivot1，放入左侧区间「跟less交换位置」
          	//less右移
            if (ak < pivot1) { 
                a[k] = a[less];
                /*
                 * Here and below we use "a[i] = b; i++;" instead
                 * of "a[i++] = b;" due to performance issue.
                 *
                 * a[i++]=b 可以理解为
                 * mov temp i
                 * inc i
                 * mov a[temp] b

                 * a[i]=b; i++ 可以理解为
                 * mov a[i]=b
                 * inc i
                 * 但是我没测出差异，class也都是一样的。应该是被编译器优化掉了。
                 */
                a[less] = ak;
                ++less;
            //如果元素大于pivot2，放入右侧区间「跟great交换位置」
            //great左移
            } else if (ak > pivot2) {
              	//如果置换出来的greate节点大于pivot2，说明两个元素都应该在右侧区间
              	//一直找到小于等于右区间边界的元素，如果到k了，说明「k，greate」之间的所有元素都应该在右区间，已经完成全部中间数据的遍历
                while (a[great] > pivot2) {
                    if (great-- == k) {
                        break outer;
                    }
                }
              	//如果置换出来的元素属于左侧区间，放入左侧区间，less右移
                if (a[great] < pivot1) {
                    a[k] = a[less];
                    a[less] = a[great];
                    ++less;
                //属于中间区间
                } else {
                    a[k] = a[great];
                }
               	//greate左移
                a[great] = ak;
                --great;
            }
        }

        // 把两个pivot放入所在的less和great位置
        a[left]  = a[less  - 1]; a[less  - 1] = pivot1;
        a[right] = a[great + 1]; a[great + 1] = pivot2;

      	//开始递归
        //对pivot1左侧的区间进行双轴快排
      	//对pivot2右侧的区间进行双轴快排
        sort(a, left, less - 2, leftmost);
        sort(a, great + 2, right, false);

        //如果中间区域还是太大，占了整个要排序区间总大小的4/7以上
        if (less < e1 && e5 < great) {
            //先跳过中间等于两个pivot的元素
            while (a[less] == pivot1) {
                ++less;
            }
            while (a[great] == pivot2) {
                --great;
            }

            /*
             * Partitioning:
             *
             *   left part         center part                  right part
             * +----------------------------------------------------------+
             * | == pivot1 |  pivot1 < && < pivot2  |    ?    | == pivot2 |
             * +----------------------------------------------------------+
             *              ^                        ^       ^
             *              |                        |       |
             *             less                      k     great
             *
             * Invariants:
             *
             *              all in (*,  less) == pivot1
             *     pivot1 < all in [less,  k)  < pivot2
             *              all in (great, *) == pivot2
             *
             * Pointer k is the first index of ?-part.
             */
            outer:
            for (int k = less - 1; ++k <= great; ) {
                int ak = a[k];
                if (ak == pivot1) { // Move a[k] to left part
                    a[k] = a[less];
                    a[less] = ak;
                    ++less;
                } else if (ak == pivot2) { // Move a[k] to right part
                    while (a[great] == pivot2) {
                        if (great-- == k) {
                            break outer;
                        }
                    }
                    if (a[great] == pivot1) { // a[great] < pivot2
                        a[k] = a[less];
                        a[less] = pivot1;
                        ++less;
                    } else { // pivot1 < a[great] < pivot2
                        a[k] = a[great];
                    }
                    a[great] = ak;
                    --great;
                }
            }
        }
      	//经过上面这一步区分出了三块区间[ ==pivot1 , >pivot1 <pivot2 , ==pivot2 ]
        //对中间>pivot1 <pivot2进行双轴快排
        sort(a, less, great, false);

    } else {
      	//如果5个点有数据相等，取中间的e3进行传统的快排
        int pivot = a[e3];
      
      	//下面逻辑跟之前重复就不看了
        /*
         * Partitioning degenerates to the traditional 3-way
         * (or "Dutch National Flag") schema:
         *
         *   left part    center part              right part
         * +-------------------------------------------------+
         * |  < pivot  |   == pivot   |     ?    |  > pivot  |
         * +-------------------------------------------------+
         *              ^              ^        ^
         *              |              |        |
         *             less            k      great
         *
         * Invariants:
         *
         *   all in (left, less)   < pivot
         *   all in [less, k)     == pivot
         *   all in (great, right) > pivot
         *
         * Pointer k is the first index of ?-part.
         */
        for (int k = less; k <= great; ++k) {
            if (a[k] == pivot) {
                continue;
            }
            int ak = a[k];
            if (ak < pivot) { // Move a[k] to left part
                a[k] = a[less];
                a[less] = ak;
                ++less;
            } else { // a[k] > pivot - Move a[k] to right part
                while (a[great] > pivot) {
                    --great;
                }
                if (a[great] < pivot) { // a[great] <= pivot
                    a[k] = a[less];
                    a[less] = a[great];
                    ++less;
                } else { // a[great] == pivot
                    a[k] = pivot;
                }
                a[great] = ak;
                --great;
            }
        }

				//两侧进行双轴快排
        sort(a, left, less - 1, leftmost);
        sort(a, great + 1, right, false);
    }
}
```

#### Comparable接口数据类型

```java
public static void sort(Object[] a) {
  	//传统归并「跟前面的归并排序基本一样」
  	//递归实现，而不是手动栈
  	//可以通过java.util.Arrays.useLegacyMergeSort=true系统参数指定
    if (LegacyMergeSort.userRequested)
        legacyMergeSort(a);
    //TimSort
    else
        ComparableTimSort.sort(a, 0, a.length, null, 0, 0);
}
```

##### ComparableTimSort

>  是由Tim Peters 2002年提出的 [论文](https://svn.python.org/projects/python/trunk/Objects/listsort.txt)，最好时间复杂度为O(n)
>
>  - 数据量少的时候，使用二分查找插入排序。
>
>  - 数据量多的时候，将所有数据切割为多个升序段，并对升序段进行归并。
>
>  - 两个升序段的归并，使用疾跑模式。
>
>  使用了**GALLOP疾跑模式**，我觉得疾跑模式的出现是为了**减少数据搬移次数**，在一个子集合中找到**一小段**可以一起搬移的数据进行**System.arraycopy**。

```java
class ComparableTimSort {
    /**
     * 递归排序的最小长度
     * 小于32使用二分查找插入排序
     */
    private static final int MIN_MERGE = 32;

    /**
     * 将要被排序的数组
     */
    private final Object[] a;

    /**
     * 疾跑模式「galloping」的阈值
     */
    private static final int  MIN_GALLOP = 7;
    private int minGallop = MIN_GALLOP;//进入疾跑模式的时机

    /**
     * temp数组的初始长度
     * 为了提升性能，小于256不使用temp数组
     */
    private static final int INITIAL_TMP_STORAGE_LENGTH = 256;

    /**
     * 用于归并合并的temp数组
     */
    private Object[] tmp;
    private int tmpBase; // 当前使用的起始下标
    private int tmpLen;  // 当前使用的长度

		/**
		 * 栈
		 * 里面记录了每一个升序组的长度及下标，所以使用了两个数组
		 */
    private int stackSize = 0;  // 栈的已使用长度
    private final int[] runBase; // 起始下标栈
    private final int[] runLen; //长度栈

   
    private ComparableTimSort(Object[] a, Object[] work, int workBase, int workLen) {
        this.a = a;

        int len = a.length;
      	//用于归并的work数组初始化
      	//要排序数组元素小于512个，使用length/2，否则使用256
        int tlen = (len < 2 * INITIAL_TMP_STORAGE_LENGTH) ?
            len >>> 1 : INITIAL_TMP_STORAGE_LENGTH;
        if (work == null || workLen < tlen || workBase + tlen > work.length) {
            tmp = new Object[tlen];
            tmpBase = 0;
            tmpLen = tlen;
        }
        else {
            tmp = work;
            tmpBase = workBase;
            tmpLen = workLen;
        }

        /*
         * 初始化运行栈的两个数组
         */
        int stackLen = (len <    120  ?  5 :
                        len <   1542  ? 10 :
                        len < 119151  ? 24 : 49);
        runBase = new int[stackLen];
        runLen = new int[stackLen];
    }

    /**
     * @param a 要排序数组
     * @param lo 要排序数组的起始下标
     * @param hi 要排序数组的末尾下标
     * @param work 归并临时数组
     * @param workBase 临时数组起始下标
     * @param workLen 临时数组可用长度
     * @since 1.8
     */
    static void sort(Object[] a, int lo, int hi, Object[] work, int workBase, int workLen) {
        assert a != null && lo >= 0 && lo <= hi && hi <= a.length;

        int nRemaining  = hi - lo;
        if (nRemaining < 2)
            return;  // Arrays of size 0 and 1 are always sorted

        // 小于32 使用基于二分查找的插入排序
        if (nRemaining < MIN_MERGE) {
            int initRunLen = countRunAndMakeAscending(a, lo, hi);
            binarySort(a, lo, hi, lo + initRunLen);
            return;
        }

        //创建一个ComparableTimSort
        ComparableTimSort ts = new ComparableTimSort(a, work, workBase, workLen);
      	//返回最小升序组长度
        int minRun = minRunLength(nRemaining);
        do {
            //从lo开始获取第一个升序组\降序组长度，并转为升序组
            int runLen = countRunAndMakeAscending(a, lo, hi);

            //如果当前这一个升序组的长度小于最小最小升序组长度minRun
            if (runLen < minRun) {
              	//使用剩余量nRemaining和minRun的最小值
              	//对这一组数据使用二分插入排序
                int force = nRemaining <= minRun ? nRemaining : minRun;
                binarySort(a, lo, lo + force, lo + runLen);
                runLen = force;
            }

            // 升序组的下标和长度放入栈中
            ts.pushRun(lo, runLen);
          	// 检测当前升序组是否需要合并
            ts.mergeCollapse();

            // Advance to find next run
            lo += runLen;
            nRemaining -= runLen;
        } while (nRemaining != 0);//未排序长度等于0就退出

        //强制合并
        assert lo == hi;
        ts.mergeForceCollapse();
        assert ts.stackSize == 1;
    }

  	/**
  	 * 基于二分查找的插入排序
  	 * 比较简单，就不注释了。
  	 */
    @SuppressWarnings({"fallthrough", "rawtypes", "unchecked"})
    private static void binarySort(Object[] a, int lo, int hi, int start) {
        assert lo <= start && start <= hi;
        if (start == lo)
            start++;
        for ( ; start < hi; start++) {
            Comparable pivot = (Comparable) a[start];

            int left = lo;
            int right = start;
            assert left <= right;

            while (left < right) {
              	//二分查找要插入的位置
                int mid = (left + right) >>> 1;
                if (pivot.compareTo(a[mid]) < 0)
                    right = mid;
                else
                    left = mid + 1;
            }
            assert left == right;

            int n = start - left;
            //插入
          	// 需要移动的长度个数做了优化，1、2的时候使用手动，其他时候使用System.arraycopy
            switch (n) {
                case 2:  a[left + 2] = a[left + 1];
                case 1:  a[left + 1] = a[left];
                         break;
                default: System.arraycopy(a, left, a, left + 1, n);
            }
            a[left] = pivot;
        }
    }

		/**
		 * 获取当前子集合的第一个升序组\降序组，转换为升序组
		 * 返回长度
		 */
    @SuppressWarnings({"unchecked", "rawtypes"})
    private static int countRunAndMakeAscending(Object[] a, int lo, int hi) {
        assert lo < hi;
        int runHi = lo + 1;
        if (runHi == hi)
            return 1;

        if (((Comparable) a[runHi++]).compareTo(a[lo]) < 0) { // 降序
            while (runHi < hi && ((Comparable) a[runHi]).compareTo(a[runHi - 1]) < 0)
                runHi++;
            reverseRange(a, lo, runHi);
        } else {                              // 升序
            while (runHi < hi && ((Comparable) a[runHi]).compareTo(a[runHi - 1]) >= 0)
                runHi++;
        }
        return runHi - lo;
    }

    /**
     * 降序组反转为升序组
     */
    private static void reverseRange(Object[] a, int lo, int hi) {
        hi--;
        while (lo < hi) {
            Object t = a[lo];
            a[lo++] = a[hi];
            a[hi--] = t;
        }
    }

    /**
     * 获取最小「升序组」长度
     * 当 n是2的指数幂时，返回MIN_MERGE/2=16
     * 当 n<32时，返回32
     * 其他情况，返回[16~32]自建的某个数字 比如100返回25 比如10000返回22
     * 其实就是intbinaryString非零位的前5位转int+后面1的个数
     */
    private static int minRunLength(int n) {
        assert n >= 0;
        int r = 0;     
        while (n >= MIN_MERGE) {
            r |= (n & 1);
            n >>= 1;
        }
        return n + r;
    }

    /**
     * 升序组的起始下标和长度 放入栈中
     */
    private void pushRun(int runBase, int runLen) {
        this.runBase[stackSize] = runBase;
        this.runLen[stackSize] = runLen;
        stackSize++;
    }

    /**
     * 检查当前栈中是否需要进行合并
     */
    private void mergeCollapse() {
        while (stackSize > 1) {
            int n = stackSize - 2;
          	//栈顶的三个升序组 长度进行比较
          	//如果第三个的长度小于等于前两个长度之和 合并一和二 如果第三个的长度小于第一个 合并二和三
            if (n > 0 && runLen[n-1] <= runLen[n] + runLen[n+1]) {
                if (runLen[n - 1] < runLen[n + 1])
                    n--;
                mergeAt(n);
            //栈顶两个升序组 长度进行比较
            //如果第二个小于等于第一个长度，合并一和二
            } else if (runLen[n] <= runLen[n + 1]) {
                mergeAt(n);
            } else {
                break; // 不进行合并
            }
        }
    }

    /**
     * 最后的强制合并
     */
    private void mergeForceCollapse() {
        while (stackSize > 1) {
            int n = stackSize - 2;
            if (n > 0 && runLen[n - 1] < runLen[n + 1])
                n--;
            mergeAt(n);
        }
    }

    /**
     * 合并升序组
     */
    @SuppressWarnings("unchecked")
    private void mergeAt(int i) {
        assert stackSize >= 2;
        assert i >= 0;
        assert i == stackSize - 2 || i == stackSize - 3;

      	//获取两个要合并的升序组的长度和起始下标
      	//  +------+
      	//  | run2 |
        //  --------
        //  | run1 |
        //  +------+
        int base1 = runBase[i];
        int len1 = runLen[i];
        int base2 = runBase[i + 1];
        int len2 = runLen[i + 1];
        assert len1 > 0 && len2 > 0;
        assert base1 + len1 == base2;

      	
      	//两个「栈帧」「合并」为一个
      	//更新run1的尺寸 如果run1、run2后面只有一个栈帧，更新run2
        runLen[i] = len1 + len2;
        if (i == stackSize - 3) {
            runBase[i + 1] = runBase[i + 2];
            runLen[i + 1] = runLen[i + 2];
        }
        stackSize--;

        /*
         * 找到「run2的第一个元素」在run1中的位置，如果有相同元素，返回最右侧元素位置
         * a[base1 + k - 1] <= ? < a[base1 + k]
         */
        int k = gallopRight((Comparable<Object>) a[base2], a, base1, len1, 0);
        assert k >= 0;
      	//修改base1
        base1 += k;
        len1 -= k;
      	//如果run2第一个元素在run1最后一个元素后面，说明已经有序
      	//停止合并
        if (len1 == 0)
            return;

        /*
         * 找到「run1的最后一个元素」在run2中的位置，如果有相同元素，返回最左侧元素
         * a[base2 + len2 - 1] < ? <= a[base2 + len2]
         */
        len2 = gallopLeft((Comparable<Object>) a[base1 + len1 - 1], a,
                base2, len2, len2 - 1);
        assert len2 >= 0;
      	//如果run1最后一个元素在run2第一个元素前面，说明已经有序
      	//停止合并
        if (len2 == 0)
            return;

        // 合并run1 run2
        if (len1 <= len2)
            mergeLo(base1, len1, base2, len2);
        else
            mergeHi(base1, len1, base2, len2);
    }

    /**
     * 「疾跑模式」定位key在a中的位置，有相等元素返回左侧的元素下标
     * a[base + ofs - 1] < key <= a[base + ofs]
     */
    private static int gallopLeft(Comparable<Object> key, Object[] a,
            int base, int len, int hint) {
        assert len > 0 && hint >= 0 && hint < len;

        int lastOfs = 0;
        int ofs = 1;
      	//如果key大于a中hint的基准元素
      	//查找key应该出在a中的大概位置[ lastOfs,ofs]之间
        if (key.compareTo(a[base + hint]) > 0) {
            // Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]
            int maxOfs = len - hint;
            while (ofs < maxOfs && key.compareTo(a[base + hint + ofs]) > 0) {
                lastOfs = ofs;
              	//这里ofs采用  1，3，7，15，31...往后查找
              	//lastOft就是  0，1，3，7，15，31...
                ofs = (ofs << 1) + 1;
                if (ofs <= 0)   // int overflow
                    ofs = maxOfs;
            }
            if (ofs > maxOfs)
                ofs = maxOfs;

            //ofs和lastOfs向基准hint看起
            lastOfs += hint;
            ofs += hint;
        } else {
          	//如果key小于等于key的基准元素
            // Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]
            final int maxOfs = hint + 1;
            while (ofs < maxOfs && key.compareTo(a[base + hint - ofs]) <= 0) {
                lastOfs = ofs;
                ofs = (ofs << 1) + 1;
                if (ofs <= 0)   // int overflow
                    ofs = maxOfs;
            }
            if (ofs > maxOfs)
                ofs = maxOfs;

            // Make offsets relative to base
            int tmp = lastOfs;
            lastOfs = hint - ofs;
            ofs = hint - tmp;
        }
        assert -1 <= lastOfs && lastOfs < ofs && ofs <= len;

       	//在ofs到lastOfs之间做二分查找，找到key所在的精确位置。
        lastOfs++;
        while (lastOfs < ofs) {
            int m = lastOfs + ((ofs - lastOfs) >>> 1);

            if (key.compareTo(a[base + m]) > 0)
                lastOfs = m + 1;  // a[base + m] < key
            else
                ofs = m;          // key <= a[base + m]
        }
        assert lastOfs == ofs;    // so a[base + ofs - 1] < key <= a[base + ofs]
        return ofs;
    }

    /**
     * 「疾跑模式」
     * 找到key在a中的位置，有相等元素，返回右侧元素的下标
     * 跟left一样，先用疾跑模式确定范围，在用二分查找精确下标
     * a[b + ofs - 1] <= key < a[b + ofs]
     */
    private static int gallopRight(Comparable<Object> key, Object[] a,
            int base, int len, int hint) {
        assert len > 0 && hint >= 0 && hint < len;

        int ofs = 1;
        int lastOfs = 0;
        if (key.compareTo(a[base + hint]) < 0) {
            // Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]
            int maxOfs = hint + 1;
            while (ofs < maxOfs && key.compareTo(a[base + hint - ofs]) < 0) {
                lastOfs = ofs;
                ofs = (ofs << 1) + 1;
                if (ofs <= 0)   // int overflow
                    ofs = maxOfs;
            }
            if (ofs > maxOfs)
                ofs = maxOfs;

            // Make offsets relative to b
            int tmp = lastOfs;
            lastOfs = hint - ofs;
            ofs = hint - tmp;
        } else { // a[b + hint] <= key
            // Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]
            int maxOfs = len - hint;
            while (ofs < maxOfs && key.compareTo(a[base + hint + ofs]) >= 0) {
                lastOfs = ofs;
                ofs = (ofs << 1) + 1;
                if (ofs <= 0)   // int overflow
                    ofs = maxOfs;
            }
            if (ofs > maxOfs)
                ofs = maxOfs;

            // Make offsets relative to b
            lastOfs += hint;
            ofs += hint;
        }
        assert -1 <= lastOfs && lastOfs < ofs && ofs <= len;

        lastOfs++;
        while (lastOfs < ofs) {
            int m = lastOfs + ((ofs - lastOfs) >>> 1);

            if (key.compareTo(a[base + m]) < 0)
                ofs = m;          // key < a[b + m]
            else
                lastOfs = m + 1;  // a[b + m] <= key
        }
        assert lastOfs == ofs;    // so a[b + ofs - 1] <= key < a[b + ofs]
        return ofs;
    }

    /**
     * run2：+-----------------------+
     *      |   len2  |    有序空间   |
     *    base2----------------------+
     *
     * run1：+-----------------------+
     *      |   有序空间   |   len1   |
     *      +-----------base1--------+
     * mergeLo对「len1 <= len2」情况进行排序
     * 前提是 a[base1] > a[base2] && run1的最后一个元素大于run2中所有元素
     */
    private void mergeLo(int base1, int len1, int base2, int len2) {
        assert len1 > 0 && len2 > 0 && base1 + len1 == base2;

        // Copy first run into temp array
        Object[] a = this.a; // For performance
        Object[] tmp = ensureCapacity(len1);

      	
      	//先把run1的数据拷贝进tmp排序数组中
        int cursor1 = tmpBase; 
        int cursor2 = base2;
        int dest = base1;      
        System.arraycopy(a, base1, tmp, cursor1, len1);

        // 把run2的第一个元素，放入base1处「操作a数组」
        a[dest++] = a[cursor2++];
      	//处理退化情况
      	//如果run2没有元素了，把tmp中的run1元素拷贝进数组a
      	//完成归并
        if (--len2 == 0) {
            System.arraycopy(tmp, cursor1, a, dest, len1);
            return;
        }
      	//如果run1只有一个元素
      	//把run2所有元素拷贝进a中，再拷贝run1中的最后一个元素
      	//完成归并
        if (len1 == 1) {
            System.arraycopy(a, cursor2, a, dest, len2);
            a[dest + len2] = tmp[cursor1];
            return;
        }

        int minGallop = this.minGallop;  // Use local variable for performance
    outer:
        while (true) {
            int count1 = 0; // Number of times in a row that first run won
            int count2 = 0; // Number of times in a row that second run won

          
          	//一轮「抢七」
            //持续对比数据 谁小谁放回a中 
          	//如果其中一个run没有数据了，退出
            do {
                assert len1 > 1 && len2 > 0;
                if (((Comparable) a[cursor2]).compareTo(tmp[cursor1]) < 0) {
                    a[dest++] = a[cursor2++];
                    count2++;
                    count1 = 0;
                    if (--len2 == 0)
                        break outer;
                } else {
                    a[dest++] = tmp[cursor1++];
                    count1++;
                    count2 = 0;
                    if (--len1 == 1)
                        break outer;
                }
              //直到run1 run2 有一方累计胜利7次
            } while ((count1 | count2) < minGallop);

						//一轮「疾跑模式抢七」
            do {
                assert len1 > 1 && len2 > 0;
              	//开始疾跑模式 查找run1中『小于等于run2当前元素的全部元素』
                count1 = gallopRight((Comparable) a[cursor2], tmp, cursor1, len1, 0);
              	//批量追加进a中
                if (count1 != 0) {
                    System.arraycopy(tmp, cursor1, a, dest, count1);
                    dest += count1;
                    cursor1 += count1;
                    len1 -= count1;
                    if (len1 <= 1)  // len1 == 1 || len1 == 0
                        break outer;
                }
              	//追加run2当前元素
                a[dest++] = a[cursor2++];
              	//检查是否归并退出条件
                if (--len2 == 0)
                    break outer;

              	//开始疾跑模式 查找run2中『小于run1当前元素的全部元素』
                count2 = gallopLeft((Comparable) tmp[cursor1], a, cursor2, len2, 0);
              	//追加进a中
                if (count2 != 0) {
                    System.arraycopy(a, cursor2, a, dest, count2);
                    dest += count2;
                    cursor2 += count2;
                    len2 -= count2;
                    if (len2 == 0)
                        break outer;
                }
              	//追加run1当前元素
                a[dest++] = tmp[cursor1++];
              	//检查是否归并退出条件
                if (--len1 == 1)
                    break outer;
                minGallop--;
              //直到一方有连续超过7个大于另一方
            } while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);
          	//minGallop不允许<0
            if (minGallop < 0)
                minGallop = 0;
            minGallop += 2;  // Penalize for leaving gallop mode
        }
      	//至此Outer循环退出
      	//可能存在run1中还剩一个数据或者还剩多个数据的情况「因为run1的最后一个元素一定大于run2的所有元素」
        this.minGallop = minGallop < 1 ? 1 : minGallop;

      	//run1中只剩一个元素
      	// 先拷贝run2中所有元素
      	//再把run1中最后一个元素追加进来
        if (len1 == 1) {
            assert len2 > 0;
            System.arraycopy(a, cursor2, a, dest, len2);
            a[dest + len2] = tmp[cursor1];
        } else if (len1 == 0) {
            throw new IllegalArgumentException(
                "Comparison method violates its general contract!");
        } else {
          	//run1中有多个元素
          	//run2中一定不会有剩余元素,直接将run1中的剩余元素追加进来
            assert len2 == 0;
            assert len1 > 1;
            System.arraycopy(tmp, cursor1, a, dest, len1);
        }
    }

    /**
     * run2：+-----------------------+
     *      |   len2  |    有序空间   |
     *    base2----------------------+
     *
     * run1：+-----------------------+
     *      |   有序空间   |   len1   |
     *      +-----------base1--------+
     * mergeLo对「len1 >= len2」情况进行排序
     * 前提是 a[base1] > a[base2] && run1的最后一个元素大于run2中所有元素
     */
    private void mergeHi(int base1, int len1, int base2, int len2) {
        assert len1 > 0 && len2 > 0 && base1 + len1 == base2;

        Object[] a = this.a; 
      	//谁的数据少，谁放tmp数据
        Object[] tmp = ensureCapacity(len2);
        int tmpBase = this.tmpBase;
        System.arraycopy(a, base2, tmp, tmpBase, len2);

        int cursor1 = base1 + len1 - 1;  
        int cursor2 = tmpBase + len2 - 1; 
        int dest = base2 + len2 - 1;

      
      	// mergeHi是从高向低倒序整理
        // 将run1中的最后一个元素先放入尾部
        a[dest--] = a[cursor1--];
      	//并检查退化情况
        if (--len1 == 0) {
            System.arraycopy(tmp, tmpBase, a, dest - (len2 - 1), len2);
            return;
        }
        if (len2 == 1) {
            dest -= len1;
            cursor1 -= len1;
            System.arraycopy(a, cursor1 + 1, a, dest + 1, len1);
            a[dest] = tmp[cursor2];
            return;
        }

        int minGallop = this.minGallop;
    outer:
        while (true) {
            int count1 = 0; // Number of times in a row that first run won
            int count2 = 0; // Number of times in a row that second run won

            //同样先来一轮抢七
            do {
                assert len1 > 0 && len2 > 1;
                if (((Comparable) tmp[cursor2]).compareTo(a[cursor1]) < 0) {
                    a[dest--] = a[cursor1--];
                    count1++;
                    count2 = 0;
                    if (--len1 == 0)
                        break outer;
                } else {
                    a[dest--] = tmp[cursor2--];
                    count2++;
                    count1 = 0;
                    if (--len2 == 1)
                        break outer;
                }
            } while ((count1 | count2) < minGallop);

            //同样再来一轮疾跑抢七
            do {
                assert len1 > 0 && len2 > 1;
                count1 = len1 - gallopRight((Comparable) tmp[cursor2], a, base1, len1, len1 - 1);
                if (count1 != 0) {
                    dest -= count1;
                    cursor1 -= count1;
                    len1 -= count1;
                    System.arraycopy(a, cursor1 + 1, a, dest + 1, count1);
                    if (len1 == 0)
                        break outer;
                }
                a[dest--] = tmp[cursor2--];
                if (--len2 == 1)
                    break outer;

                count2 = len2 - gallopLeft((Comparable) a[cursor1], tmp, tmpBase, len2, len2 - 1);
                if (count2 != 0) {
                    dest -= count2;
                    cursor2 -= count2;
                    len2 -= count2;
                    System.arraycopy(tmp, cursor2 + 1, a, dest + 1, count2);
                    if (len2 <= 1)
                        break outer; // len2 == 1 || len2 == 0
                }
                a[dest--] = a[cursor1--];
                if (--len1 == 0)
                    break outer;
                minGallop--;
            } while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);
            if (minGallop < 0)
                minGallop = 0;
            minGallop += 2;  // Penalize for leaving gallop mode
        }
      	//退出outer循环
      	//这里剩余的情况是，run2有一个或多个数据
        this.minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

      	//run2只剩一个数据的情况
      	//run2的剩余元素一定小于run1的所有元素「因为a[base1]>a[base2]」
      	//run1中的剩余元素先追加到a中，再把run2的剩余元素放入a的数据前面
        if (len2 == 1) {
            assert len1 > 0;
            dest -= len1;
            cursor1 -= len1;
            System.arraycopy(a, cursor1 + 1, a, dest + 1, len1);
            a[dest] = tmp[cursor2];  // Move first elt of run2 to front of merge
        } else if (len2 == 0) {
            throw new IllegalArgumentException(
                "Comparison method violates its general contract!");
        } else {
          	//run2还剩多个元素
          	//run1中一定没有剩余元数据
            assert len1 == 0;
            assert len2 > 0;
          	//直接将run2中的所有元素放入run1头部
            System.arraycopy(tmp, tmpBase, a, dest - (len2 - 1), len2);
        }
    }

    /**
     * 确保外部排序数组tmp的大小 超过指定的最小容量
     * 并且可以自动扩容用于均摊扩容造成的时间复杂度增加「翻倍扩容」	
     */
    private Object[]  ensureCapacity(int minCapacity) {
        if (tmpLen < minCapacity) {
            // 大于minCapacity的 最小2次幂
            int newSize = minCapacity;
            newSize |= newSize >> 1;
            newSize |= newSize >> 2;
            newSize |= newSize >> 4;
            newSize |= newSize >> 8;
            newSize |= newSize >> 16;
            newSize++;

            if (newSize < 0) // 这个情况不太可能
                newSize = minCapacity;
            else	//不能超过需要排序数组长度的一半
                newSize = Math.min(newSize, a.length >>> 1);

            @SuppressWarnings({"unchecked", "UnnecessaryLocalVariable"})
          	//每次都创建新数组
            Object[] newArray = new Object[newSize];
            tmp = newArray;
            tmpLen = newSize;
            tmpBase = 0;
        }
        return tmp;
    }

}
```