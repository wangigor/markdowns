# 索引

> 为了节省存储空间，为了提高数据增删改查的效率。就有了索引这样的设计。
>
> 索引不是数据结构。就像书的目录，是为了快速定位使用的。
>
> 下面先来看几个日常开发中会接触到的组件的索引结构。

## 跳表

> 对于一组有序数据，需要快速查找特定元素。一般会把数据存储在**数组**这样的数据结构中，利用数组的随机访问特性，可以进行二分查找。但是如果数据存储在**链表**中就不行了。
>
> 只需要对**链表进行稍加改造**，就可以实现「二分查找」的特性。
>
> 我画了个图。
>
> ![image-20210524215107764](https://gitee.com/wangigor/typora-images/raw/master/image-20210524215107764.png)
>
> 这是原始数据，我们把每两个数据，抽出一个到上级，组成以及索引。
>
> ![image-20210524215626755](https://gitee.com/wangigor/typora-images/raw/master/image-20210524215626755.png)
>
> 那么13个数据，就会抽出7个索引节点。
>
> 比如要查找15这个数据，单链表查找需要查找10个节点。有了一级索引之后，我们先从一级索引处查找到14，下一个节点17，那么要找的数据特征15，就在14-17的区间内，从一级索引14向下查找，找到15，只需要7个节点。
>
> 那么，**增加了一级索引后遍历的链表节点数少了，就说明查找效率提升了。**
>
> 再增加二级索引。
>
> ![image-20210524220813476](https://gitee.com/wangigor/typora-images/raw/master/image-20210524220813476.png)
>
> 从二级索引开始，只需要6个节点。
>
> 那么当数据量越大，索引层级越多，这样的查找速度的提升也就越明显。
>
> 这种**对链表增加多级索引的数据结构就是跳表**。

### 时间复杂度

对于上面例子中的，每两个数据抽出一个索引节点，假设数据链表长度为n。那么一级索引的链表长度就是$\frac n2$，二级索引的长度为$\frac n4$，三级索引的长度为$\frac n8$……以此类推，第k级索引的长度为$\frac{n}{2^k}$。

假设最高级索引为h级，共有2个节点 $\frac n{2^h}=2$  =>  $2^h= \frac n2$  => $h=log_2(\frac n2)=log_2n-1$。再加上数据链表这一层，总层级为$log_2n$，假设每层需要遍历m个元素，那查找到指定数据的时间复杂度就是$O(m*logn)$。

> m是多少。
>
> 由于，创建索引时没两个节点会有一个索引，而数据又落在最上层的两个节点之间，**那么每层最多遍历3个节点**.
>
> 因为如果超出三个节点，在上一层就不符合「进入下一层的条件」了。
>
> 当然，这三个节点包含了一个重复节点，就是第k层索引的y和下一层k-1层的y两个「相同」节点。

那么跳表的查询时间复杂度也就是$O(logn)$。

### 空间复杂度

> 索引的增加，必然导致了空间消耗。

假设原始数据有n个，对于「每两个数据抽出一个索引」的方式来说，增加的索引空间为

$\frac n2+\frac n4+ \frac n8+……+8+4+2$

等比数列公式$S_k=a_0*\frac{1-q^k}{1-q}$:$a_0=\frac n2;q=\frac 12;k=log_2n$;$S_k=\frac n2*\frac{1-\frac 12^{log_2n}}{\frac 12}=n*(1-\frac 2n)=n-2$。

跳表的空间复杂度是$O(n)$。

当原始数据是3个数据抽一个索引节点时，就变成了

$\frac n3+\frac n9 +\frac n{27}+……+9+3+1=\frac n3*\frac{1-\frac 23^{log_3n}}{\frac 23} \approx \frac n2$。

尽管空间复杂度还是O(n)，但是空间却少了一半。

在加上，实际开发中，**数据项的数据**往往比**索引的特征值**大很多，所以**不必太在意索引占用的空间**。

### 动态插入和删除

> 对于链表，插入和删除的时间复杂度是O(1)。有两个前提：「**已经定位到要插入位置或要删除元素**」「**拥有前驱结点或双向链表**」。

跳跃链表的插入和删除也是这样，通过O(logn)的搜索定位到对应节点，进行插入和删除，且同样考虑前驱结点问题「单链表」。

如果不考虑其他方面，到目前为止**插入和删除的时间复杂度是O(logn)**。

那么问题来了。

> **如果不更新索引，聚集性的插入，会使得跳表降为单链表；删除数据也要删除索引。**
>
> 像红黑树这样的平衡树，会通过旋转和变色维持平衡。
>
> 但是对于跳表的索引更新就比较麻烦。如果做了固定提取索引区间「超过多少个数据创建一个新索引，少于多少个，删除上级索引」这样的方式，就又很像B树。
>
> 「在redis的有序集合zset中提到过」**跳表采用的是随机函数的方式**，通过概率维持集合稳定。
>
> 也就是通过「**稳定的随机函数**」在数据插入时，给他一个随机的『层级』，放在对应的索引层中。
>
> 随机函数要稳定：从概率上来讲，能够保证跳表的索引大小和数据大小平衡性，不至于性能过度退化
>
> - 50%概率放在第一层
> - 25%概率放在第二层
> - 12.5%概率放在第三层
> - ……

### 代码实现

```java
public class SkipList {

    public static final int maxLevel = 10;
    public static final float probability = 0.5f;

    private int levelCount = 0;
    private Node head = new Node();

    /**
     * 插入
     */
    public void insert(int data) {
        Node newNode = new Node(data);
        int level = newNode.level;

        if (level > levelCount) {
            levelCount = level;
        }

        //初始化待更新集合
        Node[] updates = new Node[level];
        for (int i = 0; i < level; ++i) {
            updates[i] = head;
        }

        //找到要插入节点位置的左节点
        Node c = head;
        for (int i = level - 1; i >= 0; --i) {
            while (c.next[i] != null && c.next[i].data < data) {
                c = c.next[i];
            }
            updates[i] = c;
        }

        //更新节点
        for (int i = level - 1; i >= 0; --i) {
            //node.next左节点的next
            newNode.next[i] = updates[i].next[i];
            //原左节点的next改为newNode
            updates[i].next[i] = newNode;
        }

    }

    /**
     * 查找
     */
    public Node find(int data) {
        Node c = head;
        //按层往下找
        for (int i = levelCount - 1; i >= 0; --i) {
            //层内找到小于data的最大值
            while (c.next[i] != null && c.next[i].data < data) {
                c = c.next[i];
            }
        }

        //当前元素判断是否data
        if (c.next[0] != null && c.next[0].data == data) {
            return c.next[0];
        }
        return null;
    }

    /**
     * 顺序打印
     */
    public void printAll() {
        Node c = head;
        while (c.next[0] != null) {
            System.out.println(c.next[0].data);
            c = c.next[0];
        }
    }

    public void delete(int data) {
        Node[] updates = new Node[levelCount];
        Node c = head;
        for (int i = levelCount - 1; i >= 0; --i) {
            while (c.next[i] != null && c.next[i].data < data) {
                c = c.next[i];
            }
            updates[i] = c;
        }

        //找到了节点才删
        if (c.next[0] != null && c.next[0].data == data) {
            for (int i = levelCount - 1; i >= 0; --i) {
                if (updates[i].next[i] != null && updates[i].next[i].data == data) {
                    updates[i].next[i] = updates[i].next[i].next[i];
                }
            }
            //从最高层往下看，levelCount减少了没
            while (levelCount > 1 && head.next[levelCount] == null) {
                --levelCount;
            }
        }
    }


    public static int randomLevel() {
        int level = 1;
        while (Math.random() < probability && level < maxLevel) {
            ++level;
        }
        return level;
    }


    @Data
    public static class Node {
        private int data = -1;
      	//next是当前节点的每一层后一节点
        private Node[] next;
        private int level;

        public Node(int data) {
            this.data = data;
            this.level = randomLevel();
            this.next = new Node[this.level];
        }

        public Node() {
            //head
            this.next = new Node[maxLevel];
        }
    }
}
```

