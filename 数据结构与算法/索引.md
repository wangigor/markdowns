# 索引

> 为了节省存储空间，为了提高数据增删改查的效率。就有了索引这样的设计。
>
> 索引不是数据结构。就像书的目录，是为了快速定位使用的。
>
> 下面先来看几个日常开发中会接触到的组件的索引结构。

## 跳表

> 对于一组有序数据，需要快速查找特定元素。一般会把数据存储在**数组**这样的数据结构中，利用数组的随机访问特性，可以进行二分查找。但是如果数据存储在**链表**中就不行了。
>
> 只需要对**链表进行稍加改造**，就可以实现「二分查找」的特性。
>
> 我画了个图。
>
> ![image-20210524215107764](https://gitee.com/wangigor/typora-images/raw/master/image-20210524215107764.png)
>
> 这是原始数据，我们把每两个数据，抽出一个到上级，组成以及索引。
>
> ![image-20210524215626755](https://gitee.com/wangigor/typora-images/raw/master/image-20210524215626755.png)
>
> 那么13个数据，就会抽出7个索引节点。
>
> 比如要查找15这个数据，单链表查找需要查找10个节点。有了一级索引之后，我们先从一级索引处查找到14，下一个节点17，那么要找的数据特征15，就在14-17的区间内，从一级索引14向下查找，找到15，只需要7个节点。
>
> 那么，**增加了一级索引后遍历的链表节点数少了，就说明查找效率提升了。**
>
> 再增加二级索引。
>
> ![image-20210524220813476](https://gitee.com/wangigor/typora-images/raw/master/image-20210524220813476.png)
>
> 从二级索引开始，只需要6个节点。
>
> 那么当数据量越大，索引层级越多，这样的查找速度的提升也就越明显。
>
> 这种**对链表增加多级索引的数据结构就是跳表**。

### 时间复杂度

对于上面例子中的，每两个数据抽出一个索引节点，假设数据链表长度为n。那么一级索引的链表长度就是$\frac n2$，二级索引的长度为$\frac n4$，三级索引的长度为$\frac n8$……以此类推，第k级索引的长度为$\frac{n}{2^k}$。

假设最高级索引为h级，共有2个节点 $\frac n{2^h}=2$  =>  $2^h= \frac n2$  => $h=log_2(\frac n2)=log_2n-1$。再加上数据链表这一层，总层级为$log_2n$，假设每层需要遍历m个元素，那查找到指定数据的时间复杂度就是$O(m*logn)$。

> m是多少。
>
> 由于，创建索引时没两个节点会有一个索引，而数据又落在最上层的两个节点之间，**那么每层最多遍历3个节点**.
>
> 因为如果超出三个节点，在上一层就不符合「进入下一层的条件」了。
>
> 当然，这三个节点包含了一个重复节点，就是第k层索引的y和下一层k-1层的y两个「相同」节点。

那么跳表的查询时间复杂度也就是$O(logn)$。

### 空间复杂度

> 索引的增加，必然导致了空间消耗。

假设原始数据有n个，对于「每两个数据抽出一个索引」的方式来说，增加的索引空间为

$\frac n2+\frac n4+ \frac n8+……+8+4+2$

等比数列公式$S_k=a_0*\frac{1-q^k}{1-q}$:$a_0=\frac n2;q=\frac 12;k=log_2n$;$S_k=\frac n2*\frac{1-\frac 12^{log_2n}}{\frac 12}=n*(1-\frac 2n)=n-2$。

跳表的空间复杂度是$O(n)$。

当原始数据是3个数据抽一个索引节点时，就变成了

$\frac n3+\frac n9 +\frac n{27}+……+9+3+1=\frac n3*\frac{1-\frac 23^{log_3n}}{\frac 23} \approx \frac n2$。

尽管空间复杂度还是O(n)，但是空间却少了一半。

在加上，实际开发中，**数据项的数据**往往比**索引的特征值**大很多，所以**不必太在意索引占用的空间**。

### 动态插入和删除

> 对于链表，插入和删除的时间复杂度是O(1)。有两个前提：「**已经定位到要插入位置或要删除元素**」「**拥有前驱结点或双向链表**」。

跳跃链表的插入和删除也是这样，通过O(logn)的搜索定位到对应节点，进行插入和删除，且同样考虑前驱结点问题「单链表」。

如果不考虑其他方面，到目前为止**插入和删除的时间复杂度是O(logn)**。

那么问题来了。

> **如果不更新索引，聚集性的插入，会使得跳表降为单链表；删除数据也要删除索引。**
>
> 像红黑树这样的平衡树，会通过旋转和变色维持平衡。
>
> 但是对于跳表的索引更新就比较麻烦。如果做了固定提取索引区间「超过多少个数据创建一个新索引，少于多少个，删除上级索引」这样的方式，就又很像B树。
>
> 「在redis的有序集合zset中提到过」**跳表采用的是随机函数的方式**，通过概率维持集合稳定。
>
> 也就是通过「**稳定的随机函数**」在数据插入时，给他一个随机的『层级』，放在对应的索引层中。
>
> 随机函数要稳定：从概率上来讲，能够保证跳表的索引大小和数据大小平衡性，不至于性能过度退化
>
> - 50%概率放在第一层
> - 25%概率放在第二层
> - 12.5%概率放在第三层
> - ……

### 代码实现

```java
public class SkipList {

    public static final int maxLevel = 10;
    public static final float probability = 0.5f;

    private int levelCount = 0;
    private Node head = new Node();

    /**
     * 插入
     */
    public void insert(int data) {
        Node newNode = new Node(data);
        int level = newNode.level;

        if (level > levelCount) {
            levelCount = level;
        }

        //初始化待更新集合
        Node[] updates = new Node[level];
        for (int i = 0; i < level; ++i) {
            updates[i] = head;
        }

        //找到要插入节点位置的左节点
        Node c = head;
        for (int i = level - 1; i >= 0; --i) {
            while (c.next[i] != null && c.next[i].data < data) {
                c = c.next[i];
            }
            updates[i] = c;
        }

        //更新节点
        for (int i = level - 1; i >= 0; --i) {
            //node.next左节点的next
            newNode.next[i] = updates[i].next[i];
            //原左节点的next改为newNode
            updates[i].next[i] = newNode;
        }

    }

    /**
     * 查找
     */
    public Node find(int data) {
        Node c = head;
        //按层往下找
        for (int i = levelCount - 1; i >= 0; --i) {
            //层内找到小于data的最大值
            while (c.next[i] != null && c.next[i].data < data) {
                c = c.next[i];
            }
        }

        //当前元素判断是否data
        if (c.next[0] != null && c.next[0].data == data) {
            return c.next[0];
        }
        return null;
    }

    /**
     * 顺序打印
     */
    public void printAll() {
        Node c = head;
        while (c.next[0] != null) {
            System.out.println(c.next[0].data);
            c = c.next[0];
        }
    }

    public void delete(int data) {
        Node[] updates = new Node[levelCount];
        Node c = head;
        for (int i = levelCount - 1; i >= 0; --i) {
            while (c.next[i] != null && c.next[i].data < data) {
                c = c.next[i];
            }
            updates[i] = c;
        }

        //找到了节点才删
        if (c.next[0] != null && c.next[0].data == data) {
            for (int i = levelCount - 1; i >= 0; --i) {
                if (updates[i].next[i] != null && updates[i].next[i].data == data) {
                    updates[i].next[i] = updates[i].next[i].next[i];
                }
            }
            //从最高层往下看，levelCount减少了没
            while (levelCount > 1 && head.next[levelCount] == null) {
                --levelCount;
            }
        }
    }


    public static int randomLevel() {
        int level = 1;
        while (Math.random() < probability && level < maxLevel) {
            ++level;
        }
        return level;
    }


    @Data
    public static class Node {
        private int data = -1;
      	//next是当前节点的每一层后一节点
        private Node[] next;
        private int level;

        public Node(int data) {
            this.data = data;
            this.level = randomLevel();
            this.next = new Node[this.level];
        }

        public Node() {
            //head
            this.next = new Node[maxLevel];
        }
    }
}
```

### JDK ConcurrentSkipListMap源码解析

==todo==先放一放。

## B+树

> MySQL的索引数据结构。
>
> 跳表的插入、删除、查找的时间复杂度都是O(logn)，也支持区间查找。但是他是1989年的作品。
>
> B+树产生于1972年，是根据B树被创造出来的。
>
> 区别就在于
>
> - B+树只有叶子节点存储完整数据，其余节点只存储索引。
>
> - B+树的叶子节点要进行链接。

### 从二叉树推导

假设数据是「6、10、15、23、27、33、42」。

组成的二叉树是

<img src="https://gitee.com/wangigor/typora-images/raw/master/image-20210604100826512.png" alt="image-20210604100826512" style="zoom:50%;" />

现在每个节点都是完整的数据，没有索引的概念。

- 先把「索引节点」跟「数据节点」分开。
- 再把「数据节点」用双向链表连接起来。方便 order by asc/desc这样的操作。

> 这里要注意的是：
>
> 同一层的两个节点，「抽取」的上层节点应该是当前节点的**后继节点**，也就是右子树的最左子节点。
>
> 这样才能保证**左子树 <** 当前节点，**右子树 >=** 当前节点。

<img src="https://gitee.com/wangigor/typora-images/raw/master/image-20210604102637395.png" alt="image-20210604102637395" style="zoom:50%;" />

> 查找[10，23]区间，从小到大排列
>
> <img src="https://gitee.com/wangigor/typora-images/raw/master/image-20210604102922049.png" alt="image-20210604102922049" style="zoom:50%;" />
>
> 查找[9，34]，从大到小排列
>
> <img src="https://gitee.com/wangigor/typora-images/raw/master/image-20210604103132403.png" alt="image-20210604103132403" style="zoom:50%;" />

那么问题来了，这样创建的索引个数是很多的「即便索引占用的空间远比数据节点小得多，但是也太多了」，且索引层级很高。

假设总共有16个数据，就需要$log_216=4$层索引。假设head节点在内存中，其余节点都在磁盘里，查找到一条数据就需要4次磁盘io操作；如果要创建一个五叉树的索引，只需要两层索引「5个索引节点」，只需要2次磁盘io。数量大大减少。

> 且。要为数据创建第一层索引「也就是当前数据对应的索引值，也就是索引跟数据地址的对应关系」。
>
> 这也就是为什么覆盖索引会快的原因：只读索引上的数据，而不再去读全部数据，减少了io次数。
>
> 「啥概念呢，减少内存操作减少的时间是纳秒级别，减少磁盘io操作减少的时间是毫秒级别。」
>
> 以主键索引为例。

<img src="https://gitee.com/wangigor/typora-images/raw/master/image-20210604113233593.png" alt="image-20210604113233593" style="zoom:50%;" />

> 这是两类数据
>
> - 索引节点对象
>
>   ```java
>   public static class BPlusIndexNode {
>     	//m叉树
>       public static final int m = 5;
>     	//当前节点有多少索引值 m-1个值划分了m个区间
>       private int[] keywords = new int[m - 1];
>     	//子节点
>       private Object[] children = new Object[m];
>   }
>   ```
>
>   m值的计算
>
>   为了要保证 m-1 个 BPlusIndexNode 集合在同一个磁盘页中「数据在多个页中，会触发多个io操作」。
>
>   磁盘页大小可以通过
>
>   ```term
>   getconf PAGE_SIZE
>   ```
>
>   命令查看，默认是4096「单位：字节」。像mysql有4k、8k、16k多种选项。
>
>   ```公式
>   PAGE_SIZE = m*对象头大小 + m-1*4「keywords的int大小」+ m*8「引用对象大小」
>   ```
>
> - 叶子节点对象
>
>   ```java
>   public static class BPlusLeafNode {
>     	//对应m条数据
>       public static final int m = 3;
>     	//m个keywords
>       private int[] keywords = new int[m];
>     	//对应m个数据地址
>       private long[] address = new long[m];
>     	//前一个叶子节点引用
>       private BPlusLeafNode next;
>     	//后一个叶子节点引用
>       private BPlusLeafNode prev;
>   }
>   ```
>
>   ```公式
>   PAGE_SIZE = m*对象头大小 + m*4「keywords的int大小」+ m*8「long地址大小」+ 8「next引用大小」+8「prev引用大小」
>   ```
>
>   因为保存数据大小不同，这里的m有意设了不同的值。

谁会用java写B+树呢，等会儿我就只写一个五叉B+树。

### 动态插入、删除

> 查找，是一件简单的事情，因为m-1个数据划分了m个区间，就逐个比对，进入子节点即可。
>
> 插入和删除，是相对比较耗时的操作。因为插入数据之后，当前节点的数据就会超，需要「分裂」，分裂之后父节点又可能会超。删除也是，一个节点数量小于一定的阈值「比如m/2」，要跟兄弟节点合并，不过合并过后可能会超，再分裂。
>
> <img src="https://gitee.com/wangigor/typora-images/raw/master/image-20210604154602792.png" alt="image-20210604154602792" style="zoom:50%;" />
>
> <img src="https://gitee.com/wangigor/typora-images/raw/master/image-20210604160050824.png" alt="image-20210604160050824" style="zoom:50%;" />

### 代码实现

==todo==

