# 栈

![image-20201124233701334](https://gitee.com/wangigor/typora-images/raw/master/数据结构与算法-栈.png)

> 栈是**一种操作受限的线性表**。数组和链表操作自由，暴露了很多操作接口，导致操作不可控容易出错。
>
> 由此产生了栈、队列等操作受限的线性表。与数组和链表不同，更看重该数据结构的访问限制，而不是内存分布。
>
> 所以使用数组实现栈结构「**顺序栈**」，还是使用链表实现栈结构「**链式栈**」，都可以。

## 栈的实现

### 顺序栈

> 不论是从数组min开始存储，还是从数组max开始存储，都可以。

```java
class ArrayStack {
		
    private Object[] items;//栈元素集合
    private int capacity;//栈容量
    private int index;//当前存储下标

    /**
     * 初始化栈
     *
     * @param type
     * @param capacity
     * @param <T>
     */
    public <T> ArrayStack(Class type, int capacity) {
        this.items = (T[]) Array.newInstance(type, capacity);
        this.capacity = capacity;
        this.index = capacity - 1;//从数组最大值开始存储
    }

    /**
     * 入栈
     *
     * @param item
     * @param <T>
     * @return
     */
    public <T> boolean push(T item) {
        if (index == -1) {//栈满
            return false;
        }
        items[index--] = item;//赋值，指针前移
        return true;
    }

    /**
     * 出栈
     *
     * @param <T>
     * @return
     */
    public <T> T pop() {
        if (index == capacity - 1) {//栈空
            return null;
        }
        return (T) items[++index];//指针后移
    }

}
```

存在两个问题。**不支持动态扩容** 和 **存在并发问题**。

#### 支持动态扩容的顺序栈

> 上面实现的顺序栈，是一个固定大小的栈。当栈满了之后，新元素无法再放入栈中。
>
> 比如有限线程池，需要增加线程数，再满执行拒绝策略。
>
> 现在来实现一个支持动态扩容的顺序栈
>
> - 栈满。扩容为2倍。
>
> - 只扩容，不缩容。
>
> - 需要进行元素搬运。
>
>   注意：只是扩容和元素搬运，时间复杂度为O(n)。根据摊还分析，这个扩容的O(n)，平摊到前面每一次入栈「时间复杂度O(1)」上。**整体的入栈操作的时间复杂度仍是O(1)。**

```java
class AutoIncreaseArrayStack {

    public static final int DEFAULT_CAPACITY = 10;


    private Class type;
    private Object[] items;
    private int capacity;
    private int index;

    /**
     * 默认初始化栈
     *
     * @param type
     * @param <T>
     */
    public <T> AutoIncreaseArrayStack(Class type) {
        this(DEFAULT_CAPACITY, type);
    }

    /**
     * 初始化栈
     *
     * @param type
     * @param capacity
     * @param <T>
     */
    public <T> AutoIncreaseArrayStack(int capacity, Class type) {
        this.type = type;
        this.items = (T[]) Array.newInstance(type, capacity);
        this.capacity = capacity;
        this.index = capacity - 1;
    }

    /**
     * 入栈
     *
     * @param item
     * @param <T>
     * @return
     */
    public <T> boolean push(T item) {
        if (index == -1) {
            //扩容 二倍数组
            T[] newItems = (T[]) Array.newInstance(type, capacity=capacity<<1);
          	//搬移
            System.arraycopy(items,0,newItems,items.length,items.length);
          	//移动指针
            index=items.length-1;
            this.items=newItems;
        }
        items[index--] = item;
        return true;
    }

    /**
     * 出栈
     * <p>
     * 没变化
     *
     * @param <T>
     * @return
     */
    public <T> T pop() {
        if (index == capacity - 1) {
            return null;
        }
        T t = (T) items[++index];
        return t;
    }


}
```

#### 无锁并发的顺序栈

> 使用CAS自旋锁。简单demo演示下。
>
> 因为还涉及扩容、下标越界回退等其他问题。暂不考虑，只是简单demo。
>
> 当然使用直接使用UnSafe也是可以的。「实现是可以实现的，但是我不知道支持高并发的顺序栈有什么用。」

```java
class ConCurrentArrayStack {
    private Object[] items;
    private int capacity;
    private int index;
    private AtomicReference<Integer> reference;

    /**
     * 初始化栈
     *
     * @param type
     * @param capacity
     * @param <T>
     */
    public <T> ConCurrentArrayStack(Class type, int capacity) {
        this.items = (T[]) Array.newInstance(type, capacity);
        this.capacity = capacity;
        this.index = capacity - 1;
        this.reference = new AtomicReference<>(index);
    }

    /**
     * 入栈
     *
     * @param item
     * @param <T>
     * @return
     */
    public <T> boolean push(T item) {

        Integer current;

        for (; ; ) {
            if (reference.compareAndSet(current = reference.get(), current - 1)) {
                if (current == -1) {
                    return false;
                }
                items[current] = item;
                break;
            }
        }
        return true;
    }

    /**
     * 出栈
     *
     * @param <T>
     * @return
     */
    public <T> T pop() {
        Integer current;
        for (; ; ) {
            if ((current = reference.get()) >= -1 && reference.compareAndSet(current, current + 1)) {
                if (current < 0||current>capacity-1) {
                    return null;
                }
                return (T) items[current];
            }
        }

    }
}
```

### 链式栈

> 链式栈，就比顺序栈简单很多，不用管指针，就是从head入栈，从head出栈。
>
> 简单实现一下。

```java
class LinkedStack {

    @Getter
    @Setter
    private Node head;

    public void push(int i) {
        //head==null都不需要判断
        Node node = new Node(i);
        node.setNext(head);
        head = node;
    }

    public int poll() {
        if (head == null)
            return 0;
        int result_value = head.getValue();
        head = head.getNext();
        return result_value;
    }


    @Data
    @ToString(of = "value")
    @RequiredArgsConstructor
    class Node {
        @NonNull
        private int value;
        private Node next;
    }
}
```



## 方法调用的栈的应用

![image-20201126110833499](https://gitee.com/wangigor/typora-images/raw/master/数据结构与算法-栈-虚拟机栈.png)

### 局部变量表

> 是变量的存储空间，存放方法入参、局部变量、方法的实例对象this「第0位索引的 Slot 默认是用于传递方法所属对象实例的引用」。
>
> 变量槽「Variable Slot」是局部变量表的最小单位。大小32位。一个slot可以存放boolean、byte、char、short、int、float、reference、returnAddress 8种类型「对于64位的 long 和 double 变量而言，虚拟机会为其分配两个连续的 Slot 空间。」。
>
> 其中 reference 表示对一个对象实例的引用，通过它可以得到对象在Java 堆中存放的起始地址的索引和该数据所属数据类型在方法区的类型信息。returnAddress 则指向了一条字节码指令的地址。

**Slot是可重用的。**变量离开作用范围时，slot可被其他新分配的变量使用。这会影响GC。举个例子

```java
    public void testStackSlotGC0() {
        {
            byte[] placeHolder = new byte[200 * 1024 * 1024];
        }
      	//placeHolder离开了自己的作用范围，但是不会回收。
        System.gc();
      	//GC详情「-verbose:gc」
      	//[GC (System.gc())  241501K->206303K(1005056K), 0.0884251 secs]
				//[Full GC (System.gc())  206303K->205962K(1005056K), 0.0087572 secs]
    }

    @Test
    public void testStackSlotGC1() {
        {
            byte[] placeHolder = new byte[200 * 1024 * 1024];
        }
      	//placeHolder离开了自己的作用范围，新变量a占用了placeHolder的slot，会被回收。
        int a = 0;
        System.gc();
      	//GC详情「-verbose:gc」
      	//[GC (System.gc())  241501K->1391K(1005056K), 0.0013216 secs]
				//[Full GC (System.gc())  1391K->1162K(1005056K), 0.0063374 secs]
    }
```

所以，「不使用的对象应手动赋值为 null」应该被推荐作为编码规范，但不能过量。

### 操作数栈

> 操作数栈就是我们说的「方法调用栈的主要操作数据部分」
>
> ```java
>     public void addTest() {
>         byte a = 1;
>         int b = 2;
>         int c = a + b;
>     }
> ```
>
> 字节码是
>
> ```c
>   public void addTest();
>     Code:
>        0: iconst_1
>        1: istore_1
>        2: iconst_2
>        3: istore_2
>        4: iload_1
>        5: iload_2
>        6: iadd
>        7: istore_3
>        8: return
> ```
>
> 当int取值**-1~5**采用iconst指令，取值**-128~127**采用bipush指令，取值**-32768~32767**采用sipush指令，取值**-2147483648~2147483647**采用 ldc 指令。
>
> 下面一行一行看「局部变量表」「操作数栈」发生了什么变化

- iconst_1：「1」压入操作数栈。

```图片
操作数栈                       局部变量表
------------             -----------------
|          |             |0|     this    |
------------             -----------------
|          |             |1|             |
------------             -----------------
|          |             |2|             |
------------             -----------------
|     1    |             |3|             |
------------             -----------------
```

- istore_1：操作数栈弹栈，放入局部变量表『1位置』

```图片
操作数栈                       局部变量表
------------             -----------------
|          |             |0|     this    |
------------             -----------------
|          |             |1|      1      |
------------             -----------------
|          |             |2|             |
------------             -----------------
|          |             |3|             |
------------             -----------------
```

- iconst_2：「2」压入操作数栈

```图片
操作数栈                       局部变量表
------------             -----------------
|          |             |0|     this    |
------------             -----------------
|          |             |1|      1      |
------------             -----------------
|          |             |2|             |
------------             -----------------
|    2     |             |3|             |
------------             -----------------
```

- istore_2：操作数栈弹栈，放入局部变量表『2位置』

```图片
操作数栈                       局部变量表
------------             -----------------
|          |             |0|     this    |
------------             -----------------
|          |             |1|      1      |
------------             -----------------
|          |             |2|      2      |
------------             -----------------
|          |             |3|             |
------------             -----------------
```

- iload_1：获取局部变量表「1位置」，压入操作数栈

```图片
操作数栈                       局部变量表
------------             -----------------
|          |             |0|     this    |
------------             -----------------
|          |             |1|      1      |
------------             -----------------
|          |             |2|      2      |
------------             -----------------
|    1     |             |3|             |
------------             -----------------
```

- iload_2：获取局部变量表「2位置」，压入操作数栈

```图片
操作数栈                       局部变量表
------------             -----------------
|          |             |0|     this    |
------------             -----------------
|          |             |1|      1      |
------------             -----------------
|    2     |             |2|      2      |
------------             -----------------
|    1     |             |3|             |
------------             -----------------
```

- iadd：从操作数栈弹出两个栈顶元素，进行add运算，计算结果压入操作数栈。

```图片
操作数栈                       局部变量表
------------             -----------------
|          |             |0|     this    |
------------             -----------------
|          |             |1|      1      |
------------             -----------------
|          |             |2|      2      |
------------             -----------------
|    3     |             |3|             |
------------             -----------------
```

- istore_3：操作数栈弹栈，放入局部变量表『3位置』

```图片
操作数栈                       局部变量表
------------             -----------------
|          |             |0|     this    |
------------             -----------------
|          |             |1|      1      |
------------             -----------------
|          |             |2|      2      |
------------             -----------------
|          |             |3|      3      |
------------             -----------------
```

方法返回就是把当前方法的栈帧弹出，把返回结果，压入上一个栈帧的操作数栈中。

## 计算器表达式求值

## 括号匹配检测

## 浏览器前进后退功能

