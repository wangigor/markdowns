# 贪心、分治、回溯、动态规划算法

> 这是四种算法思想，不是具体的算法，而是用来指导我们设计算法和编码的思想。

## 贪心算法

> 贪心算法有一些经典应用，比如霍夫曼编码（Huffman Coding）、Prim 和 Kruskal 最小生成树算法、还有 Dijkstra 单源最短路径算法等等。后面会逐个展开了解。

如何理解贪心算法，先看一个例子。

> 假设现有一个可以容纳100KG物品的背包，可以装各种物品。我们有以下 5 种豆子，每种豆子的总量和总价值都各不相同。为了让背包中所装物品的总价值最大，我们如何选择在背包中装哪些豆子？每种豆子又该装多少呢？
>
> | 物品 | 重量（KG） | 总价值（元） |
> | ---- | ---------- | ------------ |
> | 黄豆 | 100        | 100          |
> | 绿豆 | 30         | 90           |
> | 红豆 | 60         | 120          |
> | 黑豆 | 20         | 80           |
> | 青豆 | 50         | 75           |
>
> 思路：
>
> - 按照单价由高到低排列 「黑豆(4) > 绿豆(3) > 红豆(2) > 青豆(1.5) > 黄豆(1)」。
> - 依次占满：黑豆20KG -> 绿豆30KG -> 红豆50KG。

这是一个贪心算法的经典应用。他也反映了贪心算法的本质解题步骤：

- 当我们看到这些问题时，要首先想到贪心算法

  针对一组数据，设置了限制值和期望值。我们希望**从中选出一些数据，在满足限制值的情况下，期望值最大。**

  上面例子中限制值是100KG，期望值是 背包中物品的总价值。希望在满足背包中物品总重量不超过100KG的情况下，物品总价值最大。

- 模拟贪心算法

  **每次选择情况下，在对限制值同等贡献量的情况下，对期望值贡献最大的数据。**

  上面的例子就是，每次在剩余的豆子中，选择**单价最高**的豆子。

- 如果使用了贪心算法，是否是最优解。

  一般情况下，需要举几个例子验证一下。严格地证明贪心算法的正确性，是非常复杂的，需要涉及比较多的数学推理。而且，从实践的角度来说，大部分能用贪心算法解决的问题，贪心算法的正确性都是显而易见的，也不需要严格的数学推导证明。

  **如果是最优解，我们才使用贪心算法。**

但是贪心算法并不一定是最优解。我举个栗子。

> <img src="https://gitee.com/wangigor/typora-images/raw/master/image-20210302095309467.png" alt="image-20210302095309467" style="zoom:50%;" />
>
> 上图是一个有权图。找到一条从出发点S开始到T结束的路径，要求边的权重和最小。
>
> 按照贪心算法 选择S -> A -> E -> T「红线所示」1+4+4=9。
>
> 但是我们可以直观的看到权重和最小的路径是 S -> B -> D -> T「绿线所示」2+2+2=6。
>
> **贪心算法对于这个问题不是最优解。**原因是 **前面的选择，会影响后面的选择**。如果我们第一步从顶点 S 走到顶点 A，那接下来面对的顶点和边，跟第一步从顶点 S 走到顶点 B，是完全不同的。所以，即便我们第一步选择最优的走法（边最短），但有可能因为这一步选择，导致后面每一步的选择都很糟糕，最终也就无缘全局最优解了。

下面是几个贪心算法的例子。

### 分糖果

> 我们有 m 个糖果和 n 个孩子。我们现在要把糖果分给这些孩子吃，但是糖果少，孩子多（m<n），所以糖果只能分配给一部分孩子。
>
> 每个糖果的大小不等，这 m 个糖果的大小分别是 s1，s2，s3，……，sm。
>
> 除此之外，每个孩子对糖果大小的需求也是不一样的，只有糖果的大小大于等于孩子的对糖果大小的需求的时候，孩子才得到满足。假设这 n 个孩子对糖果大小的需求分别是 g1，g2，g3，……，gn。
>
> 我的问题是，**如何分配糖果，能尽可能满足最多数量的孩子？**
>
> 我们可以把这个问题抽象成，从 n 个孩子中，抽取一部分孩子分配糖果，让满足的孩子的个数（期望值）是最大的。
>
> 这个问题的限制值就是糖果个数 m。
>
> 我们现在来看看如何用贪心算法来解决。
>
> 对于一个孩子来说，如果小的糖果可以满足，我们就没必要用更大的糖果，这样更大的就可以留给其他对糖果大小需求更大的孩子。另一方面，对糖果大小需求小的孩子更容易被满足，所以，我们可以从需求小的孩子开始分配糖果。
>
> 因为满足一个需求大的孩子跟满足一个需求小的孩子，对我们期望值的贡献是一样的。我们每次从剩下的孩子中，找出对糖果大小需求最小的，然后发给他剩下的糖果中能满足他的最小的糖果，这样得到的分配方案，也就是满足的孩子个数最多的方案。

### 找零钱

> 这个问题在我们的日常生活中更加普遍。假设我们有 1 元、2 元、5 元、10 元、20 元、50 元、100 元这些面额的纸币，它们的张数分别是 c1、c2、c5、c10、c20、c50、c100。
>
> **我们现在要用这些钱来支付 K 元，最少要用多少张纸币呢？**
>
> 在生活中，我们肯定是先用面值最大的来支付，如果不够，就继续用更小一点面值的，以此类推，最后剩下的用 1 元来补齐。
>
> 在贡献相同期望值（纸币数目）的情况下，我们希望多贡献点金额，这样就可以让纸币数更少，这就是一种贪心算法的解决思路。直觉告诉我们，这种处理方法就是最好的。
>
> 注意。这些纸币的面额基本是翻倍的，类似于二分法「这种**面额设置方法还是挺讲究的**」。但是不是类比情况也同样试用贪心算法。我举个栗子。
>
> 有一个国家。纸币只有三种面额100，99，1「当然。你知道这是瞎编的。」。
>
> 我们需要凑出396，按照贪心算法需要三张100和96张1。按照动态规划可以得出4张99的最优解。

### 区间覆盖

> 假设我们有 n 个区间，区间的起始端点和结束端点分别是[l1, r1]，[l2, r2]，[l3, r3]，……，[ln, rn]。
>
> 我们从这 n 个区间中选出一部分区间，这部分区间满足两两不相交（端点相交的情况不算相交），最多能选出多少个区间呢？
>
> <img src="https://gitee.com/wangigor/typora-images/raw/master/f0a1b7978711651d9f084d19a70805cd.jpg" alt="img" style="zoom:50%;" />
>
> 这个问题的解决思路是这样的：我们假设这 n 个区间中最左端点是 lmin，最右端点是 rmax。
>
> 这个问题就相当于，我们选择几个不相交的区间，从左到右将[lmin, rmax]覆盖上。我们按照起始端点从小到大的顺序对这 n 个区间排序。
>
> 我们每次选择的时候，左端点跟前面的已经覆盖的区间不重合的，右端点又尽量小的，这样可以让剩下的未覆盖区间尽可能的大，就可以放置更多的区间。这实际上就是一种贪心的选择方法。
>
> <img src="https://gitee.com/wangigor/typora-images/raw/master/ef2d0bd8284c222b6e69294566a45b0e2b5-20210302105324235.jpg" alt="img" style="zoom:50%;" />
>
> 

### 哈夫曼编码 Huffman Coding

> 假设我们有1000个字符的文件，都是英文字母，一个字符占1个字节byte，也就是8bit。存储这1000个文件，需要8000bit，也就是7.8Kb。假设这1000个字符，只有a、b、c、d、e、f这6个字母。
>
> 我们知道三位二进制数，可以表示8个可能性。那么，这6个字母也就能表示成
>
> ```
> a（000）b（001）c（010）d（011）e（100）f（101）
> ```
>
> 每个字母只需要占3bit。那么整个文件经过「压缩」之后。只需要3000bit「2.9Kb」「如果不计算字典占用的空间的情况下」。
>
> 哈夫曼编码的本质第一条，也就是**对原数据进行拆分统计**。这里还没有用到贪心算法。
>
> 那么再来。还有没有更加有效的压缩效果呢。
>
> 让拆分后的字符频率也参与到压缩之中。**根据贪心算法，让频率更高的字符编码更短，频率更低的字符编码可以稍长**。
>
> 还是用上面的例子。a、b、c、d、e、f出现的频率分别是450、350、90、60、30、20。
>
> 编码有一个前提就是 高频率的**短编码不能**是低频率的**长编码**的**前缀子串**。不然区分不出来。最简单的方式可以如下编码
>
> | 字符 | 频率 | 编码   | 总bit数 |
> | ---- | ---- | ------ | ------- |
> | a    | 450  | 1      | 450     |
> | b    | 350  | 01     | 700     |
> | c    | 90   | 001    | 270     |
> | d    | 60   | 0001   | 240     |
> | e    | 30   | 00001  | 150     |
> | f    | 20   | 000001 | 120     |
>
> 总共需要1930bit。比刚才「压缩率」又更高了。
>
> 但是。上面的这一种新的编码方式，前面的0太多了。假设只有英文字母，如果文章中有超过8种以上英文字母，从第8种英文字母开始就需要用超过8bit表示，这还是只有英文字母的情况。那么假设文本中是我们常用的1500个汉字呢？
>
> 哈夫曼编码结合二叉树，采用了自下而上的二叉树构建方式。
>
> 以上面的例子为例：
>
> - 把所有的字符按照频率从低到高排列「直接放入优先级队列更方便。」
> - 取出两个优先级「频率」最低的，频率低的为左子节点，频率高的为右子节点。以『频率和』组成新节点放入优先级队列中。
> - 重复第二步。直到队列空。
>
> 还是用上面的例子
>
> - 先取出频率为20的f「f:20」和频率30的e「e:30」。组成的频率和为50的节点放回队列中。
>
> <img src="https://gitee.com/wangigor/typora-images/raw/master/image-20210308221313439.png" alt="image-20210308221313439" style="zoom: 50%;" />
>
> - 取出优先级最高的两个 「50」和「d:60」。组成新节点「110」放回队列中。
>
>   <img src="https://gitee.com/wangigor/typora-images/raw/master/image-20210308221813961.png" alt="image-20210308221813961" style="zoom:50%;" />
>
>   
>   
>   
>   
>   
>   
> - 取出优先级最高的「c:90」和「110」。组成新节点「200」放回队列中。
>   
>   <img src="https://gitee.com/wangigor/typora-images/raw/master/image-20210308222126368.png" alt="image-20210308222126368" style="zoom:50%;" />
>   
>   
>   
> - 取出优先级最高的「200」和「b:350」。自称新节点「550」放回队列中。
>   
>   <img src="https://gitee.com/wangigor/typora-images/raw/master/image-20210308222422975.png" alt="image-20210308222422975" style="zoom:50%;" />
>   
>   
>   
> - 取出最后的优先级最高的两个节点「550」和「a:450」。生成根节点「1000」。
>   
>   <img src="https://gitee.com/wangigor/typora-images/raw/master/image-20210308222708231.png" alt="image-20210308222708231" style="zoom:50%;" />
>   
>   
>   
>
> 这样哈弗曼树就完成了。我们给「连接」标上0/1，左0，右1。从上到下，依次编码为:
>
> ```编码
> a 0
> b 11
> c 100
> d 1011
> e 10101
> f 10100
> ```
>
> 总共只需要1910bit就可以了。
>
> **而且不会出现短编码是长编码前缀子串的情况。因为字符节点都在叶子节点。**
>
> 由于上面数据的问题，缺失了一种情况，就是『频率和节点跳过了两个字符节点的情况』
>
> 假设频率和节点是『110』，队列中最小的两个字符节点是『e:70』和『f:60』就会出现这样的情况：
>
> <img src="https://gitee.com/wangigor/typora-images/raw/master/image-20210308224009082.png" alt="image-20210308224009082" style="zoom:50%;" />
>
> 跟上面步骤的逻辑是一样的。

#### java代码实现

```java
/**
 * 生成哈夫曼字典 字符-哈夫曼二进制编码
 *
 * @param mainString
 * @return
 */
public Map<Character, String> getDictionary(String mainString) {
    //统计频率
    HashMap<Character, Integer> charFrequencyMap = new HashMap<>();
    for (int i = 0; i < mainString.length(); ++i) {
        char charAt = mainString.charAt(i);
        Integer frequency = charFrequencyMap.get(charAt);
        if (frequency == null) {
            charFrequencyMap.put(charAt, 1);
        } else {
            ++frequency;
        }
    }
    //添加进优先级队列
    PriorityQueue<Node> queue = new PriorityQueue<>(Comparator.comparingInt(o -> o.frequency));
    charFrequencyMap.forEach((character, integer) -> {
        queue.add(new Node(character, integer));
    });

    //组成huffman树
    while (queue.size() > 1) {
        Node left = queue.poll();
        Node right = queue.poll();
        queue.add(new Node(left, right));
    }
    //根节点
    Node root = queue.poll();
    HashMap<Character, String> dictionary = new HashMap<>();
    //递归编码
    encode(root, "", dictionary);
    return dictionary;
}

/**
 * 对有效节点编码
 *
 * @param node
 * @param preChar
 * @param dictionary
 */
private void encode(Node node, String preChar, Map<Character, String> dictionary) {
    if (node == null) {
        return;
    }
    if (node.isLeaf) {
        dictionary.put(node.aChar, preChar);
        return;
    }
    encode(node.left, preChar + "0", dictionary);
    encode(node.right, preChar + "1", dictionary);
}


/**
 * 节点
 */
@Data
static class Node {
    /**
     * 频率
     */
    private int frequency;
    /**
     * 字符
     */
    private char aChar;
    /**
     * 左、右子节点
     */
    private Node left, right;

    /**
     * 是否叶子节点 代替对aChar的空判断
     */
    private boolean isLeaf;

    public Node(Node left, Node right) {
        this.left = left;
        this.right = right;
        this.frequency = left.frequency + right.frequency;
        this.isLeaf = false;
    }

    public Node(char aChar, int frequency) {
        this.aChar = aChar;
        this.frequency = frequency;
        this.isLeaf = true;
    }
}
```

> 只实现到了字符串生成哈夫曼编码表。
>
> 生成的"0101010"这样的字符串，而不是bit，主要是因为java的原因。后续需要字符串转二进制写，可能使用bitmap进行「翻译」后的写操作。我就不实现了。

## 分治算法

>字面意思就是**分而治之**。
>
>将原问题**拆分**为多个**规模较小**，与原问题**结构相似**的**子问题**。递归解决这些子问题，在合并结果，得到原问题的解。
>
>与递归不同的是：**分治算法是一种处理问题的思想。递归是一种编程技巧。**分治算法一般都比较适合使用递归算法来实现。在分治算法的递归实现中，每一层的操作都得是一样的步骤：
>
>- 分解：将原问题分解成一系列子问题；
>- 解决：递归的求解各个子问题；如果子问题足够小，直接求解。
>- 合并：将子问题的结果合并成现问题结果。
>
>分治算法能解决的问题，有一定的前提条件：
>
>- 原问题**可以拆分**为具有**相同模式**的子问题。
>- **子问题可以独立求解**，子问题之间没有相关性。「这一点跟动态规划有明显区别。」
>- **具有分解终止条件**。足够小的问题可以直接求解。
>- **子问题可以合并成原问题**，且合并操作的时间复杂度不能太高。

下面举几个分治算法的例子：

### 归并排序

> 在排序那一节讲了归并排序。这里就不展开了。
>
> 将一个大数组「拆分」为两个小数组。递归对小数组进行排序「直到小数组中只有一个元素」。再对小数组进行和合并。

### 计算数据的有序度「逆序度」

> 在前面的排序中，有介绍过通过有序度来衡量排序的时间复杂度的方法。
>
> 那么**怎么求解一组数据的有序度「逆序度」呢？**
>
> 逆序度最笨的方法是，拿每一个元素，跟他后面的数据对比，看有多少个比它小的，记为数组k。把所有元素都遍历过之后，对k求和，得到逆序度。不过这样操作的时间复杂度是O($n^2$)。借助分治算法应该怎么求解呢？
>
> - 求解数组「A」的逆序对个数。
> - 将「A」分成前后两部分「A1」和「A2」。
> - 分别计算「A1」和「A2」的逆序度 「K1」「K2」
> - 再计算「A1」和「A2」之间的逆序对个数「K3」。
> - 数组「A」的逆序度就等于「K1+K2+K3」。
>
> 最难得一个问题，就是**如何快速计算出K3？**
>
> 这就要借助归并排序了。在归并排序的『合并过程』中，我们就可以计算出K3的值。

<img src="https://gitee.com/wangigor/typora-images/raw/master/image-20210319102632779.jpeg" alt="image-20210319102632779" style="zoom:50%;" />

```java
public <T extends Comparable> int reverseDegreeCount(T[] array, int start, int end) {
    if (start >= end) {
        return 0;
    }
    int middle = (start + end) / 2;
    int leftCount = reverseDegreeCount(array, start, middle);//左侧逆序度
    int rightCount = reverseDegreeCount(array, middle + 1, end);//右侧逆序度
    int k = merge(array, start, middle, end);//交叉逆序度k
    return leftCount + rightCount + k;
}

public <T extends Comparable> int merge(T[] array, int start, int middle, int end) {
    int t = 0;
    int k = 0;
    int i = start;//左侧指针
    int j = middle + 1;//右侧指针
    T[] temp = (T[]) new Comparable[end - start + 1];
    while (i <= middle && j <= end) {
        if (array[i].compareTo(array[j]) <= 0) {
            temp[t++] = array[i++];
        } else {
            temp[t++] = array[j++];
            k += middle - i + 1;//统计i到middle之间，比array[j]大的元素个数
        }
    }
  	//左侧剩余
    while (i <= middle) {
        temp[t++] = array[i++];
    }
  	//右侧剩余
    while (j <= end) {
        temp[t++] = array[j++];
    }
  	//temp拷贝回array
    for (int s = 0; s <= end - start; ++s) {
        array[start + s] = temp[s];
    }
    return k;
}
```

### 平面中距离最近的点

> 平面中有n个点，需要找到距离最近的一对点。
>
> 总是有暴力匹配法这样的东西时间复杂度$O(n^2)$.
>
> 把前面的分治算法扩展到二维平面，需要下面的步骤：
>
> - 先对n个点按照「横坐标」排序
>
>   这里能选择的排序方式有很多，要求是排序的时间复杂度低、空间复杂度低、没有必要是稳定排序
>
>   可以选择**快速排序**「时间复杂度$O(nlogn)$、原地排序、非稳定排序」
>
>   <img src="https://gitee.com/wangigor/typora-images/raw/master/image-20210407134538886.png" alt="image-20210407134538886" style="zoom: 33%;" />
>
> - 开始递归分治
>
>   将整个「区域」划分成左右两块「**LeftArea、RightArea**」。
>
>   分别计算两个区域的内的最近的点对距离，**取最小值「d = min ( minLeft , minRight ) 」。**
>
>   **「合并」：考虑 一个点在LeftArea「绿色」，另一个点在RightArea「红色」的情况。**
>
>   <img src="https://gitee.com/wangigor/typora-images/raw/master/image-20210407221818671222.jpeg" alt="image-20210407221818671" style="zoom:50%;" />
>
>   - 把中线「mid」两边，跟mid距离大于d的点『刨除』。
>
>   - 遍历LeftArea中符合规则的点。「以p点为例」逐个与RightArea中符合要求的点计算「疑似最小距离」
>
>     这里的符合要求就是「横纵坐标的差，都小于d」。
>
>     不用担心，**这样符合要求的点最多只会有6个点**：
>
>     ​	根据鸽巢(抽屉)原理「把多于n个物体放到n个抽屉里，至少有一个抽屉里的物体数量大于等于2」
>
>     ​	那么。把右侧符合条件的不看，可以看成一个d*2d的长方形。把长方形6等分。
>
>     ​	<img src="https://gitee.com/wangigor/typora-images/raw/master/image-20210407224730172229.png" alt="image-20210407224730179" style="zoom:50%;" />
>
>     ​	长方形的对角线长度为 $\frac56d$≈d。那么根据前面的条件「点之前的距离最小为d」，如果存在第7个点，那么这个点到其中一个点的距离一定小于d，是前面条件不满足。
>
>     所以。这里可以认为是一个常量级的时间复杂度。
>
>   - 得到的最小距离跟d比较即可。
>   
> - 递归终止条件
>
>   左右集合中有小于等于三个元素的时候，就直接计算。
>
> 上代码。

```java
public class NearestNeighborPoint {
    @Test
    public void main() {
        Point[] points = {
                new Point(1, 2),
                new Point(1, 1),
                new Point(2,2 ),
        };
        NearestNeighbor nearestNeighbor = searchNearestNeighbor(points, 0, points.length-1);
        System.out.println(nearestNeighbor.toString());
    }

    private NearestNeighbor searchNearestNeighbor(Point[] points, int start, int end) {
        //按照x轴排序
        Arrays.parallelSort(points, Comparator.comparingInt(Point::getX));

        NearestNeighbor nearestNeighbor = null;
        //小于等于三个进行计算
        if (end - start <= 3) {
            for (int i = start; i < end; ++i) {
                for (int j = i + 1; j <= end; ++j) {
                    NearestNeighbor temp = new NearestNeighbor(points[i], points[j]);
                    if (null == nearestNeighbor) {
                        nearestNeighbor = temp;
                    } else {
                        if (nearestNeighbor.compareTo(temp) > 0) {
                            nearestNeighbor = temp;
                        }
                    }
                }
            }
            return nearestNeighbor;
        }

        int mid = (start + end) >> 2;
        NearestNeighbor d1 = searchNearestNeighbor(points, start, mid);
        NearestNeighbor d2 = searchNearestNeighbor(points, mid + 1, end);

        //左右最小距离
        nearestNeighbor = d1.compareTo(d2) > 0 ? d2 : d1;


        //合并
        for (int i = start; i <= mid; ++i) {
            if (points[i].getX() >= points[mid].getX() - nearestNeighbor.getDistance()) {

                for (int j = mid + 1; j <= end; ++j) {
                    //这里最多有6个点满足条件
                    if ((points[i].getY() - nearestNeighbor.getDistance()) <= points[j].getY()
                            && points[j].getY() <= (points[i].getY() + nearestNeighbor.getDistance())) {

                        NearestNeighbor temp = new NearestNeighbor(points[i], points[j]);
                        if (nearestNeighbor.compareTo(temp) > 0) {
                            nearestNeighbor = temp;
                        }
                    }
                }
            }
        }
        return nearestNeighbor;
    }
}

//最近点对
@Data
class NearestNeighbor implements Comparable<NearestNeighbor> {
    private Point p1;
    private Point p2;
    private double distance;

    public NearestNeighbor(Point p1, Point p2) {
        this.p1 = p1;
        this.p2 = p2;
        this.distance = getDistance(p1, p2);
    }

    /**
     * 计算两点之间距离
     */
    public static double getDistance(Point p1, Point p2) {
        return Math.sqrt(Math.pow(p1.getX() - p2.getX(), 2) + Math.pow(p1.getY() - p2.getY(), 2));
    }

    @Override
    public int compareTo(NearestNeighbor o) {
        return Double.compare(this.distance, o.getDistance());
    }
}

//点
@Data
@AllArgsConstructor
class Point {
    private int x;
    private int y;

}
```

## 回溯算法

> 贪心算法无法达到最优解。可真让人头疼。
>
> **回溯算法本质上是枚举算法，并通过剪枝，把已经失败的后续枝节停止，遇到合适的第一个结果返回。**
>
> 也就是在每一个岔路口，都先选择一条路，继续走下去。遇到走不通的时候，回到上一个路口。
>
> 经典的问题有 8皇后问题、0-1背包问题暴力暴力破解法、正则表达式通配符匹配、图的着色、旅行商问题、数独、全排列等等。

### 8皇后问题

> 在一个8*8得棋盘上，放置8枚棋子「皇后」，希望每个棋子所在的行、列、斜对角线都不能有另一枚棋子。
>
> <img src="https://gitee.com/wangigor/typora-images/raw/master/image-20210413091535572.png" alt="image-20210413091535572" style="zoom:50%;" />
>
> 每一行都是一个「路口」。每一个路口都有8种选择。
>
> 不停地放置，不满足条件就回溯。
>
> 上代码。

```java
/**
 * 8皇后问题
 */
public class EightQueens {

    int[] result = new int[8];

    int num = 0;

    @Test
    public void test() {

        selectRowOptions(0);
    }

    private void selectRowOptions(int row) {
        if (row == 8) {
            //print result.
            print(result);
            return;
        }
        for (int i = 0; i < 8; ++i) {
            //符合条件和查看下一个
            if (check(row, i)) {
                result[row] = i;
                selectRowOptions(row + 1);
            }
        }
    }

    private boolean check(int row, int option) {

        //从当前row往前
        for (int i = row - 1; i >= 0; --i) {
            //同一列
            if (result[i] == option) {
                return false;
            }
            //斜对角线
            //只需要比较这两个差值是否相等即可。
            if (Math.abs(option - result[i]) == Math.abs(row - i)) {
                return false;
            }
        }
        return true;
    }

    private void print(int[] result) {
        System.out.println(++num);
        System.out.println(Arrays.toString(result));
        for (int i = 0; i < 8; ++i) {
            for (int j = 0; j < 8; ++j) {
                if (result[i] == j) {
                    System.out.print(" Q ");
                } else {
                    System.out.print(" * ");
                }
            }
            System.out.println();
        }
    }
}

```

```log
1
[0, 4, 7, 5, 2, 6, 1, 3]
 Q  *  *  *  *  *  *  * 
 *  *  *  *  Q  *  *  * 
 *  *  *  *  *  *  *  Q 
 *  *  *  *  *  Q  *  * 
 *  *  Q  *  *  *  *  * 
 *  *  *  *  *  *  Q  * 
 *  Q  *  *  *  *  *  * 
 *  *  *  Q  *  *  *  * 
2
[0, 5, 7, 2, 6, 3, 1, 4]
 Q  *  *  *  *  *  *  * 
 *  *  *  *  *  Q  *  * 
 *  *  *  *  *  *  *  Q 
 *  *  Q  *  *  *  *  * 
 *  *  *  *  *  *  Q  * 
 *  *  *  Q  *  *  *  * 
 *  Q  *  *  *  *  *  * 
 *  *  *  *  Q  *  *  * 
3
[0, 6, 3, 5, 7, 1, 4, 2]
 Q  *  *  *  *  *  *  * 
 *  *  *  *  *  *  Q  * 
 *  *  *  Q  *  *  *  * 
 *  *  *  *  *  Q  *  * 
 *  *  *  *  *  *  *  Q 
 *  Q  *  *  *  *  *  * 
 *  *  *  *  Q  *  *  * 
 *  *  Q  *  *  *  *  * 
4
[0, 6, 4, 7, 1, 3, 5, 2]
 Q  *  *  *  *  *  *  * 
 *  *  *  *  *  *  Q  * 
 *  *  *  *  Q  *  *  * 
 *  *  *  *  *  *  *  Q 
 *  Q  *  *  *  *  *  * 
 *  *  *  Q  *  *  *  * 
 *  *  *  *  *  Q  *  * 
 *  *  Q  *  *  *  *  * 
5
[1, 3, 5, 7, 2, 0, 6, 4]
 *  Q  *  *  *  *  *  * 
 *  *  *  Q  *  *  *  * 
 *  *  *  *  *  Q  *  * 
 *  *  *  *  *  *  *  Q 
 *  *  Q  *  *  *  *  * 
 Q  *  *  *  *  *  *  * 
 *  *  *  *  *  *  Q  * 
 *  *  *  *  Q  *  *  * 
6
[1, 4, 6, 0, 2, 7, 5, 3]
 *  Q  *  *  *  *  *  * 
 *  *  *  *  Q  *  *  * 
 *  *  *  *  *  *  Q  * 
 Q  *  *  *  *  *  *  * 
 *  *  Q  *  *  *  *  * 
 *  *  *  *  *  *  *  Q 
 *  *  *  *  *  Q  *  * 
 *  *  *  Q  *  *  *  * 
7
[1, 4, 6, 3, 0, 7, 5, 2]
 *  Q  *  *  *  *  *  * 
 *  *  *  *  Q  *  *  * 
 *  *  *  *  *  *  Q  * 
 *  *  *  Q  *  *  *  * 
 Q  *  *  *  *  *  *  * 
 *  *  *  *  *  *  *  Q 
 *  *  *  *  *  Q  *  * 
 *  *  Q  *  *  *  *  * 
8
[1, 5, 0, 6, 3, 7, 2, 4]
 *  Q  *  *  *  *  *  * 
 *  *  *  *  *  Q  *  * 
 Q  *  *  *  *  *  *  * 
 *  *  *  *  *  *  Q  * 
 *  *  *  Q  *  *  *  * 
 *  *  *  *  *  *  *  Q 
 *  *  Q  *  *  *  *  * 
 *  *  *  *  Q  *  *  * 
9
[1, 5, 7, 2, 0, 3, 6, 4]
 *  Q  *  *  *  *  *  * 
 *  *  *  *  *  Q  *  * 
 *  *  *  *  *  *  *  Q 
 *  *  Q  *  *  *  *  * 
 Q  *  *  *  *  *  *  * 
 *  *  *  Q  *  *  *  * 
 *  *  *  *  *  *  Q  * 
 *  *  *  *  Q  *  *  * 
10
[1, 6, 2, 5, 7, 4, 0, 3]
 *  Q  *  *  *  *  *  * 
 *  *  *  *  *  *  Q  * 
 *  *  Q  *  *  *  *  * 
 *  *  *  *  *  Q  *  * 
 *  *  *  *  *  *  *  Q 
 *  *  *  *  Q  *  *  * 
 Q  *  *  *  *  *  *  * 
 *  *  *  Q  *  *  *  * 
11
[1, 6, 4, 7, 0, 3, 5, 2]
 *  Q  *  *  *  *  *  * 
 *  *  *  *  *  *  Q  * 
 *  *  *  *  Q  *  *  * 
 *  *  *  *  *  *  *  Q 
 Q  *  *  *  *  *  *  * 
 *  *  *  Q  *  *  *  * 
 *  *  *  *  *  Q  *  * 
 *  *  Q  *  *  *  *  * 
12
[1, 7, 5, 0, 2, 4, 6, 3]
 *  Q  *  *  *  *  *  * 
 *  *  *  *  *  *  *  Q 
 *  *  *  *  *  Q  *  * 
 Q  *  *  *  *  *  *  * 
 *  *  Q  *  *  *  *  * 
 *  *  *  *  Q  *  *  * 
 *  *  *  *  *  *  Q  * 
 *  *  *  Q  *  *  *  * 
13
[2, 0, 6, 4, 7, 1, 3, 5]
 *  *  Q  *  *  *  *  * 
 Q  *  *  *  *  *  *  * 
 *  *  *  *  *  *  Q  * 
 *  *  *  *  Q  *  *  * 
 *  *  *  *  *  *  *  Q 
 *  Q  *  *  *  *  *  * 
 *  *  *  Q  *  *  *  * 
 *  *  *  *  *  Q  *  * 
14
[2, 4, 1, 7, 0, 6, 3, 5]
 *  *  Q  *  *  *  *  * 
 *  *  *  *  Q  *  *  * 
 *  Q  *  *  *  *  *  * 
 *  *  *  *  *  *  *  Q 
 Q  *  *  *  *  *  *  * 
 *  *  *  *  *  *  Q  * 
 *  *  *  Q  *  *  *  * 
 *  *  *  *  *  Q  *  * 
15
[2, 4, 1, 7, 5, 3, 6, 0]
 *  *  Q  *  *  *  *  * 
 *  *  *  *  Q  *  *  * 
 *  Q  *  *  *  *  *  * 
 *  *  *  *  *  *  *  Q 
 *  *  *  *  *  Q  *  * 
 *  *  *  Q  *  *  *  * 
 *  *  *  *  *  *  Q  * 
 Q  *  *  *  *  *  *  * 
16
[2, 4, 6, 0, 3, 1, 7, 5]
 *  *  Q  *  *  *  *  * 
 *  *  *  *  Q  *  *  * 
 *  *  *  *  *  *  Q  * 
 Q  *  *  *  *  *  *  * 
 *  *  *  Q  *  *  *  * 
 *  Q  *  *  *  *  *  * 
 *  *  *  *  *  *  *  Q 
 *  *  *  *  *  Q  *  * 
17
[2, 4, 7, 3, 0, 6, 1, 5]
 *  *  Q  *  *  *  *  * 
 *  *  *  *  Q  *  *  * 
 *  *  *  *  *  *  *  Q 
 *  *  *  Q  *  *  *  * 
 Q  *  *  *  *  *  *  * 
 *  *  *  *  *  *  Q  * 
 *  Q  *  *  *  *  *  * 
 *  *  *  *  *  Q  *  * 
18
[2, 5, 1, 4, 7, 0, 6, 3]
 *  *  Q  *  *  *  *  * 
 *  *  *  *  *  Q  *  * 
 *  Q  *  *  *  *  *  * 
 *  *  *  *  Q  *  *  * 
 *  *  *  *  *  *  *  Q 
 Q  *  *  *  *  *  *  * 
 *  *  *  *  *  *  Q  * 
 *  *  *  Q  *  *  *  * 
19
[2, 5, 1, 6, 0, 3, 7, 4]
 *  *  Q  *  *  *  *  * 
 *  *  *  *  *  Q  *  * 
 *  Q  *  *  *  *  *  * 
 *  *  *  *  *  *  Q  * 
 Q  *  *  *  *  *  *  * 
 *  *  *  Q  *  *  *  * 
 *  *  *  *  *  *  *  Q 
 *  *  *  *  Q  *  *  * 
20
[2, 5, 1, 6, 4, 0, 7, 3]
 *  *  Q  *  *  *  *  * 
 *  *  *  *  *  Q  *  * 
 *  Q  *  *  *  *  *  * 
 *  *  *  *  *  *  Q  * 
 *  *  *  *  Q  *  *  * 
 Q  *  *  *  *  *  *  * 
 *  *  *  *  *  *  *  Q 
 *  *  *  Q  *  *  *  * 
21
[2, 5, 3, 0, 7, 4, 6, 1]
 *  *  Q  *  *  *  *  * 
 *  *  *  *  *  Q  *  * 
 *  *  *  Q  *  *  *  * 
 Q  *  *  *  *  *  *  * 
 *  *  *  *  *  *  *  Q 
 *  *  *  *  Q  *  *  * 
 *  *  *  *  *  *  Q  * 
 *  Q  *  *  *  *  *  * 
22
[2, 5, 3, 1, 7, 4, 6, 0]
 *  *  Q  *  *  *  *  * 
 *  *  *  *  *  Q  *  * 
 *  *  *  Q  *  *  *  * 
 *  Q  *  *  *  *  *  * 
 *  *  *  *  *  *  *  Q 
 *  *  *  *  Q  *  *  * 
 *  *  *  *  *  *  Q  * 
 Q  *  *  *  *  *  *  * 
23
[2, 5, 7, 0, 3, 6, 4, 1]
 *  *  Q  *  *  *  *  * 
 *  *  *  *  *  Q  *  * 
 *  *  *  *  *  *  *  Q 
 Q  *  *  *  *  *  *  * 
 *  *  *  Q  *  *  *  * 
 *  *  *  *  *  *  Q  * 
 *  *  *  *  Q  *  *  * 
 *  Q  *  *  *  *  *  * 
24
[2, 5, 7, 0, 4, 6, 1, 3]
 *  *  Q  *  *  *  *  * 
 *  *  *  *  *  Q  *  * 
 *  *  *  *  *  *  *  Q 
 Q  *  *  *  *  *  *  * 
 *  *  *  *  Q  *  *  * 
 *  *  *  *  *  *  Q  * 
 *  Q  *  *  *  *  *  * 
 *  *  *  Q  *  *  *  * 
25
[2, 5, 7, 1, 3, 0, 6, 4]
 *  *  Q  *  *  *  *  * 
 *  *  *  *  *  Q  *  * 
 *  *  *  *  *  *  *  Q 
 *  Q  *  *  *  *  *  * 
 *  *  *  Q  *  *  *  * 
 Q  *  *  *  *  *  *  * 
 *  *  *  *  *  *  Q  * 
 *  *  *  *  Q  *  *  * 
26
[2, 6, 1, 7, 4, 0, 3, 5]
 *  *  Q  *  *  *  *  * 
 *  *  *  *  *  *  Q  * 
 *  Q  *  *  *  *  *  * 
 *  *  *  *  *  *  *  Q 
 *  *  *  *  Q  *  *  * 
 Q  *  *  *  *  *  *  * 
 *  *  *  Q  *  *  *  * 
 *  *  *  *  *  Q  *  * 
27
[2, 6, 1, 7, 5, 3, 0, 4]
 *  *  Q  *  *  *  *  * 
 *  *  *  *  *  *  Q  * 
 *  Q  *  *  *  *  *  * 
 *  *  *  *  *  *  *  Q 
 *  *  *  *  *  Q  *  * 
 *  *  *  Q  *  *  *  * 
 Q  *  *  *  *  *  *  * 
 *  *  *  *  Q  *  *  * 
28
[2, 7, 3, 6, 0, 5, 1, 4]
 *  *  Q  *  *  *  *  * 
 *  *  *  *  *  *  *  Q 
 *  *  *  Q  *  *  *  * 
 *  *  *  *  *  *  Q  * 
 Q  *  *  *  *  *  *  * 
 *  *  *  *  *  Q  *  * 
 *  Q  *  *  *  *  *  * 
 *  *  *  *  Q  *  *  * 
29
[3, 0, 4, 7, 1, 6, 2, 5]
 *  *  *  Q  *  *  *  * 
 Q  *  *  *  *  *  *  * 
 *  *  *  *  Q  *  *  * 
 *  *  *  *  *  *  *  Q 
 *  Q  *  *  *  *  *  * 
 *  *  *  *  *  *  Q  * 
 *  *  Q  *  *  *  *  * 
 *  *  *  *  *  Q  *  * 
30
[3, 0, 4, 7, 5, 2, 6, 1]
 *  *  *  Q  *  *  *  * 
 Q  *  *  *  *  *  *  * 
 *  *  *  *  Q  *  *  * 
 *  *  *  *  *  *  *  Q 
 *  *  *  *  *  Q  *  * 
 *  *  Q  *  *  *  *  * 
 *  *  *  *  *  *  Q  * 
 *  Q  *  *  *  *  *  * 
31
[3, 1, 4, 7, 5, 0, 2, 6]
 *  *  *  Q  *  *  *  * 
 *  Q  *  *  *  *  *  * 
 *  *  *  *  Q  *  *  * 
 *  *  *  *  *  *  *  Q 
 *  *  *  *  *  Q  *  * 
 Q  *  *  *  *  *  *  * 
 *  *  Q  *  *  *  *  * 
 *  *  *  *  *  *  Q  * 
32
[3, 1, 6, 2, 5, 7, 0, 4]
 *  *  *  Q  *  *  *  * 
 *  Q  *  *  *  *  *  * 
 *  *  *  *  *  *  Q  * 
 *  *  Q  *  *  *  *  * 
 *  *  *  *  *  Q  *  * 
 *  *  *  *  *  *  *  Q 
 Q  *  *  *  *  *  *  * 
 *  *  *  *  Q  *  *  * 
33
[3, 1, 6, 2, 5, 7, 4, 0]
 *  *  *  Q  *  *  *  * 
 *  Q  *  *  *  *  *  * 
 *  *  *  *  *  *  Q  * 
 *  *  Q  *  *  *  *  * 
 *  *  *  *  *  Q  *  * 
 *  *  *  *  *  *  *  Q 
 *  *  *  *  Q  *  *  * 
 Q  *  *  *  *  *  *  * 
34
[3, 1, 6, 4, 0, 7, 5, 2]
 *  *  *  Q  *  *  *  * 
 *  Q  *  *  *  *  *  * 
 *  *  *  *  *  *  Q  * 
 *  *  *  *  Q  *  *  * 
 Q  *  *  *  *  *  *  * 
 *  *  *  *  *  *  *  Q 
 *  *  *  *  *  Q  *  * 
 *  *  Q  *  *  *  *  * 
35
[3, 1, 7, 4, 6, 0, 2, 5]
 *  *  *  Q  *  *  *  * 
 *  Q  *  *  *  *  *  * 
 *  *  *  *  *  *  *  Q 
 *  *  *  *  Q  *  *  * 
 *  *  *  *  *  *  Q  * 
 Q  *  *  *  *  *  *  * 
 *  *  Q  *  *  *  *  * 
 *  *  *  *  *  Q  *  * 
36
[3, 1, 7, 5, 0, 2, 4, 6]
 *  *  *  Q  *  *  *  * 
 *  Q  *  *  *  *  *  * 
 *  *  *  *  *  *  *  Q 
 *  *  *  *  *  Q  *  * 
 Q  *  *  *  *  *  *  * 
 *  *  Q  *  *  *  *  * 
 *  *  *  *  Q  *  *  * 
 *  *  *  *  *  *  Q  * 
37
[3, 5, 0, 4, 1, 7, 2, 6]
 *  *  *  Q  *  *  *  * 
 *  *  *  *  *  Q  *  * 
 Q  *  *  *  *  *  *  * 
 *  *  *  *  Q  *  *  * 
 *  Q  *  *  *  *  *  * 
 *  *  *  *  *  *  *  Q 
 *  *  Q  *  *  *  *  * 
 *  *  *  *  *  *  Q  * 
38
[3, 5, 7, 1, 6, 0, 2, 4]
 *  *  *  Q  *  *  *  * 
 *  *  *  *  *  Q  *  * 
 *  *  *  *  *  *  *  Q 
 *  Q  *  *  *  *  *  * 
 *  *  *  *  *  *  Q  * 
 Q  *  *  *  *  *  *  * 
 *  *  Q  *  *  *  *  * 
 *  *  *  *  Q  *  *  * 
39
[3, 5, 7, 2, 0, 6, 4, 1]
 *  *  *  Q  *  *  *  * 
 *  *  *  *  *  Q  *  * 
 *  *  *  *  *  *  *  Q 
 *  *  Q  *  *  *  *  * 
 Q  *  *  *  *  *  *  * 
 *  *  *  *  *  *  Q  * 
 *  *  *  *  Q  *  *  * 
 *  Q  *  *  *  *  *  * 
40
[3, 6, 0, 7, 4, 1, 5, 2]
 *  *  *  Q  *  *  *  * 
 *  *  *  *  *  *  Q  * 
 Q  *  *  *  *  *  *  * 
 *  *  *  *  *  *  *  Q 
 *  *  *  *  Q  *  *  * 
 *  Q  *  *  *  *  *  * 
 *  *  *  *  *  Q  *  * 
 *  *  Q  *  *  *  *  * 
41
[3, 6, 2, 7, 1, 4, 0, 5]
 *  *  *  Q  *  *  *  * 
 *  *  *  *  *  *  Q  * 
 *  *  Q  *  *  *  *  * 
 *  *  *  *  *  *  *  Q 
 *  Q  *  *  *  *  *  * 
 *  *  *  *  Q  *  *  * 
 Q  *  *  *  *  *  *  * 
 *  *  *  *  *  Q  *  * 
42
[3, 6, 4, 1, 5, 0, 2, 7]
 *  *  *  Q  *  *  *  * 
 *  *  *  *  *  *  Q  * 
 *  *  *  *  Q  *  *  * 
 *  Q  *  *  *  *  *  * 
 *  *  *  *  *  Q  *  * 
 Q  *  *  *  *  *  *  * 
 *  *  Q  *  *  *  *  * 
 *  *  *  *  *  *  *  Q 
43
[3, 6, 4, 2, 0, 5, 7, 1]
 *  *  *  Q  *  *  *  * 
 *  *  *  *  *  *  Q  * 
 *  *  *  *  Q  *  *  * 
 *  *  Q  *  *  *  *  * 
 Q  *  *  *  *  *  *  * 
 *  *  *  *  *  Q  *  * 
 *  *  *  *  *  *  *  Q 
 *  Q  *  *  *  *  *  * 
44
[3, 7, 0, 2, 5, 1, 6, 4]
 *  *  *  Q  *  *  *  * 
 *  *  *  *  *  *  *  Q 
 Q  *  *  *  *  *  *  * 
 *  *  Q  *  *  *  *  * 
 *  *  *  *  *  Q  *  * 
 *  Q  *  *  *  *  *  * 
 *  *  *  *  *  *  Q  * 
 *  *  *  *  Q  *  *  * 
45
[3, 7, 0, 4, 6, 1, 5, 2]
 *  *  *  Q  *  *  *  * 
 *  *  *  *  *  *  *  Q 
 Q  *  *  *  *  *  *  * 
 *  *  *  *  Q  *  *  * 
 *  *  *  *  *  *  Q  * 
 *  Q  *  *  *  *  *  * 
 *  *  *  *  *  Q  *  * 
 *  *  Q  *  *  *  *  * 
46
[3, 7, 4, 2, 0, 6, 1, 5]
 *  *  *  Q  *  *  *  * 
 *  *  *  *  *  *  *  Q 
 *  *  *  *  Q  *  *  * 
 *  *  Q  *  *  *  *  * 
 Q  *  *  *  *  *  *  * 
 *  *  *  *  *  *  Q  * 
 *  Q  *  *  *  *  *  * 
 *  *  *  *  *  Q  *  * 
47
[4, 0, 3, 5, 7, 1, 6, 2]
 *  *  *  *  Q  *  *  * 
 Q  *  *  *  *  *  *  * 
 *  *  *  Q  *  *  *  * 
 *  *  *  *  *  Q  *  * 
 *  *  *  *  *  *  *  Q 
 *  Q  *  *  *  *  *  * 
 *  *  *  *  *  *  Q  * 
 *  *  Q  *  *  *  *  * 
48
[4, 0, 7, 3, 1, 6, 2, 5]
 *  *  *  *  Q  *  *  * 
 Q  *  *  *  *  *  *  * 
 *  *  *  *  *  *  *  Q 
 *  *  *  Q  *  *  *  * 
 *  Q  *  *  *  *  *  * 
 *  *  *  *  *  *  Q  * 
 *  *  Q  *  *  *  *  * 
 *  *  *  *  *  Q  *  * 
49
[4, 0, 7, 5, 2, 6, 1, 3]
 *  *  *  *  Q  *  *  * 
 Q  *  *  *  *  *  *  * 
 *  *  *  *  *  *  *  Q 
 *  *  *  *  *  Q  *  * 
 *  *  Q  *  *  *  *  * 
 *  *  *  *  *  *  Q  * 
 *  Q  *  *  *  *  *  * 
 *  *  *  Q  *  *  *  * 
50
[4, 1, 3, 5, 7, 2, 0, 6]
 *  *  *  *  Q  *  *  * 
 *  Q  *  *  *  *  *  * 
 *  *  *  Q  *  *  *  * 
 *  *  *  *  *  Q  *  * 
 *  *  *  *  *  *  *  Q 
 *  *  Q  *  *  *  *  * 
 Q  *  *  *  *  *  *  * 
 *  *  *  *  *  *  Q  * 
51
[4, 1, 3, 6, 2, 7, 5, 0]
 *  *  *  *  Q  *  *  * 
 *  Q  *  *  *  *  *  * 
 *  *  *  Q  *  *  *  * 
 *  *  *  *  *  *  Q  * 
 *  *  Q  *  *  *  *  * 
 *  *  *  *  *  *  *  Q 
 *  *  *  *  *  Q  *  * 
 Q  *  *  *  *  *  *  * 
52
[4, 1, 5, 0, 6, 3, 7, 2]
 *  *  *  *  Q  *  *  * 
 *  Q  *  *  *  *  *  * 
 *  *  *  *  *  Q  *  * 
 Q  *  *  *  *  *  *  * 
 *  *  *  *  *  *  Q  * 
 *  *  *  Q  *  *  *  * 
 *  *  *  *  *  *  *  Q 
 *  *  Q  *  *  *  *  * 
53
[4, 1, 7, 0, 3, 6, 2, 5]
 *  *  *  *  Q  *  *  * 
 *  Q  *  *  *  *  *  * 
 *  *  *  *  *  *  *  Q 
 Q  *  *  *  *  *  *  * 
 *  *  *  Q  *  *  *  * 
 *  *  *  *  *  *  Q  * 
 *  *  Q  *  *  *  *  * 
 *  *  *  *  *  Q  *  * 
54
[4, 2, 0, 5, 7, 1, 3, 6]
 *  *  *  *  Q  *  *  * 
 *  *  Q  *  *  *  *  * 
 Q  *  *  *  *  *  *  * 
 *  *  *  *  *  Q  *  * 
 *  *  *  *  *  *  *  Q 
 *  Q  *  *  *  *  *  * 
 *  *  *  Q  *  *  *  * 
 *  *  *  *  *  *  Q  * 
55
[4, 2, 0, 6, 1, 7, 5, 3]
 *  *  *  *  Q  *  *  * 
 *  *  Q  *  *  *  *  * 
 Q  *  *  *  *  *  *  * 
 *  *  *  *  *  *  Q  * 
 *  Q  *  *  *  *  *  * 
 *  *  *  *  *  *  *  Q 
 *  *  *  *  *  Q  *  * 
 *  *  *  Q  *  *  *  * 
56
[4, 2, 7, 3, 6, 0, 5, 1]
 *  *  *  *  Q  *  *  * 
 *  *  Q  *  *  *  *  * 
 *  *  *  *  *  *  *  Q 
 *  *  *  Q  *  *  *  * 
 *  *  *  *  *  *  Q  * 
 Q  *  *  *  *  *  *  * 
 *  *  *  *  *  Q  *  * 
 *  Q  *  *  *  *  *  * 
57
[4, 6, 0, 2, 7, 5, 3, 1]
 *  *  *  *  Q  *  *  * 
 *  *  *  *  *  *  Q  * 
 Q  *  *  *  *  *  *  * 
 *  *  Q  *  *  *  *  * 
 *  *  *  *  *  *  *  Q 
 *  *  *  *  *  Q  *  * 
 *  *  *  Q  *  *  *  * 
 *  Q  *  *  *  *  *  * 
58
[4, 6, 0, 3, 1, 7, 5, 2]
 *  *  *  *  Q  *  *  * 
 *  *  *  *  *  *  Q  * 
 Q  *  *  *  *  *  *  * 
 *  *  *  Q  *  *  *  * 
 *  Q  *  *  *  *  *  * 
 *  *  *  *  *  *  *  Q 
 *  *  *  *  *  Q  *  * 
 *  *  Q  *  *  *  *  * 
59
[4, 6, 1, 3, 7, 0, 2, 5]
 *  *  *  *  Q  *  *  * 
 *  *  *  *  *  *  Q  * 
 *  Q  *  *  *  *  *  * 
 *  *  *  Q  *  *  *  * 
 *  *  *  *  *  *  *  Q 
 Q  *  *  *  *  *  *  * 
 *  *  Q  *  *  *  *  * 
 *  *  *  *  *  Q  *  * 
60
[4, 6, 1, 5, 2, 0, 3, 7]
 *  *  *  *  Q  *  *  * 
 *  *  *  *  *  *  Q  * 
 *  Q  *  *  *  *  *  * 
 *  *  *  *  *  Q  *  * 
 *  *  Q  *  *  *  *  * 
 Q  *  *  *  *  *  *  * 
 *  *  *  Q  *  *  *  * 
 *  *  *  *  *  *  *  Q 
61
[4, 6, 1, 5, 2, 0, 7, 3]
 *  *  *  *  Q  *  *  * 
 *  *  *  *  *  *  Q  * 
 *  Q  *  *  *  *  *  * 
 *  *  *  *  *  Q  *  * 
 *  *  Q  *  *  *  *  * 
 Q  *  *  *  *  *  *  * 
 *  *  *  *  *  *  *  Q 
 *  *  *  Q  *  *  *  * 
62
[4, 6, 3, 0, 2, 7, 5, 1]
 *  *  *  *  Q  *  *  * 
 *  *  *  *  *  *  Q  * 
 *  *  *  Q  *  *  *  * 
 Q  *  *  *  *  *  *  * 
 *  *  Q  *  *  *  *  * 
 *  *  *  *  *  *  *  Q 
 *  *  *  *  *  Q  *  * 
 *  Q  *  *  *  *  *  * 
63
[4, 7, 3, 0, 2, 5, 1, 6]
 *  *  *  *  Q  *  *  * 
 *  *  *  *  *  *  *  Q 
 *  *  *  Q  *  *  *  * 
 Q  *  *  *  *  *  *  * 
 *  *  Q  *  *  *  *  * 
 *  *  *  *  *  Q  *  * 
 *  Q  *  *  *  *  *  * 
 *  *  *  *  *  *  Q  * 
64
[4, 7, 3, 0, 6, 1, 5, 2]
 *  *  *  *  Q  *  *  * 
 *  *  *  *  *  *  *  Q 
 *  *  *  Q  *  *  *  * 
 Q  *  *  *  *  *  *  * 
 *  *  *  *  *  *  Q  * 
 *  Q  *  *  *  *  *  * 
 *  *  *  *  *  Q  *  * 
 *  *  Q  *  *  *  *  * 
65
[5, 0, 4, 1, 7, 2, 6, 3]
 *  *  *  *  *  Q  *  * 
 Q  *  *  *  *  *  *  * 
 *  *  *  *  Q  *  *  * 
 *  Q  *  *  *  *  *  * 
 *  *  *  *  *  *  *  Q 
 *  *  Q  *  *  *  *  * 
 *  *  *  *  *  *  Q  * 
 *  *  *  Q  *  *  *  * 
66
[5, 1, 6, 0, 2, 4, 7, 3]
 *  *  *  *  *  Q  *  * 
 *  Q  *  *  *  *  *  * 
 *  *  *  *  *  *  Q  * 
 Q  *  *  *  *  *  *  * 
 *  *  Q  *  *  *  *  * 
 *  *  *  *  Q  *  *  * 
 *  *  *  *  *  *  *  Q 
 *  *  *  Q  *  *  *  * 
67
[5, 1, 6, 0, 3, 7, 4, 2]
 *  *  *  *  *  Q  *  * 
 *  Q  *  *  *  *  *  * 
 *  *  *  *  *  *  Q  * 
 Q  *  *  *  *  *  *  * 
 *  *  *  Q  *  *  *  * 
 *  *  *  *  *  *  *  Q 
 *  *  *  *  Q  *  *  * 
 *  *  Q  *  *  *  *  * 
68
[5, 2, 0, 6, 4, 7, 1, 3]
 *  *  *  *  *  Q  *  * 
 *  *  Q  *  *  *  *  * 
 Q  *  *  *  *  *  *  * 
 *  *  *  *  *  *  Q  * 
 *  *  *  *  Q  *  *  * 
 *  *  *  *  *  *  *  Q 
 *  Q  *  *  *  *  *  * 
 *  *  *  Q  *  *  *  * 
69
[5, 2, 0, 7, 3, 1, 6, 4]
 *  *  *  *  *  Q  *  * 
 *  *  Q  *  *  *  *  * 
 Q  *  *  *  *  *  *  * 
 *  *  *  *  *  *  *  Q 
 *  *  *  Q  *  *  *  * 
 *  Q  *  *  *  *  *  * 
 *  *  *  *  *  *  Q  * 
 *  *  *  *  Q  *  *  * 
70
[5, 2, 0, 7, 4, 1, 3, 6]
 *  *  *  *  *  Q  *  * 
 *  *  Q  *  *  *  *  * 
 Q  *  *  *  *  *  *  * 
 *  *  *  *  *  *  *  Q 
 *  *  *  *  Q  *  *  * 
 *  Q  *  *  *  *  *  * 
 *  *  *  Q  *  *  *  * 
 *  *  *  *  *  *  Q  * 
71
[5, 2, 4, 6, 0, 3, 1, 7]
 *  *  *  *  *  Q  *  * 
 *  *  Q  *  *  *  *  * 
 *  *  *  *  Q  *  *  * 
 *  *  *  *  *  *  Q  * 
 Q  *  *  *  *  *  *  * 
 *  *  *  Q  *  *  *  * 
 *  Q  *  *  *  *  *  * 
 *  *  *  *  *  *  *  Q 
72
[5, 2, 4, 7, 0, 3, 1, 6]
 *  *  *  *  *  Q  *  * 
 *  *  Q  *  *  *  *  * 
 *  *  *  *  Q  *  *  * 
 *  *  *  *  *  *  *  Q 
 Q  *  *  *  *  *  *  * 
 *  *  *  Q  *  *  *  * 
 *  Q  *  *  *  *  *  * 
 *  *  *  *  *  *  Q  * 
73
[5, 2, 6, 1, 3, 7, 0, 4]
 *  *  *  *  *  Q  *  * 
 *  *  Q  *  *  *  *  * 
 *  *  *  *  *  *  Q  * 
 *  Q  *  *  *  *  *  * 
 *  *  *  Q  *  *  *  * 
 *  *  *  *  *  *  *  Q 
 Q  *  *  *  *  *  *  * 
 *  *  *  *  Q  *  *  * 
74
[5, 2, 6, 1, 7, 4, 0, 3]
 *  *  *  *  *  Q  *  * 
 *  *  Q  *  *  *  *  * 
 *  *  *  *  *  *  Q  * 
 *  Q  *  *  *  *  *  * 
 *  *  *  *  *  *  *  Q 
 *  *  *  *  Q  *  *  * 
 Q  *  *  *  *  *  *  * 
 *  *  *  Q  *  *  *  * 
75
[5, 2, 6, 3, 0, 7, 1, 4]
 *  *  *  *  *  Q  *  * 
 *  *  Q  *  *  *  *  * 
 *  *  *  *  *  *  Q  * 
 *  *  *  Q  *  *  *  * 
 Q  *  *  *  *  *  *  * 
 *  *  *  *  *  *  *  Q 
 *  Q  *  *  *  *  *  * 
 *  *  *  *  Q  *  *  * 
76
[5, 3, 0, 4, 7, 1, 6, 2]
 *  *  *  *  *  Q  *  * 
 *  *  *  Q  *  *  *  * 
 Q  *  *  *  *  *  *  * 
 *  *  *  *  Q  *  *  * 
 *  *  *  *  *  *  *  Q 
 *  Q  *  *  *  *  *  * 
 *  *  *  *  *  *  Q  * 
 *  *  Q  *  *  *  *  * 
77
[5, 3, 1, 7, 4, 6, 0, 2]
 *  *  *  *  *  Q  *  * 
 *  *  *  Q  *  *  *  * 
 *  Q  *  *  *  *  *  * 
 *  *  *  *  *  *  *  Q 
 *  *  *  *  Q  *  *  * 
 *  *  *  *  *  *  Q  * 
 Q  *  *  *  *  *  *  * 
 *  *  Q  *  *  *  *  * 
78
[5, 3, 6, 0, 2, 4, 1, 7]
 *  *  *  *  *  Q  *  * 
 *  *  *  Q  *  *  *  * 
 *  *  *  *  *  *  Q  * 
 Q  *  *  *  *  *  *  * 
 *  *  Q  *  *  *  *  * 
 *  *  *  *  Q  *  *  * 
 *  Q  *  *  *  *  *  * 
 *  *  *  *  *  *  *  Q 
79
[5, 3, 6, 0, 7, 1, 4, 2]
 *  *  *  *  *  Q  *  * 
 *  *  *  Q  *  *  *  * 
 *  *  *  *  *  *  Q  * 
 Q  *  *  *  *  *  *  * 
 *  *  *  *  *  *  *  Q 
 *  Q  *  *  *  *  *  * 
 *  *  *  *  Q  *  *  * 
 *  *  Q  *  *  *  *  * 
80
[5, 7, 1, 3, 0, 6, 4, 2]
 *  *  *  *  *  Q  *  * 
 *  *  *  *  *  *  *  Q 
 *  Q  *  *  *  *  *  * 
 *  *  *  Q  *  *  *  * 
 Q  *  *  *  *  *  *  * 
 *  *  *  *  *  *  Q  * 
 *  *  *  *  Q  *  *  * 
 *  *  Q  *  *  *  *  * 
81
[6, 0, 2, 7, 5, 3, 1, 4]
 *  *  *  *  *  *  Q  * 
 Q  *  *  *  *  *  *  * 
 *  *  Q  *  *  *  *  * 
 *  *  *  *  *  *  *  Q 
 *  *  *  *  *  Q  *  * 
 *  *  *  Q  *  *  *  * 
 *  Q  *  *  *  *  *  * 
 *  *  *  *  Q  *  *  * 
82
[6, 1, 3, 0, 7, 4, 2, 5]
 *  *  *  *  *  *  Q  * 
 *  Q  *  *  *  *  *  * 
 *  *  *  Q  *  *  *  * 
 Q  *  *  *  *  *  *  * 
 *  *  *  *  *  *  *  Q 
 *  *  *  *  Q  *  *  * 
 *  *  Q  *  *  *  *  * 
 *  *  *  *  *  Q  *  * 
83
[6, 1, 5, 2, 0, 3, 7, 4]
 *  *  *  *  *  *  Q  * 
 *  Q  *  *  *  *  *  * 
 *  *  *  *  *  Q  *  * 
 *  *  Q  *  *  *  *  * 
 Q  *  *  *  *  *  *  * 
 *  *  *  Q  *  *  *  * 
 *  *  *  *  *  *  *  Q 
 *  *  *  *  Q  *  *  * 
84
[6, 2, 0, 5, 7, 4, 1, 3]
 *  *  *  *  *  *  Q  * 
 *  *  Q  *  *  *  *  * 
 Q  *  *  *  *  *  *  * 
 *  *  *  *  *  Q  *  * 
 *  *  *  *  *  *  *  Q 
 *  *  *  *  Q  *  *  * 
 *  Q  *  *  *  *  *  * 
 *  *  *  Q  *  *  *  * 
85
[6, 2, 7, 1, 4, 0, 5, 3]
 *  *  *  *  *  *  Q  * 
 *  *  Q  *  *  *  *  * 
 *  *  *  *  *  *  *  Q 
 *  Q  *  *  *  *  *  * 
 *  *  *  *  Q  *  *  * 
 Q  *  *  *  *  *  *  * 
 *  *  *  *  *  Q  *  * 
 *  *  *  Q  *  *  *  * 
86
[6, 3, 1, 4, 7, 0, 2, 5]
 *  *  *  *  *  *  Q  * 
 *  *  *  Q  *  *  *  * 
 *  Q  *  *  *  *  *  * 
 *  *  *  *  Q  *  *  * 
 *  *  *  *  *  *  *  Q 
 Q  *  *  *  *  *  *  * 
 *  *  Q  *  *  *  *  * 
 *  *  *  *  *  Q  *  * 
87
[6, 3, 1, 7, 5, 0, 2, 4]
 *  *  *  *  *  *  Q  * 
 *  *  *  Q  *  *  *  * 
 *  Q  *  *  *  *  *  * 
 *  *  *  *  *  *  *  Q 
 *  *  *  *  *  Q  *  * 
 Q  *  *  *  *  *  *  * 
 *  *  Q  *  *  *  *  * 
 *  *  *  *  Q  *  *  * 
88
[6, 4, 2, 0, 5, 7, 1, 3]
 *  *  *  *  *  *  Q  * 
 *  *  *  *  Q  *  *  * 
 *  *  Q  *  *  *  *  * 
 Q  *  *  *  *  *  *  * 
 *  *  *  *  *  Q  *  * 
 *  *  *  *  *  *  *  Q 
 *  Q  *  *  *  *  *  * 
 *  *  *  Q  *  *  *  * 
89
[7, 1, 3, 0, 6, 4, 2, 5]
 *  *  *  *  *  *  *  Q 
 *  Q  *  *  *  *  *  * 
 *  *  *  Q  *  *  *  * 
 Q  *  *  *  *  *  *  * 
 *  *  *  *  *  *  Q  * 
 *  *  *  *  Q  *  *  * 
 *  *  Q  *  *  *  *  * 
 *  *  *  *  *  Q  *  * 
90
[7, 1, 4, 2, 0, 6, 3, 5]
 *  *  *  *  *  *  *  Q 
 *  Q  *  *  *  *  *  * 
 *  *  *  *  Q  *  *  * 
 *  *  Q  *  *  *  *  * 
 Q  *  *  *  *  *  *  * 
 *  *  *  *  *  *  Q  * 
 *  *  *  Q  *  *  *  * 
 *  *  *  *  *  Q  *  * 
91
[7, 2, 0, 5, 1, 4, 6, 3]
 *  *  *  *  *  *  *  Q 
 *  *  Q  *  *  *  *  * 
 Q  *  *  *  *  *  *  * 
 *  *  *  *  *  Q  *  * 
 *  Q  *  *  *  *  *  * 
 *  *  *  *  Q  *  *  * 
 *  *  *  *  *  *  Q  * 
 *  *  *  Q  *  *  *  * 
92
[7, 3, 0, 2, 5, 1, 6, 4]
 *  *  *  *  *  *  *  Q 
 *  *  *  Q  *  *  *  * 
 Q  *  *  *  *  *  *  * 
 *  *  Q  *  *  *  *  * 
 *  *  *  *  *  Q  *  * 
 *  Q  *  *  *  *  *  * 
 *  *  *  *  *  *  Q  * 
 *  *  *  *  Q  *  *  * 
```

### 0-1背包问题

> 有一个最多可容纳M重量的背包，有n个重量不同的物品。在总重量不超过M的前提下，怎么放置可以使得背包内物品总重量最大。
>
> 这些物品不能拆分。**要么放要么不放，所以称为0-1背包问题。**

```java
public class zeroOnePackage {

    @Test
    public void test() {
      	//物品集合
        int[] items = {100, 200, 300, 400, 500, 600, 700, 200};
        f(0, 0, items);
    }
		
  	//最大重量
    int max = 1000;

    public void f(int i, int current, int[] items) {
        if (current == max || i == items.length) {
            // cw==w表示装满了;i==n表示已经考察完所有的物品
            return;
        }
        //不装当前的情况
        f(i + 1, current, items);

        // 装当前
        // 已经超过可以背包承受的重量的时候，就不要再装了
        if (current + items[i] <= max) {
            f(i + 1, current + items[i], items);
        }
    }
}
```

### 正则表达式通配符问题

> 正则表达式的通配符，可以支持非常多的语义。
>
> 打个比方：「*」匹配任意多个「多个或一个」任意字符。「?」匹配零个或任意一个字符。
>
> 那么通配符在进行适配的时候，可以匹配很多的情况。但是只要有一个成功匹配的，就说明正则表达式匹配成功。
>
> 也是使用回溯算法。

```java
public class Pattern {

    public static void main(String[] args) {
        Pattern pattern = new Pattern("**9??d?*");
        boolean adfsd9fd = pattern.match("adfsd9fd");
        System.out.println(adfsd9fd);
    }


    private boolean matched = false;
    private char[] pattern; // 正则表达式


    public Pattern(String pattern) {
        this.pattern = pattern.toCharArray();
    }

    public boolean match(String text) { // 文本串及长度
        matched = false;
        rmatch(0, 0, text.toCharArray());
        return matched;
    }

    private void rmatch(int ti, int pj, char[] text) {
        if (matched) {
            return; // 如果已经匹配了，就不要继续递归了
        }
        if (pj == pattern.length) { // 正则表达式到结尾了
            if (ti == text.length) {
                matched = true; // 文本串也到结尾了
            }
            return;
        }
        if (pattern[pj] == '*') { // *匹配任意个字符
            for (int k = 0; k <= text.length - ti; ++k) {
                rmatch(ti + k, pj + 1, text);
            }
        } else if (pattern[pj] == '?') { // ?匹配0个或者1个字符
            rmatch(ti, pj + 1, text);
            rmatch(ti + 1, pj + 1, text);
        } else if (ti < text.length && pattern[pj] == text[ti]) { // 纯字符匹配才行
            rmatch(ti + 1, pj + 1, text);
        }
    }
}
```

## 动态规划

### 再回到0-1背包问题

> 我们先回到之前的0-1背包问题。

```java
@Test
public void test() {
    int[] weight = {2, 2, 4, 6, 3};
    f(0, 0, weight);
    System.out.println(result);
}

int max = 9;

int result = -1;

public void f(int i, int current, int[] items) {
    if (current == max || i == items.length) {
        // cw==w表示装满了;i==n表示已经考察完所有的物品
        if (current > result) {
            result = current;
        }
        return;
    }
    //不装当前的情况
    f(i + 1, current, items);

    // 装当前
    // 已经超过可以背包承受的重量的时候，就不要再装了
    if (current + items[i] <= max) {
        f(i + 1, current + items[i], items);
    }
}
```

每一个元素，都进行0或1的添加。时间复杂度为$O(n^2)$。

过程如下图

> f ( 2 , 0 ) 这个表示当前的计算结果 2是当前元素的下标，0是进行当前抉择后背包总重量。

![image-20210420225941456](https://gitee.com/wangigor/typora-images/raw/master/image-20210420225941423456.jpeg)

> 有些计算是重复计算。先使用「**递归中的备忘录方式**」对算法进行优化。

### 备忘录优化

```java
boolean[][] memo = new boolean[weight.length][max+1];

public void fWithMemo(int i, int current) {
    if (current == max || i == weight.length) {
        if (current > result) {
            result = current;
        }
        return;
    }

    //备忘录查询是否计算过
    if (memo[i][current]) {
        return;
    }
    memo[i][current] = true;

    fWithMemo(i + 1, current);
    if (current + weight[i] <= max) {
        fWithMemo(i + 1, current + weight[i]);
    }
}
```

这个速度是很快的。

> 以下面数据为例
>
> ```java
> int[] weight = {2, 2, 3, 6, 4, 6, 8, 4, 6, 8, 4, 3, 6, 5, 3, 2, 4, 5, 6, 7, 8, 9, 4, 3, 2, 5, 6, 7, 8};
> int max = 100;
> 
> //回溯算法执行时间 1833ms  1833879402ns
> //优化后          0.4ms      423509ns
> ```

下面来看一下这个备忘录memo二维数组的形成过程。

初始化

<img src="https://gitee.com/wangigor/typora-images/raw/master/image-20210422223655239.png" alt="image-20210422223655239" style="zoom:50%;" />

然后进行第一个元素决策。可以达到的重量是0和2.

<img src="https://gitee.com/wangigor/typora-images/raw/master/image-20210422223818977775.png" alt="image-20210422223818975" style="zoom:50%;" />

后续每一层，都在第一层的基础上。先继承下来上一层的元素，再在每一个继承元素上增加本层元素值。

<img src="https://gitee.com/wangigor/typora-images/raw/master/image-2021042222423019587.jpeg" alt="image-20210422224019587" style="zoom:50%;" />



那么。在纵轴这个维度上，可以达到的最大高度就是可以达到的最大重量。「0-1背包的题最大是9」

> 这其实就是一种动态规划的思想：
>
> ```text
> 我们把问题分解为多个阶段，每个阶段对应一个决策。
> 我们记录每一个阶段可达的状态集合（去掉重复的），然后通过当前阶段的状态集合，来推导下一个阶段的状态集合，动态地往前推进。
> ```

下面把上面的过程写成代码：

```java
public int knapsack(int[] weights, int max) {
    boolean[][] memo = new boolean[weights.length][max + 1];

    //对第一次进行手动处理
    memo[0][0] = true;
    if (weights[0] < max) {
        memo[0][weights[0]] = true;
    }
    //从第二层开始动态推进
    for (int i = 1; i < weights.length; ++i) {
        for (int j = 0; j < max; ++j) {
            if (memo[i - 1][j]) {
                memo[i][j] = true; //上一层的搬下来
                if (j + weights[i] <= max) { //推进一位
                    memo[i][j + weights[i]] = true;
                }
            }
        }
    }
    //输出最大重量
    for (int i = max; i >= 0; --i) {
        //最后一行倒着往前找
        if (memo[weights.length - 1][i]) {
            return i;
        }
    }
    return 0;
}
```

> 上面的测试数据 81653ns。比备忘录方式还要快。

### 二维数组优化

就是空间有点大。是一个weight.length * max+1的二维数组。

> 其实只需要一个max+1的一位数组就可以了。一遍一遍的循环遍历嘛。
>
> 这样还有一个好处。
>
> 就是。**如果当前层的元素值 加上当前的遍历位置已经超过了max的话，就停**。而在上面的代码中不能停，还要进行上层其余元素的搬运。「只做0决策」
>
> 出了一个问题：
>
> 只有一行数据的话。不知道「哪些数据是从上一次遍历的时候继承过来的」。也就是说假设这一层新设置了一个memo[7]=true,那么上一次遍历的时候memo[7]这个位置是不是7呢，就会出现**重复计算**的问题。怎么解决：
>
> **从大到小遍历。**
>
> 那么。再改进一下代码。

```java
public int betterKnapsack(int[] weights, int max) {
    boolean[] memo = new boolean[max + 1];
    //对第一次进行手动处理
    memo[0] = true;
    if (weights[0] < max) {
        memo[weights[0]] = true;
    }
    //从第二层开始动态推进
    for (int i = 1; i < weights.length; ++i) {
        for (int j = max - weights[i]; j >= 0; --j) {
            //推进一位
            if (memo[j]) {
                memo[j + weights[i]] = true;
            }
        }
    }
    //输出最大重量
    for (int i = max; i >= 0; --i) {
        //最后一行倒着往前找
        if (memo[i]) {
            return i;
        }
    }
    return 0;
}
```

> 上面的测试数据 40865ns。又更快了一点点。
>
> 这是个啥概念呢。**「0.04毫秒」**

### 增加「价值轴」

> 继续上面的问题，再升级。
>
> 假设不同重量的物品**有不同的价值**，在保证总重量不超过背包称重的前提下，使背包总价值最大。
>
> 先进行简单的最大价值的求解。

```java
int[] weights = {2, 2, 4, 6, 3};
int max = 9;
int[] values = {3, 4, 8, 9, 6};
int maxValue = -1;

@Test
public void testMaxValue() {
    m(0,0,0);
    System.out.println(maxValue);
}

public void f(int i, int weight, int value) {
    if (i == weights.length || weight == max) {
        if (value > maxValue) {//比较价值
            maxValue = value;
        }
        return;
    }

    f(i + 1, weight, value);
    if (weight + weights[i] <= max) {
        f(i + 1, weight + weights[i], value + values[i]);
    }
}
```

画出递归树。

![image-20210426213845231](https://gitee.com/wangigor/typora-images/raw/master/image-20210426213845231.jpeg)

> 就出现一个问题。
>
> 对于 **f(2,2,3) 和 f(2,2,4)**这样的情况：同一层决策，总重量相同，但是**价值不同**。f(2,2,3)的所有子树都是小于f(2,2,4)的，那么就没必要计算。
>
> 那么还是使用备忘录的二维数组，元素不再使用boolean类型，而是使用int记录价值。
>
> 且，加上「动态规划」的递推：根据上一层状态，求解下一层。
>
> 代码如下。

```java
public int knapsack3(int[] weights, int[] values, int max) {
    int[][] memo = new int[weights.length][max + 1];
    //初始化二维数组
    for (int i = 0; i < weights.length; ++i) {
        for (int j = 0; j <= max; ++j) {
            memo[i][j] = -1;
        }
    }
    //特殊处理0
    memo[0][0] = 0;
    if (weights[0] <= max) {
        memo[0][weights[0]] = values[0];
    }
    //开始递推每一层数据
    for (int i = 1; i < weights.length; ++i) {
        for (int j = 0; j < max + 1; ++j) {
            //上层有数据
            if (memo[i - 1][j] >= 0) {
                //如果当前备忘已经有值且大于上一层数据，不重复计算 && memo[i][j] < memo[i - 1][j]
                //搬移上层数据 也就是不选择当前物品
                if (memo[i][j] < memo[i - 1][j]) {
                    memo[i][j] = memo[i - 1][j];
                }
                //不超重，选择当前物品
                //也要刨除重复计算部分
                if (j + weights[i] <= max && memo[i][j + weights[i]] < memo[i - 1][j] + values[i]) {
                    memo[i][j + weights[i]] = memo[i - 1][j] + values[i];
                }
            }
        }
    }

    //遍历二维数组得到最大值
    //只看最后一行就行
    int maxValue = -1;
    for (int i = 0; i < max + 1; ++i) {
        if (memo[weights.length-1][i] >= maxValue) {
            maxValue = memo[weights.length-1][i];
        }
    }
    return maxValue;
}
```

> 当然空间复杂度也是可以优化的。这里就不写了。
>
> 那么知道了最大价值之后，还需要直到是哪几个物品凑成了这个最大价值。可以通过maxValue所在位置进行反推。
>
> 反推代码如下：
>
> ```java
> int tempMax_value=maxValue;
> int temp_index=index;
> //maxValue在memo[weights.length-1][i]位置
> //他可能是从memo[weights.length-2][i]位置直接继承来的，也可能是从memo[weights.length-2][i-values[i]]加了values[i]过来的。
> for (int i = weights.length - 2; i >= 0; --i) {
>     if(tempMax_value==memo[i][temp_index]){
>     //从上一层继承过来的，所以没选择
>     }else if(tempMax_value==memo[i][temp_index-weights[i+1]]+values[i+1]){
>         System.out.println(i+1);
>         temp_index=temp_index-weights[i+1];
>         tempMax_value=tempMax_value-values[i+1];
>     }
> }
> ```

### 动态规划理论

> 动态规划理论可以总结为「一个模型三个特征」。

#### 一个模型

> 指的是动态规划适合解决问题的模型。也就是「**多阶段决策最优解模型**」。
>
> - 找到一个问题的最优解。
>
> - 需要经历多个决策阶段。
>
> - 每个决策阶段都对应一组决策状态。
>
> - 寻找一组决策序列『一条能够达到最优解的决策序列』。

#### 三个特征

- **最优子结构**

  **问题的最优解包含子问题的最优解。**

  可以通过子问题的最优解，推导出问题的最优解。

  也可以理解为后面阶段的最优状态，可以通过前面阶段的最优状态推导出来。

- **无后效性**

  在推导后面阶段状态的过程中，我们只关心前面阶段的状态值，不关心过程。

  某阶段状态一旦确定，不受之后阶段的决策影响。

- **重复子问题**

  不同的决策序列，达到相同的阶段时，可能会产生重复的状态。

#### 实例剖析

<img src="https://gitee.com/wangigor/typora-images/raw/master/image-20210502200256341.png" alt="image-20210502200256341" style="zoom: 50%;" />

> 假设我们有一个n*n的矩阵  w [ n ] [ n ]。矩阵存储的都是正整数，如上图所示。棋子起始位置在左上角，终止位置在右下角。我们将棋子从左上角移动到右下角。每次只能向右或者向下移动一位。求解移动路径的所有整数和的最小值。
>
> 从左上角到右上角，会有很多不同的路径。

符合「 **一个模型** 」

从（ 0 , 0 ）走到（ n-1 , n-1），总共要走2*( n-1 )步。也对应着 2\*( n-1 )个阶段。每个阶段都对应着「向右走」「向下走」两种决策。并且每个阶段都会对应一个状态集合。把每个阶段的状态定义为 min_dist( i , j )，其中i表示行，j表示列。min_dist表示从（ 0 , 0 ）到（ i , j ）的最短整数和。

<img src="https://gitee.com/wangigor/typora-images/raw/master/image-20210502202841569.jpeg" alt="image-20210502202841569" style="zoom:50%;" />

符合「 **重复子问题** 」

<img src="https://gitee.com/wangigor/typora-images/raw/master/image-20210502203514877.png" alt="image-20210502203514877" style="zoom:50%;" />

> 从（ 0 , 0 ）走到（ 2 , 2 ）有很多条路。

符合「 **无后效性** 」

> ( i , j )这个位置的状态值，只能从( i-1 , j )或者（ i , j-1 ）两个位置移动过来。不关心其他位置的状态。

符合「 **最优子结构** 」

> min_dist( i , j ) = w\[ i ]\[ j ] + min( min_dist( i-1 , j ) , min_dist( i , j-1 ) )
>
> 这就是最优子结构的通解。

一般有两种解题思路，分别是**状态转移表法**和**状态转移方程法**。

#### 状态转移表法

> 画一个状态转移表。跟上面用到的二维备忘录一样，可以想象成一个二维数组。
>
> 其中每个状态min_dist包含三个标量，行、列、数值。根据决策的先后过程，根据递推关系，分阶段填充状态表的每个状态。最后将整个过程翻译成代码。就是动态规划的代码了。
>
> **尽管大多数状态表都是二维的，但是如果问题的状态比较复杂，需要很多变量标识，那对应的状态表可能是高维度的，这时就不适合使用状态转移表法了。因为图不好画，且，人脑不擅长思考高维度的东西。**
>
> - 先填充第0行和第0列。
> - 再对其他节点进行填充。

<img src="https://gitee.com/wangigor/typora-images/raw/master/image-20210502211402929.jpeg" alt="image-20210502211402929" style="zoom:50%;" />

翻译成代码如下。

```java
@Test
public void testMinDistDP() {
    int[][] matrix = {
            {1, 3, 5, 9},
            {2, 1, 3, 4},
            {5, 2, 6, 7},
            {6, 8, 4, 3}
    };
    System.out.println(minDistDP(matrix, 4));
}

/**
 * 转移表法
 *
 * @param matrix
 * @return
 */
public int minDistDP(int[][] matrix, int n) {

    //创建状态转移表
    int[][] states = new int[n][n];

    //初始化第一行
    int sum = 0;
    for (int i = 0; i < n; ++i) {
        sum += matrix[0][i];
        states[0][i] = sum;
    }

    //初始化第一列 从第二个开始就行
    sum = states[0][0];
    for (int i = 1; i < n; i++) {
        sum += matrix[i][0];
        states[i][0] = sum;
    }

    //递推初始化其他空节点
    for (int i = 1; i < n; ++i) {
        for (int j = 1; j < n; ++j) {
            states[i][j] = matrix[i][j] + Math.min(states[i - 1][j], states[i][j - 1]);
        }
    }


    return states[n - 1][n - 1];
}
```

#### 状态转移方程法

> 方程法需要分析出 「子问题的通解方程」。
>
> 也就是我们上面分析过的
>
> ```java
> min_dist( i , j ) = w[ i ][ j ] + min( min_dist( i-1 , j ) , min_dist( i , j-1 ) )
> ```
>
> 有两种代码实现方式：
>
> - 递归加备忘录
> - 迭代递推「跟状态转移表法代码一样」
>
> 下面是递归加备忘录的代码。

```java
@Test
public void testMinDist() {
    System.out.println(minDist(n - 1, n - 1));
}

private int[][] matrix = {
        {1, 3, 5, 9},
        {2, 1, 3, 4},
        {5, 2, 6, 7},
        {6, 8, 4, 3}
};
private int n = 4;

private int[][] mem = new int[n][n];

public int minDist(int i, int j) {
    if (i == 0 && j == 0) {//（0，0）节点
        return matrix[0][0];
    }
    if (mem[i][j] > 0) {
        return mem[i][j];
    }

    int minLeft = Integer.MAX_VALUE;
    if (j - 1 >= 0) {
        minLeft = minDist(i, j - 1);
    }

    int minUp = Integer.MAX_VALUE;
    if (i - 1 >= 0) {
        minUp = minDist(i - 1, j);
    }

    mem[i][j] = matrix[i][j] + Math.min(minLeft, minUp);

    return mem[i][j];
}
```

> ==**状态转移方程是解决动态规划问题的关键**==。
>
> **状态转移表法**的思路是：回溯实现 -> 定义状态 -> 画递归树 -> 找重复子问题 -> 画状态转移表 -> 根据地推关系填表 -> 将填表过程翻译成代码。
>
> **状态转移方程法**的思路是：找最优子结构 -> 写状态方程 -> 翻译成代码。

#### 硬币找零问题

> 假设 有无数多的1，3，5面值的硬币，要凑出9块钱，最少需要多少枚硬币。
>
> 状态转移方程
>
> ```java
> f(n) = 1 + min( f(n-1) , f(n-3) , f(n-5) )
> ```
>
> ```java
> @Test
> public void testLessCoin() {
>     System.out.println(lessCoin(9));
> }
> 
> private int lessCoin(int num) {
> 
>     if (num <= 0) {
>         return Integer.MAX_VALUE;
>     }
>     if (num == 1) {
>         return 1;
>     }
>     if (num == 2) {
>         return 2;
>     }
>     if (num == 3) {
>         return 1;
>     }
>     if (num == 4) {
>         return 2;
>     }
>     if (num == 5) {
>         return 1;
>     }
> 
>     int lessCoin1 = lessCoin(num - 1);
>     int lessCoin3 = lessCoin(num - 3);
>     int lessCoin5 = lessCoin(num - 5);
>     return 1 + (lessCoin1 > lessCoin3 ? Math.min(lessCoin3, lessCoin5) : Math.min(lessCoin1, lessCoin5));
> 
> }
> ```

### 搜索引擎的拼写纠错功能

> 如何量化两个字符串之间的相似程度，有一个非常著名的量化方法，那就是编辑距离。
>
> **编辑距离**指的是，将一个字符串转化为另一个字符串，需要的最少编辑操作次数「编辑一个字符、删除一个字符、替换一个字符」。编辑距离越大，说明两个字符串的相似程度越小；反之亦然。对于两个完全相同的字符串，编辑距离为0。
>
> 编辑距离有多重不同的计算方式，比较著名的是**莱文斯坦距离**和**最长公共子串长度**。
>
> - 莱温斯坦距离允许增加、删除、替换字符三个操作。
> - 最长公共子串长度只允许增加、删除两个操作。
> - 莱文斯坦距离表示差异大小。
> - 最长公共子串长度标识相似度大小。
>
> 举个例子「mitcmu」和「mtacnu」莱文斯坦距离是3，最长公共子串距离是4.
>
> <img src="https://gitee.com/wangigor/typora-images/raw/master/image-20210504173844508.png" alt="image-20210504173844508" style="zoom:50%;" />

#### 计算莱文斯坦距离

> 把一个字符串变成另一个字符串，需要依次对比一个字符串中的字符，跟另一个字符串中的字符是否匹配。
>
> - 匹配，继续对比下一对字符串。
>
> - 不匹配，可以进行增加、删除、替换操作。
>
> 那么就先使用**回溯算法**。每一个**阶段**进行a\[i\]和b\[j\]的对比：
>
> - 如果匹配，递归考察a\[i+1\]和b\[j+1\]。莱文斯坦距离不增加。
>
> - 如果不匹配：需要分开讨论，莱文斯坦距离都+1
>
>   - 增加操作：可以**在a\[i\]前添加b\[j\]递归对比a\[i]和b\[j+1]** 或者 **b\[j]前添加a[i]递归对比b\[j]和a\[i+1]**
>   - 删除操作：**删除a\[i]递归对比a\[i+1]和b\[j]** 或者 **删除b\[j]递归对比b\[j+1]和a\[i]**
>   - 替换操作：把a[i]直接替换成b\[j]，其实也就是**两个字符都忽略，递归对比a\[i+1]和b\[j+1]**
>
>   这三个操作可以合并为三个状态 ( i+1 , j , distance+1 ) ( i , j+1 , distance+1 ) ( i+1 , j+1 , distance+1 ) 

先写出回溯代码，如下

```java
@Test
public void testLevenshteinDistance00() {
    levenshteinDistance00(0, 0, 0);
    System.out.println(min_distance);
}

private char[] a = "mitcmu".toCharArray();
private char[] b = "mtacnu".toCharArray();
private int min_distance = Integer.MAX_VALUE;

public void levenshteinDistance00(int i, int j, int distance) {
    //一个字符串全部考察完成
    if (i == a.length || j == b.length) {
        //先处理没有对比的剩余长度
        if (i < a.length) distance += a.length - i;
        if (j < b.length) distance += b.length - j;
        //对比最小距离
        if (distance < min_distance) min_distance = distance;
        return;
    }
    if (a[i] == b[j])
        levenshteinDistance00(i + 1, j + 1, distance);
    else {
        //三条修改方案
        levenshteinDistance00(i + 1, j, distance + 1);
        levenshteinDistance00(i, j + 1, distance + 1);
        levenshteinDistance00(i + 1, j + 1, distance + 1);
    }
}
```

画出递归树，查看是否存在重复子问题。

> 没有重复子问题，回溯就是最好的解决方法。
>
> 如果有重复子问题，考虑使用动态规划。

<img src="https://gitee.com/wangigor/typora-images/raw/master/image-20210506212453307.jpeg" alt="image-20210506212453307" style="zoom:50%;" />

> 出现了重复子问题。
>
> 不过跟之前不同的是，（ i , j , min_dist ）不是从两个状态变化过来的。而是从（ i-1 , j ）（ i , j-1 ）（ i-1 , j-1 ）三个状态变化过来的。
>
> 那么写一下状态转移方程
>
> ```java
> 当a[i]!=b[j]时：
> 	min_dist(i,j) = min( min_dist(i-1,j)+1 , min_dist(i,j-1)+1 , min_dist(i-1,j-1)+1 ); 
> 当a[i]==b[j]时：
>   min_dist(i,j) = min( min_dist(i-1,j)+1 , min_dist(i,j-1)+1 , min_dist(i-1,j-1) ); 
> ```
>
> 按照状态方程一次填表
>
> <img src="https://gitee.com/wangigor/typora-images/raw/master/image-20210506215549153.jpeg" alt="image-20210506215549153" style="zoom:50%;" />
>
> 我这个图的行列画反了。
>
> 下面写的代码是用a作为行，b作为列。

状态转移表法代码如下。

```java
@Test
public void testLevenshteinDistance01() {
    char[] a = "mitcmu".toCharArray();
    char[] b = "mtacnu".toCharArray();
    int i = levenshteinDistance01(a, b);
    System.out.println(i);
}

public int levenshteinDistance01(char[] a, char[] b) {
    int[][] minDist = new int[a.length][b.length];

    //初始化第0行
    for (int j = 0; j < b.length; ++j) {
        if (a[0] == b[j]) {
            minDist[0][j] = j;
        } else {
            if (j == 0) {
                minDist[0][j] = 1;
            } else {
                minDist[0][j] = minDist[0][j - 1] + 1;
            }
        }
    }

    //初始化第0列
    for (int i = 0; i < a.length; ++i) {
        if (b[0] == a[i]) {
            minDist[i][0] = i;
        } else {
            if (i == 0) {
                minDist[i][0] = 1;
            } else {
                minDist[i][0] = minDist[i - 1][0] + 1;
            }
        }
    }
    //开始填表
    for (int i = 1; i < a.length; ++i) {
        for (int j = 1; j < b.length; ++j) {
            if (a[i] == b[j]) {
                minDist[i][j] = min(minDist[i - 1][j] + 1, minDist[i][j - 1] + 1, minDist[i - 1][j - 1]);
            } else {
                minDist[i][j] = min(minDist[i - 1][j] + 1, minDist[i][j - 1] + 1, minDist[i - 1][j - 1] + 1);
            }
        }
    }

    //返回最优一个minDist[a.length-1][b.length-1]
    return minDist[a.length - 1][b.length - 1];
}

private int min(int x, int y, int z) {
    return x > y ? Math.min(y, z) : Math.min(x, z);
}
```

状态转移方程法代码如下。

```java
@Test
public void testLevenshteinDistance010() {
    System.out.println(levenshteinDistance01(a.length - 1, b.length - 1));
}

/**
 * 状态转移方程法
 *
 * @param a_index
 * @param b_index
 * @return
 */
public int levenshteinDistance01(int a_index, int b_index) {
    if (a_index == 0) {
        if (a[0] == b[b_index]) {
            return b_index;
        } else {
            //向前遍历 有重复的
            boolean equals = false;
            for (int j = b_index - 1; j >= 0; --j) {
                if (a[0] == b[j]) {
                    equals = true;
                }
            }
            if (equals) return b_index;
            else return b_index + 1;
        }
    }
    if (b_index == 0) {
        if (a[a_index] == b[0]) {
            return a_index;
        } else {
            //向前遍历 有重复的
            boolean equals = false;
            for (int i = a_index - 1; i >= 0; --i) {
                if (a[i] == b[0]) {
                    equals = true;
                }
            }
            if (equals) return a_index;
            else return a_index + 1;
        }
    }

    if (a[a_index] == b[b_index]) {
        return min(levenshteinDistance01(a_index - 1, b_index) + 1, levenshteinDistance01(a_index, b_index - 1) + 1, levenshteinDistance01(a_index - 1, b_index - 1));
    } else {
        return min(levenshteinDistance01(a_index - 1, b_index) + 1, levenshteinDistance01(a_index, b_index - 1) + 1, levenshteinDistance01(a_index - 1, b_index - 1) + 1);
    }
}
```

#### 计算最长公共子串长度

