# 结构型-桥接模式

> 桥接模式，也叫做桥梁模式「**Bridge Design Pattern**」。
>
> GoF的「设计模式」一书中对桥接模式的定义是：Decouple an abstraction from its implementation so that the two can vary independently.**将抽象和实现解耦，可以让他们独立变化**。

很多资料中，JDBC驱动一致被认为是桥接模式的经典应用。那就先来看一下jdbc驱动对不同数据源支持的。

简单demo

```java
Class.forName("com.mysql.jdbc.Driver");//加载及注册JDBC驱动程序
String url = "jdbc:mysql://localhost:3306/sample_db?user=root&password=your_password";
Connection con = DriverManager.getConnection(url);
Statement stmt = con.createStatement()；
String query = "select * from test";
ResultSet rs=stmt.executeQuery(query);
while(rs.next()) {
  rs.getString(1);
  rs.getInt(2);
}
```

如果想要把`MySQL`数据库换成`Oracle`数据库，只需要

- 修改`com.mysql.jdbc.Driver`成`oracle.jdbc.driver.OracleDriver`
- 数据库url换成oracle数据库的相关连接

即可。而这些都是可以放在`spring`的`properties`中进行配置的。

这样，**在切换数据库的时候，不需要修改代码，只需要修改配置文件，就可以了。**这就是把抽象和实现解耦。

先来看看`com.mysql.jdbc.Driver`源码。

```java
public class Driver extends NonRegisteringDriver implements java.sql.Driver {
    //
    // Register ourselves with the DriverManager
    //
    static {
        try {
            java.sql.DriverManager.registerDriver(new Driver());
        } catch (SQLException E) {
            throw new RuntimeException("Can't register driver!");
        }
    }

    /**
     * Construct a new driver and register it with DriverManager
     * 
     * @throws SQLException
     *             if a database error occurs.
     */
    public Driver() throws SQLException {
        // Required for Class.forName().newInstance()
    }
}
```

当执行到`Class.forName()`这一句的时候：

- jvm查找并加载执行`Driver`类。
- 执行类的静态代码块，创建`Driver`实例注册到`DriverManager`中。

再来看看`DriverManager`类是干什么的。

```java
   public class DriverManager {
   
   
       // List of registered JDBC drivers
       private final static CopyOnWriteArrayList<DriverInfo> registeredDrivers = new CopyOnWriteArrayList<>();
       
  
       /**
        * Load the initial JDBC drivers by checking the System property
        * jdbc.properties and then use the {@code ServiceLoader} mechanism
        */
       static {
           loadInitialDrivers();
           println("JDBC DriverManager initialized");
       }
 
       @CallerSensitive
       public static Connection getConnection(String url)
           throws SQLException {
   
           java.util.Properties info = new java.util.Properties();
           //通过不同调用者class获取connection
           return (getConnection(url, info, Reflection.getCallerClass()));
       }
   
   		 //注册driver
       public static synchronized void registerDriver(java.sql.Driver driver,
               DriverAction da) throws SQLException {
           if(driver != null) {
               registeredDrivers.addIfAbsent(new DriverInfo(driver, da));
           } else {
               throw new NullPointerException();
           }
       }
   
   
       //  Worker method called by the public getConnection() methods.
       private static Connection getConnection(
           String url, java.util.Properties info, Class<?> caller) throws SQLException {
           //忽略实现...
       }
   }
```

这就是桥接模式的定义所说的将实现和抽象解耦，让他们独立变化。

- 这里的抽象不是指「抽象类」，而是不同类型的具体实现。

![image-20220518132704535](https://gitee.com/wangigor/typora-images/raw/master/image-20220518132704535.jpeg)

在其他资料中，还有一种更加简单的理解方式：「**一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展。**」

