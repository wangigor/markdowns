# 面向对象

> [维基百科](https://zh.wikipedia.org/zh-cn/面向对象程序设计)
>
> 面向对象编程的英文缩写是OOP「Object Oriented Programming」。
>
> 面向对象编程语言的英文缩写是OOPL「Object Oriented Programming Language」。
>
> 实际软件开发过程中，基本都是使用面向对象编程语言进行的编程。

- **面向对象编程**是一种编程范式或编程风格。

  他以类或对象作为组织代码的基本单元，并将**封装、抽象、继承、多态**作为代码设计和实现的基石。

- **面向对象编程语言**是支持类或对象的语法机制。

  且有线程的语法机制，能**方便的实现面向对象四大特性的编程语言**。

> 如何判断一个编程语言是否是面向对象编程语言？
>
> 按照最简单的方式来理解，就是语言本身就支持将对象或类作为代码组织的基本单元。

## 封装、抽象、继承、多态

### 封装「信息隐藏或数据访问保护」

> 类通过暴露有限的访问接口，授权外部仅能通过类提供的方式来访问内部信息或者数据。

举个例子。虚拟钱包的设计实现。

```java

public class Wallet {
  private String id;
  private long createTime;
  private BigDecimal balance;
  private long balanceLastModifiedTime;
  // ...省略其他属性...

  public Wallet() {
     this.id = IdGenerator.getInstance().generate();
     this.createTime = System.currentTimeMillis();
     this.balance = BigDecimal.ZERO;
     this.balanceLastModifiedTime = System.currentTimeMillis();
  }

  // 注意：下面对get方法做了代码折叠，是为了减少代码所占文章的篇幅
  public String getId() { return this.id; }
  public long getCreateTime() { return this.createTime; }
  public BigDecimal getBalance() { return this.balance; }
  public long getBalanceLastModifiedTime() { return this.balanceLastModifiedTime;  }

  public void increaseBalance(BigDecimal increasedAmount) {
    if (increasedAmount.compareTo(BigDecimal.ZERO) < 0) {
      throw new InvalidAmountException("...");
    }
    this.balance.add(increasedAmount);
    this.balanceLastModifiedTime = System.currentTimeMillis();
  }

  public void decreaseBalance(BigDecimal decreasedAmount) {
    if (decreasedAmount.compareTo(BigDecimal.ZERO) < 0) {
      throw new InvalidAmountException("...");
    }
    if (decreasedAmount.compareTo(this.balance) > 0) {
      throw new InsufficientAmountException("...");
    }
    this.balance.subtract(decreasedAmount);
    this.balanceLastModifiedTime = System.currentTimeMillis();
  }
}
```

- `id`和`createTime`在创建钱包的时候就确定好了，之后不应该再被改动

  所以没有暴露`id`和`createTime`的`setter`方法。

- `id`和`createTime`的创建，定义在`Wallet`类的构造函数中，对调用者来说是透明的。

  且不能通过构造函数意外的的方式赋值。

- 对于余额`balance`这个属性，从业务角度来说，只能增/减，不会被重新赋值。

  所以在`Wallet`类中，只暴露了`increaseBalance()`和`decreaseBalance()`两个方法。

  没有对外暴露的其他修改操作。

- 对于`balanceLastModifiedTime`最后修改时间这样的属性，封装在了`increaseBalance()`和`decreaseBalance()`中，保证了跟`balance`的数据一致性。

封装特性，需要编程语言本身提供语法机制「**访问权限控制**」来支持。

比如private关键字修饰的属性只能类本身访问，保护其不被类之外的代码「随意/直接」修改。如果`id`设为public的，任意外部代码可以通过类似`wallet.id=123`这样的访问方式直接访问、修改属性。达不到信息隐藏和保护数据的目的，没用用好封装特性。

> - 我们把所有的操作和属性访问权限都开放给调用者。
>
>   调用者如果想要正确的操作这些属性，就势必要对业务细节有足够的了解。但这确实没有必要，反而是一种负担灵活确实灵活，但是灵活度不可控。
>
> - 暴露必要的方法给调用者使用，不需要调用者过分了解背后的业务细节，用错的概率反而减少很多。
>
>   就比如一个空调，只暴露开、停、调节温度。一眼就知道该如何操作，怎么会出错呢。

### 抽象「隐藏具体实现」

> 跟封装「隐藏信息、保护数据」不同，抽象是要隐藏方法的具体实现。调用者只需要关心类提供了哪些方法，并不需要直到功能室怎么实现的。

比如interface和abstract的抽象类都是**接口类**「区别API接口」。

```java

public interface IPictureStorage {
  void savePicture(Picture picture);
  Image getPicture(String pictureId);
  void deletePicture(String pictureId);
  void modifyMetaInfo(String pictureId, PictureMetaInfo metaInfo);
}

public class DefaultPictureStorage implements IPictureStorage {
  // ...省略其他属性...
  @Override
  public void savePicture(Picture picture) { ... }
  @Override
  public Image getPicture(String pictureId) { ... }
  @Override
  public void deletePicture(String pictureId) { ... }
  @Override
  public void modifyMetaInfo(String pictureId, PictureMetaInfo metaInfo) { ... }
}
```

其实。抽象是很容易实现的，并不需要依赖接口类或者特殊语法机制来完成。

换句话说，不一定要有interface区分出接口类，单纯DefaultPictureStorage本身也能满足抽象特性「别往里看就行哈哈哈哈哈哈哈」。这也就是为什么「他们说java只有封装、继承、多态三大特性。」

> 抽象和封装都是**人类处理复杂性的有效手段**。在面对复杂系统的时候，人脑能承受的信息复杂程度是有限的，所以我们需要忽略掉一些非关键性的实现细节。而抽象作为一种只关注功能点不关注实现的设计思路，正好帮我们的大脑过滤掉大部分非必要信息。

> 抽象是一种非常宽泛的设计思想。在代码设计中，起到非常重要的指导作用。

> 很多设计原则都体现了抽象这种设计思想，比如基于接口而非实现编程、开闭原则「对扩展开放、对修改关闭」、代码耦合「降低代码的耦合性」等。

在我们定义方法名的时候，也要有抽象思维。不要在方法定义中，暴露太多实现细节。

比如`getAliyunPictureUrl()`就不是一个具有抽象思维的命名。因为如果有一天我们不把图片存储在阿里云上时，这个命名也要虽只修改。相反，我们需要抽象一个`getPictureUrl()`，我们需要提供阿里云及其他的不同实现就好。这就是对扩展开放，对修改关闭。

### 继承「代码复用」

> 继承最大的好处就是代码复用。
>
> 加入两个类有一些相同的属性和方法，我们就可以把这些相同的部分，抽取到父类中，让两个子类继承父类。子类重用父类中相同的代码，也可以重写差异。

不过这不是继承所特有的，也可以通过其他方式解决代码复用问题，比如组合。

从上下层级来说：继承是一种is-a关系。

> 如果**过度使用**继承，继承层级过深而复杂，就**会导致代码可读性、可维护性差**。为了了解一个功能，不仅要查看这个类的代码，还要按照继承关系一层一层往上查看父类代码、父类的父类代码……。
>
> 子类和父类高度耦合，修改父类代码，会直接影响子类实现。

继承是一种非常有争议的特性。很多人认为继承是一种反模式，应该尽量少用，甚至不用。

> 在「继承还是组合」设计思想时总结。

### 多态「”动态“调用」

> 在编译中，子类可以替换为父类的声明。实际代码运行过程中，调用子类的方法实现。

举个例子。

```java

public class DynamicArray {
  private static final int DEFAULT_CAPACITY = 10;
  protected int size = 0;
  protected int capacity = DEFAULT_CAPACITY;
  protected Integer[] elements = new Integer[DEFAULT_CAPACITY];
  
  public int size() { return this.size; }
  public Integer get(int index) { return elements[index];}
  //...省略n多方法...
  
  public void add(Integer e) {
    ensureCapacity();
    elements[size++] = e;
  }
  
  protected void ensureCapacity() {
    //...如果数组满了就扩容...代码省略...
  }
}

public class SortedDynamicArray extends DynamicArray {
  @Override
  public void add(Integer e) {
    ensureCapacity();
    int i;
    for (i = size-1; i>=0; --i) { //保证数组中的数据有序
      if (elements[i] > e) {
        elements[i+1] = elements[i];
      } else {
        break;
      }
    }
    elements[i+1] = e;
    ++size;
  }
}

public class Example {
  public static void test(DynamicArray dynamicArray) {
    dynamicArray.add(5);
    dynamicArray.add(1);
    dynamicArray.add(3);
    for (int i = 0; i < dynamicArray.size(); ++i) {
      System.out.println(dynamicArray.get(i));
    }
  }
  
  public static void main(String args[]) {
    DynamicArray dynamicArray = new SortedDynamicArray();
    test(dynamicArray); // 打印结果：1、3、5
  }
}
```

- 编程语言要支持父类对象可以引用子类对象。

  也就是将`SortedDynamicArray`传递给`DynamicArray`。

- 编程语言要支持继承。

  `SortedDynamicArray`继承了`DynamicArray`，才能将`SortedDyamicArray`传递给`DynamicArray`。

- 编程语言支持子类重写父类中的方法。

  `SortedDyamicArray`重写了`DynamicArray`中的`add()`方法。

> 多态特性，除了上面说的「继承+方法重写」这种方式以外。还有两种比较常见的实现方式。
>
> - 利用接口实现
> - 利用`duck-typing`实现。

#### 接口实现

```java

public interface Iterator {
  boolean hasNext();
  String next();
  String remove();
}

public class Array implements Iterator {
  private String[] data;
  
  public boolean hasNext() { ... }
  public String next() { ... }
  public String remove() { ... }
  //...省略其他方法...
}

public class LinkedList implements Iterator {
  private LinkedListNode head;
  
  public boolean hasNext() { ... }
  public String next() { ... }
  public String remove() { ... }
  //...省略其他方法... 
}

public class Demo {
  private static void print(Iterator iterator) {
    while (iterator.hasNext()) {
      System.out.println(iterator.next());
    }
  }
  
  public static void main(String[] args) {
    Iterator arrayIterator = new Array();
    print(arrayIterator);
    
    Iterator linkedListIterator = new LinkedList();
    print(linkedListIterator);
  }
}
```

#### duck-typing实现

```python

class Logger:
    def record(self):
        print(“I write a log into file.”)
        
class DB:
    def record(self):
        print(“I insert data into db. ”)
        
def test(recorder):
    recorder.record()

def demo():
    logger = Logger()
    db = DB()
    test(logger)
    test(db)
```

Duck-typing实现多态的方式非常灵活。Logger和DB两个类没有任何关系，既不是继承也不是接口实现。

但他们都定义了`record()`方法可以传递到`test()`中执行。

> 多态提高了代码的可扩展性。

## 面向过程和面向对象

## 基于接口和基于实现

## 继承还是组合

