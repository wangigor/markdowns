# 面向对象

> [维基百科](https://zh.wikipedia.org/zh-cn/面向对象程序设计)
>
> 面向对象编程的英文缩写是OOP「Object Oriented Programming」。
>
> 面向对象编程语言的英文缩写是OOPL「Object Oriented Programming Language」。
>
> 实际软件开发过程中，基本都是使用面向对象编程语言进行的编程。

- **面向对象编程**是一种编程范式或编程风格。

  他以类或对象作为组织代码的基本单元，并将**封装、抽象、继承、多态**作为代码设计和实现的基石。

- **面向对象编程语言**是支持类或对象的语法机制。

  且有线程的语法机制，能**方便的实现面向对象四大特性的编程语言**。

> 如何判断一个编程语言是否是面向对象编程语言？
>
> 按照最简单的方式来理解，就是语言本身就支持将对象或类作为代码组织的基本单元。

## 封装、抽象、继承、多态

### 封装「信息隐藏或数据访问保护」

> 类通过暴露有限的访问接口，授权外部仅能通过类提供的方式来访问内部信息或者数据。

举个例子。虚拟钱包的设计实现。

```java

public class Wallet {
  private String id;
  private long createTime;
  private BigDecimal balance;
  private long balanceLastModifiedTime;
  // ...省略其他属性...

  public Wallet() {
     this.id = IdGenerator.getInstance().generate();
     this.createTime = System.currentTimeMillis();
     this.balance = BigDecimal.ZERO;
     this.balanceLastModifiedTime = System.currentTimeMillis();
  }

  // 注意：下面对get方法做了代码折叠，是为了减少代码所占文章的篇幅
  public String getId() { return this.id; }
  public long getCreateTime() { return this.createTime; }
  public BigDecimal getBalance() { return this.balance; }
  public long getBalanceLastModifiedTime() { return this.balanceLastModifiedTime;  }

  public void increaseBalance(BigDecimal increasedAmount) {
    if (increasedAmount.compareTo(BigDecimal.ZERO) < 0) {
      throw new InvalidAmountException("...");
    }
    this.balance.add(increasedAmount);
    this.balanceLastModifiedTime = System.currentTimeMillis();
  }

  public void decreaseBalance(BigDecimal decreasedAmount) {
    if (decreasedAmount.compareTo(BigDecimal.ZERO) < 0) {
      throw new InvalidAmountException("...");
    }
    if (decreasedAmount.compareTo(this.balance) > 0) {
      throw new InsufficientAmountException("...");
    }
    this.balance.subtract(decreasedAmount);
    this.balanceLastModifiedTime = System.currentTimeMillis();
  }
}
```

- `id`和`createTime`在创建钱包的时候就确定好了，之后不应该再被改动

  所以没有暴露`id`和`createTime`的`setter`方法。

- `id`和`createTime`的创建，定义在`Wallet`类的构造函数中，对调用者来说是透明的。

  且不能通过构造函数意外的的方式赋值。

- 对于余额`balance`这个属性，从业务角度来说，只能增/减，不会被重新赋值。

  所以在`Wallet`类中，只暴露了`increaseBalance()`和`decreaseBalance()`两个方法。

  没有对外暴露的其他修改操作。

- 对于`balanceLastModifiedTime`最后修改时间这样的属性，封装在了`increaseBalance()`和`decreaseBalance()`中，保证了跟`balance`的数据一致性。

封装特性，需要编程语言本身提供语法机制「**访问权限控制**」来支持。

比如private关键字修饰的属性只能类本身访问，保护其不被类之外的代码「随意/直接」修改。如果`id`设为public的，任意外部代码可以通过类似`wallet.id=123`这样的访问方式直接访问、修改属性。达不到信息隐藏和保护数据的目的，没用用好封装特性。

> - 我们把所有的操作和属性访问权限都开放给调用者。
>
>   调用者如果想要正确的操作这些属性，就势必要对业务细节有足够的了解。但这确实没有必要，反而是一种负担灵活确实灵活，但是灵活度不可控。
>
> - 暴露必要的方法给调用者使用，不需要调用者过分了解背后的业务细节，用错的概率反而减少很多。
>
>   就比如一个空调，只暴露开、停、调节温度。一眼就知道该如何操作，怎么会出错呢。

### 抽象「隐藏具体实现」

> 跟封装「隐藏信息、保护数据」不同，抽象是要隐藏方法的具体实现。调用者只需要关心类提供了哪些方法，并不需要直到功能室怎么实现的。

比如interface和abstract的抽象类都是**接口类**「区别API接口」。

```java

public interface IPictureStorage {
  void savePicture(Picture picture);
  Image getPicture(String pictureId);
  void deletePicture(String pictureId);
  void modifyMetaInfo(String pictureId, PictureMetaInfo metaInfo);
}

public class DefaultPictureStorage implements IPictureStorage {
  // ...省略其他属性...
  @Override
  public void savePicture(Picture picture) { ... }
  @Override
  public Image getPicture(String pictureId) { ... }
  @Override
  public void deletePicture(String pictureId) { ... }
  @Override
  public void modifyMetaInfo(String pictureId, PictureMetaInfo metaInfo) { ... }
}
```

其实。抽象是很容易实现的，并不需要依赖接口类或者特殊语法机制来完成。

换句话说，不一定要有interface区分出接口类，单纯DefaultPictureStorage本身也能满足抽象特性「别往里看就行哈哈哈哈哈哈哈」。这也就是为什么「他们说java只有封装、继承、多态三大特性。」

> 抽象和封装都是**人类处理复杂性的有效手段**。在面对复杂系统的时候，人脑能承受的信息复杂程度是有限的，所以我们需要忽略掉一些非关键性的实现细节。而抽象作为一种只关注功能点不关注实现的设计思路，正好帮我们的大脑过滤掉大部分非必要信息。

> 抽象是一种非常宽泛的设计思想。在代码设计中，起到非常重要的指导作用。

> 很多设计原则都体现了抽象这种设计思想，比如基于接口而非实现编程、开闭原则「对扩展开放、对修改关闭」、代码耦合「降低代码的耦合性」等。

在我们定义方法名的时候，也要有抽象思维。不要在方法定义中，暴露太多实现细节。

比如`getAliyunPictureUrl()`就不是一个具有抽象思维的命名。因为如果有一天我们不把图片存储在阿里云上时，这个命名也要虽只修改。相反，我们需要抽象一个`getPictureUrl()`，我们需要提供阿里云及其他的不同实现就好。这就是对扩展开放，对修改关闭。

### 继承「代码复用」

> 继承最大的好处就是代码复用。
>
> 加入两个类有一些相同的属性和方法，我们就可以把这些相同的部分，抽取到父类中，让两个子类继承父类。子类重用父类中相同的代码，也可以重写差异。

不过这不是继承所特有的，也可以通过其他方式解决代码复用问题，比如组合。

从上下层级来说：继承是一种is-a关系。

> 如果**过度使用**继承，继承层级过深而复杂，就**会导致代码可读性、可维护性差**。为了了解一个功能，不仅要查看这个类的代码，还要按照继承关系一层一层往上查看父类代码、父类的父类代码……。
>
> 子类和父类高度耦合，修改父类代码，会直接影响子类实现。

继承是一种非常有争议的特性。很多人认为继承是一种反模式，应该尽量少用，甚至不用。

> 在「继承还是组合」设计思想时总结。

### 多态「”动态“调用」

> 在编译中，子类可以替换为父类的声明。实际代码运行过程中，调用子类的方法实现。

举个例子。

```java

public class DynamicArray {
  private static final int DEFAULT_CAPACITY = 10;
  protected int size = 0;
  protected int capacity = DEFAULT_CAPACITY;
  protected Integer[] elements = new Integer[DEFAULT_CAPACITY];
  
  public int size() { return this.size; }
  public Integer get(int index) { return elements[index];}
  //...省略n多方法...
  
  public void add(Integer e) {
    ensureCapacity();
    elements[size++] = e;
  }
  
  protected void ensureCapacity() {
    //...如果数组满了就扩容...代码省略...
  }
}

public class SortedDynamicArray extends DynamicArray {
  @Override
  public void add(Integer e) {
    ensureCapacity();
    int i;
    for (i = size-1; i>=0; --i) { //保证数组中的数据有序
      if (elements[i] > e) {
        elements[i+1] = elements[i];
      } else {
        break;
      }
    }
    elements[i+1] = e;
    ++size;
  }
}

public class Example {
  public static void test(DynamicArray dynamicArray) {
    dynamicArray.add(5);
    dynamicArray.add(1);
    dynamicArray.add(3);
    for (int i = 0; i < dynamicArray.size(); ++i) {
      System.out.println(dynamicArray.get(i));
    }
  }
  
  public static void main(String args[]) {
    DynamicArray dynamicArray = new SortedDynamicArray();
    test(dynamicArray); // 打印结果：1、3、5
  }
}
```

- 编程语言要支持父类对象可以引用子类对象。

  也就是将`SortedDynamicArray`传递给`DynamicArray`。

- 编程语言要支持继承。

  `SortedDynamicArray`继承了`DynamicArray`，才能将`SortedDyamicArray`传递给`DynamicArray`。

- 编程语言支持子类重写父类中的方法。

  `SortedDyamicArray`重写了`DynamicArray`中的`add()`方法。

> 多态特性，除了上面说的「继承+方法重写」这种方式以外。还有两种比较常见的实现方式。
>
> - 利用接口实现
> - 利用`duck-typing`实现。

#### 接口实现

```java

public interface Iterator {
  boolean hasNext();
  String next();
  String remove();
}

public class Array implements Iterator {
  private String[] data;
  
  public boolean hasNext() { ... }
  public String next() { ... }
  public String remove() { ... }
  //...省略其他方法...
}

public class LinkedList implements Iterator {
  private LinkedListNode head;
  
  public boolean hasNext() { ... }
  public String next() { ... }
  public String remove() { ... }
  //...省略其他方法... 
}

public class Demo {
  private static void print(Iterator iterator) {
    while (iterator.hasNext()) {
      System.out.println(iterator.next());
    }
  }
  
  public static void main(String[] args) {
    Iterator arrayIterator = new Array();
    print(arrayIterator);
    
    Iterator linkedListIterator = new LinkedList();
    print(linkedListIterator);
  }
}
```

#### duck-typing实现

```python
class Logger:
    def record(self):
        print(“I write a log into file.”)
        
class DB:
    def record(self):
        print(“I insert data into db. ”)
        
def test(recorder):
    recorder.record()

def demo():
    logger = Logger()
    db = DB()
    test(logger)
    test(db)
```

Duck-typing实现多态的方式非常灵活。Logger和DB两个类没有任何关系，既不是继承也不是接口实现。

但他们都定义了`record()`方法可以传递到`test()`中执行。

> 多态提高了代码的可扩展性。

## 面向过程和面向对象

像`面向对象编程`和`面向对象编程语言`一样，`面向过程编程`和`面向过程编程语言`，也是成对出现的两个概念。

- 面向过程编程也是一种编程范式「编程风格」。

  以过程「方法、函数、操作」作为组织代码的基本单元。

  以数据「成员变量、属性」与方法分离为最主要特点。

  他是一种流程化的编程风格，通过拼接一组顺序执行的方法来操作数据，实现某种功能。

- 面向过程编程语言是编程语言。

  不支持类和对象两个语法概念。

  不支持丰富的面向对象编程特性「封装、继承、多态」。

面向过程的代码示例：

```c

struct User {
  char name[64];
  int age;
  char gender[16];
};

struct User parse_to_user(char* text) {
  // 将text(“小王&28&男”)解析成结构体struct User
}

char* format_to_text(struct User user) {
  // 将结构体struct User格式化成文本（"小王\t28\t男"）
}

void sort_users_by_age(struct User users[]) {
  // 按照年龄从小到大排序users
}

void format_user_file(char* origin_file_path, char* new_file_path) {
  // open files...
  struct User users[1024]; // 假设最大1024个用户
  int count = 0;
  while(1) { // read until the file is empty
    struct User user = parse_to_user(line);
    users[count++] = user;
  }
  
  sort_users_by_age(users);
  
  for (int i = 0; i < count; ++i) {
    char* formatted_user_text = format_to_text(users[i]);
    // write to new file...
  }
  // close files...
}

int main(char** args, int argv) {
  format_user_file("/user.txt", "/formatted_users.txt");
}
```

改为面向对象编程的示例

```java

 public class User {
  private String name;
  private int age;
  private String gender;
  
  public User(String name, int age, String gender) {
    this.name = name;
    this.age = age;
    this.gender = gender;
  }
  
  public static User praseFrom(String userInfoText) {
    // 将text(“小王&28&男”)解析成类User
  }
  
  public String formatToText() {
    // 将类User格式化成文本（"小王\t28\t男"）
  }
}

public class UserFileFormatter {
  public void format(String userFile, String formattedUserFile) {
    // Open files...
    List users = new ArrayList<>();
    while (1) { // read until file is empty 
      // read from file into userText...
      User user = User.parseFrom(userText);
      users.add(user);
    }
    // sort users by age...
    for (int i = 0; i < users.size(); ++i) {
      String formattedUserText = user.formatToText();
      // write to new file...
    }
    // close files...
  }
}

public class MainApplication {
  public static void main(String[] args) {
    UserFileFormatter userFileFormatter = new UserFileFormatter();
    userFileFormatter.format("/home/zheng/users.txt", "/home/zheng/formatted_users.txt");
  }
}
```

区别就是，代码的组织方式不同。

- 面向过程风格的代码呗组织成了一组方法组合及其数据结构。

  方法和数据结构是分开的。

- 面向对象风格的代码被组织成一组类，方法和数据结构是绑定在一起的「绑定在类中」。



>面向对象更能应对大规模复杂程序的开发。
>
>面向对象的代码更易复用、易扩展、已维护。
>
>从编程语言跟机器打交道的方式的演进规律中：面向对象比起面向过程，更人性化、更高级、更智能。

### 典型举例

#### 滥用getter、setter方法

> 经常有的人在定义完类的属性之后，就顺手把这些属性的getter、setter方法都定义上。
>
> 为了省事，还会使用IDE的代码自动生成。或者Lombok的编译期注解。
>
> 某些POJO可能确实需要，但绝大多数类并不需要这样的getter、setter方法。如果加上了，反而会退化成面向过程编程的代码。

```java
public class ShoppingCart {
  private int itemsCount;
  private double totalPrice;
  private List<ShoppingCartItem> items = new ArrayList<>();
  
  public int getItemsCount() {
    return this.itemsCount;
  }
  
  public void setItemsCount(int itemsCount) {
    this.itemsCount = itemsCount;
  }
  
  public double getTotalPrice() {
    return this.totalPrice;
  }
  
  public void setTotalPrice(double totalPrice) {
    this.totalPrice = totalPrice;
  }

  public List<ShoppingCartItem> getItems() {
    return this.items;
  }
  
  public void addItem(ShoppingCartItem item) {
    items.add(item);
    itemsCount++;
    totalPrice += item.getPrice();
  }
  // ...省略其他方法...
}
```

`ShoppingCart`是一个简化后的购物车类，有三个私有「`private`」属性：`itemsCount`、`totalPrice`、`items`。三个属性，都分别定义了getter、setter方法。

- 对于`itemsCount`和`totalPrice`两个属性增加getter、setter方法，就相当于变成了public公有属性。

  外部可以随意修改两个属性的值。如果发生修改，就可能会导致对于`ShoppingCart`的数据不一致。

- 对于`items`属性，定义了`getter`和`addItem`方法，且内部修改了`itemsCount`和`totalPrice`两个属性。看起来没啥问题，但其实不是。

  外部代码依然可以在获取到`items`进行任意修改。比如这样：

  ```java
  ShoppingCart cart = new ShoppCart();
  ...
  cart.getItems().clear(); // 清空购物车
  ```

  同样会导致`itemsCount`、`totalPrice`、`items`三者数据不一致。

  应该在`ShoppingCart`中提供可以给调用者使用的`clear()`方法:

  ```java
  public class ShoppingCart {
    // ...省略其他代码...
    public void clear() {
      items.clear();
      itemsCount = 0;
      totalPrice = 0.0;
    }
  }
  ```

  那getter方法的问题怎么解决呢？

  可以使用jdk提供的`Collections.unmodifiableList()`方法，使getter的返回值编程一个不可修改的集合容器，如果遇到修改就会抛出`UnsupportedOperationException`异常。

  ```java
  
  public class ShoppingCart {
    // ...省略其他代码...
    public List<ShoppingCartItem> getItems() {
      return Collections.unmodifiableList(this.items);
    }
  }
  
  public class UnmodifiableList<E> extends UnmodifiableCollection<E>
                            implements List<E> {
    public boolean add(E e) {
      throw new UnsupportedOperationException();
    }
    public void clear() {
      throw new UnsupportedOperationException();
    }
    // ...省略其他代码...
  }
  
  ShoppingCart cart = new ShoppingCart();
  List<ShoppingCartItem> items = cart.getItems();
  items.clear();//抛出UnsupportedOperationException异常
  ```

#### 滥用全局变量和全局方法

> 常见的全局变量有「单例类对象」、「静态成员变量」、「常量」等。
>
> 常见的全局方法有「静态方法」。

##### 大而全的Constants

```java

public class Constants {
  public static final String MYSQL_ADDR_KEY = "mysql_addr";
  public static final String MYSQL_DB_NAME_KEY = "db_name";
  public static final String MYSQL_USERNAME_KEY = "mysql_username";
  public static final String MYSQL_PASSWORD_KEY = "mysql_password";
  
  public static final String REDIS_DEFAULT_ADDR = "192.168.7.2:7234";
  public static final int REDIS_DEFAULT_MAX_TOTAL = 50;
  public static final int REDIS_DEFAULT_MAX_IDLE = 50;
  public static final int REDIS_DEFAULT_MIN_IDLE = 20;
  public static final String REDIS_DEFAULT_KEY_PREFIX = "rt:";
  
  // ...省略更多的常量定义...
}
```

- 影响代码的可维护性。

  太集中。大家都在修改这些常量，类会变得越来越大，提交代码的冲突概率增加。

- 编译时间增加。

  `Constants`每次修改都会导致依赖他的类文件重新编译，浪费很多不必要的编译时间。

  这个编译时间，可不是一个可忽略的时间。编译项目、每次运行单元测试，都会触发一次编译。

  它是会影响开发和发布效率的。

- 影响代码的复用性。

  如果要在另一个项目中，复用本项目开发的某个类，而这个类又依赖`Constants`类。

  即便这个类只依赖`Constants`类中的一小部分常量，仍然需要把整个`Constants`类一并引入。

> 有两种思路可以借鉴。
>
> - 把一个`Constants`类拆分为功能更加单一的多个类。
>
>   比如MySQL的相关常量都放在`MysqlConstants`类中；Redis的相关常量都放在`RedisConstants`中。
>
> - 不单独设置`Constants`常量类。
>
>   哪个类用到了某个常量，就把这个常量定义在这个类中。
>
>   比如`RedisConfig`类用到了Redis配置相关的常量，就把这个常量直接定义在`RedisConfig`中。
>
>   这样也提高了类设计的内聚性和代码的复用性。

##### Utils类

> Utils类出现的背景是：
>
> - 有两个类A、B，他们都会用到一块相同的功能逻辑，需要避免代码重复
> - A和B不一定具有继承关系，硬生生的抽象出来一个父类，会影响代码的可读性。
> - 分割出来的方法，不需要共享任何数据「共享可以使用组合，而不是Utils静态方法」。所以新的类不需要定义任何属性。
>
> 这个时候，我们就可以把它定义为只包含静态方法的Utils类了。

只包含静态方法不包含任何属性的`Utils`类，是彻彻底底的面向过程编程风格。

但是不能因此杜绝使用`Utils`类这种模式。`Utils`类的存在在软件开发中还是挺有用的，能解决代码复用的问题。而是要**尽量避免滥用**，不嫩不加思考的随意定义`Utils`类。

跟`Constants`类的设计一样，Utils类设计的时候也需要细化。

针对不同的功能设计不同的Utils类，比如`FileUtils`、`StringUtils`等等，**不要设计一个大而全的Utils类**。

#### 定义数据和方法分离的类

> 传统的MVC结构分为`Model`、`Controller`、`View`三层。在做了前后端分离之后三层结构变成了`Controller`、`Service`、`Repository`三层。
>
> `Controller`层负责暴露接口供前端调用。`Service`层负责核心业务逻辑。`Repository`层负责数据持久化。

每一层中，会定义对应的`VO`、`BO「DTO」`、`Entity`。一般情况下只会定义数据，不会定义方法。

所有操作这些数据的业务逻辑都定义在对应层的其他类中。这就是典型的面向过程编程风格。

这是现在常见的WEB项目开发模式，是基于**贫血模型**的开发模式。

***

> 不得不承认，在我们进行面向过程编码的过程中，很容易且不由自主的写出面向过程风格的代码。
>
> 因为在日常生活中，要去完成一个任务的时候，一般会先去思考「应该先做什么、后做什么，如何一步一步的顺序执行一系列操作」，最后完成整个任务。
>
> **面向过程编程风格恰恰符合人的这种流程化思维模式。**
>
> 而面向对象编程正好相反，他是**自底向上**的思考模式。
>
> 它不是先去按照执行流程分接任务，而是将任务翻译成一个一个小的模块「类」,设计类之间的交互，最后按照流程将类组装起来，完成整个任务。
>
> 面向对象更难一些，需要考虑数据和方法的组合，如何设计类的关系，如何设计类的交互等等诸多设计问题。
>
> 基于这两点，日常代码可能也就不由自主的变成面向过程编程风格了。

且。**面向过程一定不会被彻底摒弃**。

面向对象编程离不开面向过程变成的基础，因为，类中方法的实现逻辑就是面向过程风格的代码。

如果不是，那他下一个level也是、使用到的标准开发库是、字节码执行的汇编语言也是。你根本跑不了。

**我们最后的目的还是要写出易维护、易读、易复用、易扩展的高质量代码。**

## 接口和抽象类

接口和抽象类不同。

- 接口是一种has-a关系，表示了这个类有这个接口的功能。就像一个打在类上的功能tag。
- 抽象类是is-a关系，肯定是有继承实现的父类。

### 抽象类

```java
// 抽象类
public abstract class Logger {
  private String name;
  private boolean enabled;
  private Level minPermittedLevel;

  public Logger(String name, boolean enabled, Level minPermittedLevel) {
    this.name = name;
    this.enabled = enabled;
    this.minPermittedLevel = minPermittedLevel;
  }
  
  public void log(Level level, String message) {
    boolean loggable = enabled && (minPermittedLevel.intValue() <= level.intValue());
    if (!loggable) return;
    doLog(level, message);
  }
  
  protected abstract void doLog(Level level, String message);
}
// 抽象类的子类：输出日志到文件
public class FileLogger extends Logger {
  private Writer fileWriter;

  public FileLogger(String name, boolean enabled,
    Level minPermittedLevel, String filepath) {
    super(name, enabled, minPermittedLevel);
    this.fileWriter = new FileWriter(filepath); 
  }
  
  @Override
  public void doLog(Level level, String mesage) {
    // 格式化level和message,输出到日志文件
    fileWriter.write(...);
  }
}
// 抽象类的子类: 输出日志到消息中间件(比如kafka)
public class MessageQueueLogger extends Logger {
  private MessageQueueClient msgQueueClient;
  
  public MessageQueueLogger(String name, boolean enabled,
    Level minPermittedLevel, MessageQueueClient msgQueueClient) {
    super(name, enabled, minPermittedLevel);
    this.msgQueueClient = msgQueueClient;
  }
  
  @Override
  protected void doLog(Level level, String mesage) {
    // 格式化level和message,输出到消息中间件
    msgQueueClient.send(...);
  }
}
```

`Logger`是一个记录日志的抽象类，`FileLogger`和`MessageQueueLogger`继承`Logger`分别实现两种不同的日志记录方式：记录在文件中或发送到消息队列中。两个子类复用了父类`Logger`中的`name`、`enabled`、`minPermittedLevel`属性和`log()`方法，但因为两个子类日志记录方式不同，他们又各自重写了父类的抽象方法`doLog()`。

- 抽象类不允许被实例化，只能被继承。也就是不能直接`new Logger()`。
- 抽象类可以包含属性和方法。也可以有不包含代码的需要由子类实现的抽象方法。
- 子类继承抽象类，必须重写抽象类中的所有抽象方法。

### 接口

```java
// 接口
public interface Filter {
  void doFilter(RpcRequest req) throws RpcException;
}
// 接口实现类：鉴权过滤器
public class AuthencationFilter implements Filter {
  @Override
  public void doFilter(RpcRequest req) throws RpcException {
    //...鉴权逻辑..
  }
}
// 接口实现类：限流过滤器
public class RateLimitFilter implements Filter {
  @Override
  public void doFilter(RpcRequest req) throws RpcException {
    //...限流逻辑...
  }
}
// 过滤器使用Demo
public class Application {
  // filters.add(new AuthencationFilter());
  // filters.add(new RateLimitFilter());
  private List<Filter> filters = new ArrayList<>();
  
  public void handleRpcRequest(RpcRequest req) {
    try {
      for (Filter filter : filters) {
        filter.doFilter(req);
      }
    } catch(RpcException e) {
      // ...处理过滤结果...
    }
    // ...省略其他处理逻辑...
  }
}
```

定义了一个`Filter`接口。`AuthencationFilter`和`RateLimitFilter`是接口的两个实现类。`Application`实现了对RPC请求的鉴权和限流的过滤。

- 接口不能声明属性。
- 接口只能声明方法，方法不能包含代码实现。
- 类实现接口的时候，必须实现接口中声明的所有方法。

### 抽象类和接口能解决什么问题

#### 抽象类

> 抽象类实际使用的是继承解决了代码复用的问题。但是继承并不要求父类一定是抽象类。那抽象类还有什么用呢？

我们把`Logger`改为普通父类，删除`log()`、`doLog()`方法，新增`isLoggable()`方法。

```java
// 父类：非抽象类，就是普通的类. 删除了log(),doLog()，新增了isLoggable().
public class Logger {
  private String name;
  private boolean enabled;
  private Level minPermittedLevel;

  public Logger(String name, boolean enabled, Level minPermittedLevel) {
    //...构造函数不变，代码省略...
  }

  protected boolean isLoggable() {
    boolean loggable = enabled && (minPermittedLevel.intValue() <= level.intValue());
    return loggable;
  }
}
// 子类：输出日志到文件
public class FileLogger extends Logger {
  private Writer fileWriter;

  public FileLogger(String name, boolean enabled,
    Level minPermittedLevel, String filepath) {
    //...构造函数不变，代码省略...
  }
  
  public void log(Level level, String mesage) {
    if (!isLoggable()) return;
    // 格式化level和message,输出到日志文件
    fileWriter.write(...);
  }
}
// 子类: 输出日志到消息中间件(比如kafka)
public class MessageQueueLogger extends Logger {
  private MessageQueueClient msgQueueClient;
  
  public MessageQueueLogger(String name, boolean enabled,
    Level minPermittedLevel, MessageQueueClient msgQueueClient) {
    //...构造函数不变，代码省略...
  }
  
  public void log(Level level, String mesage) {
    if (!isLoggable()) return;
    // 格式化level和message,输出到消息中间件
    msgQueueClient.send(...);
  }
}
```

这样做可以达到代码复用，但是无法使用多台特性。

```java
//这样的写法就会报错，因为Logger中没有定义log()方法
Logger logger = new FileLogger("access-log", true, Level.WARN, "/tmp/access.log");
logger.log(Level.ERROR, "This is a test log message.");
```

那在父类`Logger`中定义一个空的`log()`方法，不就行了吗？

```java
public class Logger {
  // ...省略部分代码...
  public void log(Level level, String mesage) { // do nothing... }
}
public class FileLogger extends Logger {
  // ...省略部分代码...
  @Override
  public void log(Level level, String mesage) {
    if (!isLoggable()) return;
    // 格式化level和message,输出到日志文件
    fileWriter.write(...);
  }
}
public class MessageQueueLogger extends Logger {
  // ...省略部分代码...
  @Override
  public void log(Level level, String mesage) {
    if (!isLoggable()) return;
    // 格式化level和message,输出到消息中间件
    msgQueueClient.send(...);
  }
}
```

**不优雅。**

- `Logger`中的空方法影响代码的可读性。得看到子类对`log()`方法重写之后，才能明白设计意图。
- 如果新创建子类不重写`log()`方法，就会导致日志无法记录。
- `Logger`可以被实例化。但是无法记录日志。

#### 接口 

> 抽象类更多是为了代码复用，而接口侧重于解耦。
>
> 请看「基于接口和基于实现」部分。

## 基于接口和基于实现

> 「基于接口而非实现」这条原则的英文描述是『Program to an interface,not an implementation.』
>
> 原则本身跟任何一种编程语言都没有关系，它是一条比较抽象、泛化的设计思想。
>
> 理解这条原则的关键，就是理解『接口』两个字。本质上，**接口就是一组协议或约定，是功能提供者提供给使用者的功能列表。**比如服务端与客户端之间的接口，类库提供的接口，甚至一组通信的协议都可以叫做接口。
>
> 如果落实在具体的编码上，接口就是编程语言中的接口或者抽象类。

应用「基于接口而非实现」这条原则，可以**将接口和实现相分离，封装不稳定的实现，暴露稳定的接口**。

上游系统面向接口而非实现编程，不依赖不稳定的实现细节。当实现发生变化的时候，上游系统的代码基本上不需要改动，耦合度降低了，扩展性提升了。

软件开发中，最大的挑战之一就是需求的不断变化，这也是考验代码设计好坏的一个标准。**越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。**好的代码设计，不仅能应对当下的需求，而且在将来需求发生变化的时候，仍然能够在不破坏原有代码设计的情况下灵活应对。抽象就是提高代码扩展性、灵活性、可维护性最有效的手段之一。

> 假设系统中有很多涉及图片处理和存储的业务逻辑，图片经过处理之后上传阿里云。
>
> 为了代码复用，封装了一个图片存储相关的组件，提供了统一的AliyunImageStore类。

```java
public class AliyunImageStore {
  //...省略属性、构造函数等...
  
  public void createBucketIfNotExisting(String bucketName) {
    // ...创建bucket代码逻辑...
    // ...失败会抛出异常..
  }
  
  public String generateAccessToken() {
    // ...根据accesskey/secrectkey等生成access token
  }
  
  public String uploadToAliyun(Image image, String bucketName, String accessToken) {
    //...上传图片到阿里云...
    //...返回图片存储在阿里云上的地址(url）...
  }
  
  public Image downloadFromAliyun(String url, String accessToken) {
    //...从阿里云下载图片...
  }
}

// AliyunImageStore类的使用举例
public class ImageProcessingJob {
  private static final String BUCKET_NAME = "ai_images_bucket";
  //...省略其他无关代码...
  
  public void process() {
    Image image = ...; //处理图片，并封装为Image对象
    AliyunImageStore imageStore = new AliyunImageStore(/*省略参数*/);
    imageStore.createBucketIfNotExisting(BUCKET_NAME);
    String accessToken = imageStore.generateAccessToken();
    imagestore.uploadToAliyun(image, BUCKET_NAME, accessToken);
  }
  
}
```

整个上传流程包含三个步骤：创建bucket「目录」、生成assess token、携带access token上传图片到指定bucket中。乍一看问题不大。

**软件开发中唯一不变的就是变化**。过了一段时间，自建了私有云不再将图片存储在阿里云上了。为了满足这个需求的变化，就需要修改代码。

> 需要设计一个存储图片到私有云的`PrivateImageStore`类，并用它替换掉所有`AliyunImageStore`类对象。简单一想不复杂，只是简单替换而已对整体代码改动不大。不过隐藏了很多容易出问题的「魔鬼细节」。

新的`PrivateImageStore`类需要实现哪些方法，才能在尽量最小化代码修改的情况下，替换掉`AliyunImageStore`类呢？这就要求我们必须将`AliyunImageStore`类中所定义的所有public方法，在`PrivateImageStore`类中逐一定义并重新实现一遍。

- 有些函数命名暴露了实现细节。

  比如`updateToAliyun()`和`downloadFromAliyun()`，照搬到`PrivateImageStore`中显然不合适。

- 流程不同。

  阿里云的图片上传和下载，需要生产`access token`。而私有云不需要。所以`generateAccessToken()`不能照搬，但是客户代码中用到了这个方法，就需要对客户代码也做修改。

为了避免这样的问题，从`AliyunImageStore`设计的时候，就需要遵从「基于接口而非实现编程」的原则。

- 函数命名不能暴露任何实现细节。

  `updateToAliyun()`不符合要求，要改为抽象的命名方式`update()`

- 封装具体的实现细节。

  流程上的不同不能暴露给客户代码，比如`generateAccessToken()`不应该交给客户代码调用。

- 客户代码「使用者」依赖接口编程，而不是具体的实现类。

重构如下。

```java
public interface ImageStore {
  String upload(Image image, String bucketName);
  Image download(String url);
}

public class AliyunImageStore implements ImageStore {
  //...省略属性、构造函数等...

  public String upload(Image image, String bucketName) {
    createBucketIfNotExisting(bucketName);
    String accessToken = generateAccessToken();
    //...上传图片到阿里云...
    //...返回图片在阿里云上的地址(url)...
  }

  public Image download(String url) {
    String accessToken = generateAccessToken();
    //...从阿里云下载图片...
  }

  private void createBucketIfNotExisting(String bucketName) {
    // ...创建bucket...
    // ...失败会抛出异常..
  }

  private String generateAccessToken() {
    // ...根据accesskey/secrectkey等生成access token
  }
}

// 上传下载流程改变：私有云不需要支持access token
public class PrivateImageStore implements ImageStore  {
  public String upload(Image image, String bucketName) {
    createBucketIfNotExisting(bucketName);
    //...上传图片到私有云...
    //...返回图片的url...
  }

  public Image download(String url) {
    //...从私有云下载图片...
  }

  private void createBucketIfNotExisting(String bucketName) {
    // ...创建bucket...
    // ...失败会抛出异常..
  }
}

// ImageStore的使用举例
public class ImageProcessingJob {
  private static final String BUCKET_NAME = "ai_images_bucket";
  //...省略其他无关代码...
  
  public void process() {
    Image image = ...;//处理图片，并封装为Image对象
    ImageStore imageStore = new PrivateImageStore(...);
    imagestore.upload(image, BUCKET_NAME);
  }
}
```

***

但。也**不应该为任何一个类都定义接口**。

做任何事情都要讲求一个「度」。多度使用这条原则，接口满天飞，也会导致不必要的开发负担。至于哪些需要定接口；哪些不需要，还是要回归到设计原则诞生的初衷『将接口与实现分离，封装不稳定的实现，暴露稳定的接口。如果发生修改，上游代码基本不需要改动，以此降低代码见的耦合性，提高代码的扩展性』上来。

如果业务场景中，某个功能只有一种实现，未来也不可能被其他方式替换，就没必要设计接口。直接使用实现类就可以了。

越不稳定的系统，我们越要在代码的扩展性、维护性上下功夫。如果一个系统特别稳定，开发完之后，基本不需要维护，那么也就没有必要为其扩展性投入不必要的开发时间。

## 继承还是组合

