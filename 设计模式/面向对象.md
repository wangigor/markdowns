# 面向对象

> [维基百科](https://zh.wikipedia.org/zh-cn/面向对象程序设计)
>
> 面向对象编程的英文缩写是OOP「Object Oriented Programming」。
>
> 面向对象编程语言的英文缩写是OOPL「Object Oriented Programming Language」。
>
> 实际软件开发过程中，基本都是使用面向对象编程语言进行的编程。

- **面向对象编程**是一种编程范式或编程风格。

  他以类或对象作为组织代码的基本单元，并将**封装、抽象、继承、多态**作为代码设计和实现的基石。

- **面向对象编程语言**是支持类或对象的语法机制。

  且有线程的语法机制，能**方便的实现面向对象四大特性的编程语言**。

> 如何判断一个编程语言是否是面向对象编程语言？
>
> 按照最简单的方式来理解，就是语言本身就支持将对象或类作为代码组织的基本单元。

## 封装、抽象、继承、多态

### 封装「信息隐藏或数据访问保护」

> 类通过暴露有限的访问接口，授权外部仅能通过类提供的方式来访问内部信息或者数据。

举个例子。虚拟钱包的设计实现。

```java

public class Wallet {
  private String id;
  private long createTime;
  private BigDecimal balance;
  private long balanceLastModifiedTime;
  // ...省略其他属性...

  public Wallet() {
     this.id = IdGenerator.getInstance().generate();
     this.createTime = System.currentTimeMillis();
     this.balance = BigDecimal.ZERO;
     this.balanceLastModifiedTime = System.currentTimeMillis();
  }

  // 注意：下面对get方法做了代码折叠，是为了减少代码所占文章的篇幅
  public String getId() { return this.id; }
  public long getCreateTime() { return this.createTime; }
  public BigDecimal getBalance() { return this.balance; }
  public long getBalanceLastModifiedTime() { return this.balanceLastModifiedTime;  }

  public void increaseBalance(BigDecimal increasedAmount) {
    if (increasedAmount.compareTo(BigDecimal.ZERO) < 0) {
      throw new InvalidAmountException("...");
    }
    this.balance.add(increasedAmount);
    this.balanceLastModifiedTime = System.currentTimeMillis();
  }

  public void decreaseBalance(BigDecimal decreasedAmount) {
    if (decreasedAmount.compareTo(BigDecimal.ZERO) < 0) {
      throw new InvalidAmountException("...");
    }
    if (decreasedAmount.compareTo(this.balance) > 0) {
      throw new InsufficientAmountException("...");
    }
    this.balance.subtract(decreasedAmount);
    this.balanceLastModifiedTime = System.currentTimeMillis();
  }
}
```

- `id`和`createTime`在创建钱包的时候就确定好了，之后不应该再被改动

  所以没有暴露`id`和`createTime`的`setter`方法。

- `id`和`createTime`的创建，定义在`Wallet`类的构造函数中，对调用者来说是透明的。

  且不能通过构造函数意外的的方式赋值。

- 对于余额`balance`这个属性，从业务角度来说，只能增/减，不会被重新赋值。

  所以在`Wallet`类中，只暴露了`increaseBalance()`和`decreaseBalance()`两个方法。

  没有对外暴露的其他修改操作。

- 对于`balanceLastModifiedTime`最后修改时间这样的属性，封装在了`increaseBalance()`和`decreaseBalance()`中，保证了跟`balance`的数据一致性。

封装特性，需要编程语言本身提供语法机制「**访问权限控制**」来支持。

比如private关键字修饰的属性只能类本身访问，保护其不被类之外的代码「随意/直接」修改。如果`id`设为public的，任意外部代码可以通过类似`wallet.id=123`这样的访问方式直接访问、修改属性。达不到信息隐藏和保护数据的目的，没用用好封装特性。

> - 我们把所有的操作和属性访问权限都开放给调用者。
>
>   调用者如果想要正确的操作这些属性，就势必要对业务细节有足够的了解。但这确实没有必要，反而是一种负担灵活确实灵活，但是灵活度不可控。
>
> - 暴露必要的方法给调用者使用，不需要调用者过分了解背后的业务细节，用错的概率反而减少很多。
>
>   就比如一个空调，只暴露开、停、调节温度。一眼就知道该如何操作，怎么会出错呢。

### 抽象「隐藏具体实现」

> 跟封装「隐藏信息、保护数据」不同，抽象是要隐藏方法的具体实现。调用者只需要关心类提供了哪些方法，并不需要直到功能室怎么实现的。

比如interface和abstract的抽象类都是**接口类**「区别API接口」。

```java

public interface IPictureStorage {
  void savePicture(Picture picture);
  Image getPicture(String pictureId);
  void deletePicture(String pictureId);
  void modifyMetaInfo(String pictureId, PictureMetaInfo metaInfo);
}

public class DefaultPictureStorage implements IPictureStorage {
  // ...省略其他属性...
  @Override
  public void savePicture(Picture picture) { ... }
  @Override
  public Image getPicture(String pictureId) { ... }
  @Override
  public void deletePicture(String pictureId) { ... }
  @Override
  public void modifyMetaInfo(String pictureId, PictureMetaInfo metaInfo) { ... }
}
```

其实。抽象是很容易实现的，并不需要依赖接口类或者特殊语法机制来完成。

换句话说，不一定要有interface区分出接口类，单纯DefaultPictureStorage本身也能满足抽象特性「别往里看就行哈哈哈哈哈哈哈」。这也就是为什么「他们说java只有封装、继承、多态三大特性。」

> 抽象和封装都是**人类处理复杂性的有效手段**。在面对复杂系统的时候，人脑能承受的信息复杂程度是有限的，所以我们需要忽略掉一些非关键性的实现细节。而抽象作为一种只关注功能点不关注实现的设计思路，正好帮我们的大脑过滤掉大部分非必要信息。

> 抽象是一种非常宽泛的设计思想。在代码设计中，起到非常重要的指导作用。

> 很多设计原则都体现了抽象这种设计思想，比如基于接口而非实现编程、开闭原则「对扩展开放、对修改关闭」、代码耦合「降低代码的耦合性」等。

在我们定义方法名的时候，也要有抽象思维。不要在方法定义中，暴露太多实现细节。

比如`getAliyunPictureUrl()`就不是一个具有抽象思维的命名。因为如果有一天我们不把图片存储在阿里云上时，这个命名也要虽只修改。相反，我们需要抽象一个`getPictureUrl()`，我们需要提供阿里云及其他的不同实现就好。这就是对扩展开放，对修改关闭。

### 继承「代码复用」

> 继承最大的好处就是代码复用。
>
> 加入两个类有一些相同的属性和方法，我们就可以把这些相同的部分，抽取到父类中，让两个子类继承父类。子类重用父类中相同的代码，也可以重写差异。

不过这不是继承所特有的，也可以通过其他方式解决代码复用问题，比如组合。

从上下层级来说：继承是一种is-a关系。

> 如果**过度使用**继承，继承层级过深而复杂，就**会导致代码可读性、可维护性差**。为了了解一个功能，不仅要查看这个类的代码，还要按照继承关系一层一层往上查看父类代码、父类的父类代码……。
>
> 子类和父类高度耦合，修改父类代码，会直接影响子类实现。

继承是一种非常有争议的特性。很多人认为继承是一种反模式，应该尽量少用，甚至不用。

> 在「继承还是组合」设计思想时总结。

### 多态「”动态“调用」

> 在编译中，子类可以替换为父类的声明。实际代码运行过程中，调用子类的方法实现。

举个例子。

```java

public class DynamicArray {
  private static final int DEFAULT_CAPACITY = 10;
  protected int size = 0;
  protected int capacity = DEFAULT_CAPACITY;
  protected Integer[] elements = new Integer[DEFAULT_CAPACITY];
  
  public int size() { return this.size; }
  public Integer get(int index) { return elements[index];}
  //...省略n多方法...
  
  public void add(Integer e) {
    ensureCapacity();
    elements[size++] = e;
  }
  
  protected void ensureCapacity() {
    //...如果数组满了就扩容...代码省略...
  }
}

public class SortedDynamicArray extends DynamicArray {
  @Override
  public void add(Integer e) {
    ensureCapacity();
    int i;
    for (i = size-1; i>=0; --i) { //保证数组中的数据有序
      if (elements[i] > e) {
        elements[i+1] = elements[i];
      } else {
        break;
      }
    }
    elements[i+1] = e;
    ++size;
  }
}

public class Example {
  public static void test(DynamicArray dynamicArray) {
    dynamicArray.add(5);
    dynamicArray.add(1);
    dynamicArray.add(3);
    for (int i = 0; i < dynamicArray.size(); ++i) {
      System.out.println(dynamicArray.get(i));
    }
  }
  
  public static void main(String args[]) {
    DynamicArray dynamicArray = new SortedDynamicArray();
    test(dynamicArray); // 打印结果：1、3、5
  }
}
```

- 编程语言要支持父类对象可以引用子类对象。

  也就是将`SortedDynamicArray`传递给`DynamicArray`。

- 编程语言要支持继承。

  `SortedDynamicArray`继承了`DynamicArray`，才能将`SortedDyamicArray`传递给`DynamicArray`。

- 编程语言支持子类重写父类中的方法。

  `SortedDyamicArray`重写了`DynamicArray`中的`add()`方法。

> 多态特性，除了上面说的「继承+方法重写」这种方式以外。还有两种比较常见的实现方式。
>
> - 利用接口实现
> - 利用`duck-typing`实现。

#### 接口实现

```java

public interface Iterator {
  boolean hasNext();
  String next();
  String remove();
}

public class Array implements Iterator {
  private String[] data;
  
  public boolean hasNext() { ... }
  public String next() { ... }
  public String remove() { ... }
  //...省略其他方法...
}

public class LinkedList implements Iterator {
  private LinkedListNode head;
  
  public boolean hasNext() { ... }
  public String next() { ... }
  public String remove() { ... }
  //...省略其他方法... 
}

public class Demo {
  private static void print(Iterator iterator) {
    while (iterator.hasNext()) {
      System.out.println(iterator.next());
    }
  }
  
  public static void main(String[] args) {
    Iterator arrayIterator = new Array();
    print(arrayIterator);
    
    Iterator linkedListIterator = new LinkedList();
    print(linkedListIterator);
  }
}
```

#### duck-typing实现

```python
class Logger:
    def record(self):
        print(“I write a log into file.”)
        
class DB:
    def record(self):
        print(“I insert data into db. ”)
        
def test(recorder):
    recorder.record()

def demo():
    logger = Logger()
    db = DB()
    test(logger)
    test(db)
```

Duck-typing实现多态的方式非常灵活。Logger和DB两个类没有任何关系，既不是继承也不是接口实现。

但他们都定义了`record()`方法可以传递到`test()`中执行。

> 多态提高了代码的可扩展性。

## 面向过程和面向对象

像`面向对象编程`和`面向对象编程语言`一样，`面向过程编程`和`面向过程编程语言`，也是成对出现的两个概念。

- 面向过程编程也是一种编程范式「编程风格」。

  以过程「方法、函数、操作」作为组织代码的基本单元。

  以数据「成员变量、属性」与方法分离为最主要特点。

  他是一种流程化的编程风格，通过拼接一组顺序执行的方法来操作数据，实现某种功能。

- 面向过程编程语言是编程语言。

  不支持类和对象两个语法概念。

  不支持丰富的面向对象编程特性「封装、继承、多态」。

面向过程的代码示例：

```c

struct User {
  char name[64];
  int age;
  char gender[16];
};

struct User parse_to_user(char* text) {
  // 将text(“小王&28&男”)解析成结构体struct User
}

char* format_to_text(struct User user) {
  // 将结构体struct User格式化成文本（"小王\t28\t男"）
}

void sort_users_by_age(struct User users[]) {
  // 按照年龄从小到大排序users
}

void format_user_file(char* origin_file_path, char* new_file_path) {
  // open files...
  struct User users[1024]; // 假设最大1024个用户
  int count = 0;
  while(1) { // read until the file is empty
    struct User user = parse_to_user(line);
    users[count++] = user;
  }
  
  sort_users_by_age(users);
  
  for (int i = 0; i < count; ++i) {
    char* formatted_user_text = format_to_text(users[i]);
    // write to new file...
  }
  // close files...
}

int main(char** args, int argv) {
  format_user_file("/user.txt", "/formatted_users.txt");
}
```

改为面向对象编程的示例

```java

 public class User {
  private String name;
  private int age;
  private String gender;
  
  public User(String name, int age, String gender) {
    this.name = name;
    this.age = age;
    this.gender = gender;
  }
  
  public static User praseFrom(String userInfoText) {
    // 将text(“小王&28&男”)解析成类User
  }
  
  public String formatToText() {
    // 将类User格式化成文本（"小王\t28\t男"）
  }
}

public class UserFileFormatter {
  public void format(String userFile, String formattedUserFile) {
    // Open files...
    List users = new ArrayList<>();
    while (1) { // read until file is empty 
      // read from file into userText...
      User user = User.parseFrom(userText);
      users.add(user);
    }
    // sort users by age...
    for (int i = 0; i < users.size(); ++i) {
      String formattedUserText = user.formatToText();
      // write to new file...
    }
    // close files...
  }
}

public class MainApplication {
  public static void main(String[] args) {
    UserFileFormatter userFileFormatter = new UserFileFormatter();
    userFileFormatter.format("/home/zheng/users.txt", "/home/zheng/formatted_users.txt");
  }
}
```

区别就是，代码的组织方式不同。

- 面向过程风格的代码呗组织成了一组方法组合及其数据结构。

  方法和数据结构是分开的。

- 面向对象风格的代码被组织成一组类，方法和数据结构是绑定在一起的「绑定在类中」。



>面向对象更能应对大规模复杂程序的开发。
>
>面向对象的代码更易复用、易扩展、已维护。
>
>从编程语言跟机器打交道的方式的演进规律中：面向对象比起面向过程，更人性化、更高级、更智能。

### 典型举例

#### 滥用getter、setter方法

> 经常有的人在定义完类的属性之后，就顺手把这些属性的getter、setter方法都定义上。
>
> 为了省事，还会使用IDE的代码自动生成。或者Lombok的编译期注解。
>
> 某些POJO可能确实需要，但绝大多数类并不需要这样的getter、setter方法。如果加上了，反而会退化成面向过程编程的代码。

```java
public class ShoppingCart {
  private int itemsCount;
  private double totalPrice;
  private List<ShoppingCartItem> items = new ArrayList<>();
  
  public int getItemsCount() {
    return this.itemsCount;
  }
  
  public void setItemsCount(int itemsCount) {
    this.itemsCount = itemsCount;
  }
  
  public double getTotalPrice() {
    return this.totalPrice;
  }
  
  public void setTotalPrice(double totalPrice) {
    this.totalPrice = totalPrice;
  }

  public List<ShoppingCartItem> getItems() {
    return this.items;
  }
  
  public void addItem(ShoppingCartItem item) {
    items.add(item);
    itemsCount++;
    totalPrice += item.getPrice();
  }
  // ...省略其他方法...
}
```

`ShoppingCart`是一个简化后的购物车类，有三个私有「`private`」属性：`itemsCount`、`totalPrice`、`items`。三个属性，都分别定义了getter、setter方法。

- 对于`itemsCount`和`totalPrice`两个属性增加getter、setter方法，就相当于变成了public公有属性。

  外部可以随意修改两个属性的值。如果发生修改，就可能会导致对于`ShoppingCart`的数据不一致。

- 对于`items`属性，定义了`getter`和`addItem`方法，且内部修改了`itemsCount`和`totalPrice`两个属性。看起来没啥问题，但其实不是。

  外部代码依然可以在获取到`items`进行任意修改。比如这样：

  ```java
  ShoppingCart cart = new ShoppCart();
  ...
  cart.getItems().clear(); // 清空购物车
  ```

  同样会导致`itemsCount`、`totalPrice`、`items`三者数据不一致。

  应该在`ShoppingCart`中提供可以给调用者使用的`clear()`方法:

  ```java
  public class ShoppingCart {
    // ...省略其他代码...
    public void clear() {
      items.clear();
      itemsCount = 0;
      totalPrice = 0.0;
    }
  }
  ```

  那getter方法的问题怎么解决呢？

  可以使用jdk提供的`Collections.unmodifiableList()`方法，使getter的返回值编程一个不可修改的集合容器，如果遇到修改就会抛出`UnsupportedOperationException`异常。

  ```java
  
  public class ShoppingCart {
    // ...省略其他代码...
    public List<ShoppingCartItem> getItems() {
      return Collections.unmodifiableList(this.items);
    }
  }
  
  public class UnmodifiableList<E> extends UnmodifiableCollection<E>
                            implements List<E> {
    public boolean add(E e) {
      throw new UnsupportedOperationException();
    }
    public void clear() {
      throw new UnsupportedOperationException();
    }
    // ...省略其他代码...
  }
  
  ShoppingCart cart = new ShoppingCart();
  List<ShoppingCartItem> items = cart.getItems();
  items.clear();//抛出UnsupportedOperationException异常
  ```

#### 滥用全局变量和全局方法

> 常见的全局变量有「单例类对象」、「静态成员变量」、「常量」等。
>
> 常见的全局方法有「静态方法」。

##### 大而全的Constants

```java

public class Constants {
  public static final String MYSQL_ADDR_KEY = "mysql_addr";
  public static final String MYSQL_DB_NAME_KEY = "db_name";
  public static final String MYSQL_USERNAME_KEY = "mysql_username";
  public static final String MYSQL_PASSWORD_KEY = "mysql_password";
  
  public static final String REDIS_DEFAULT_ADDR = "192.168.7.2:7234";
  public static final int REDIS_DEFAULT_MAX_TOTAL = 50;
  public static final int REDIS_DEFAULT_MAX_IDLE = 50;
  public static final int REDIS_DEFAULT_MIN_IDLE = 20;
  public static final String REDIS_DEFAULT_KEY_PREFIX = "rt:";
  
  // ...省略更多的常量定义...
}
```

- 影响代码的可维护性。

  太集中。大家都在修改这些常量，类会变得越来越大，提交代码的冲突概率增加。

- 编译时间增加。

  `Constants`每次修改都会导致依赖他的类文件重新编译，浪费很多不必要的编译时间。

  这个编译时间，可不是一个可忽略的时间。编译项目、每次运行单元测试，都会触发一次编译。

  它是会影响开发和发布效率的。

- 影响代码的复用性。

  如果要在另一个项目中，复用本项目开发的某个类，而这个类又依赖`Constants`类。

  即便这个类只依赖`Constants`类中的一小部分常量，仍然需要把整个`Constants`类一并引入。

> 有两种思路可以借鉴。
>
> - 把一个`Constants`类拆分为功能更加单一的多个类。
>
>   比如MySQL的相关常量都放在`MysqlConstants`类中；Redis的相关常量都放在`RedisConstants`中。
>
> - 不单独设置`Constants`常量类。
>
>   哪个类用到了某个常量，就把这个常量定义在这个类中。
>
>   比如`RedisConfig`类用到了Redis配置相关的常量，就把这个常量直接定义在`RedisConfig`中。
>
>   这样也提高了类设计的内聚性和代码的复用性。

##### Utils类

> Utils类出现的背景是：
>
> - 有两个类A、B，他们都会用到一块相同的功能逻辑，需要避免代码重复
> - A和B不一定具有继承关系，硬生生的抽象出来一个父类，会影响代码的可读性。
> - 分割出来的方法，不需要共享任何数据「共享可以使用组合，而不是Utils静态方法」。所以新的类不需要定义任何属性。
>
> 这个时候，我们就可以把它定义为只包含静态方法的Utils类了。

只包含静态方法不包含任何属性的`Utils`类，是彻彻底底的面向过程编程风格。

但是不能因此杜绝使用`Utils`类这种模式。`Utils`类的存在在软件开发中还是挺有用的，能解决代码复用的问题。而是要**尽量避免滥用**，不嫩不加思考的随意定义`Utils`类。

跟`Constants`类的设计一样，Utils类设计的时候也需要细化。

针对不同的功能设计不同的Utils类，比如`FileUtils`、`StringUtils`等等，**不要设计一个大而全的Utils类**。

#### 定义数据和方法分离的类

> 传统的MVC结构分为`Model`、`Controller`、`View`三层。在做了前后端分离之后三层结构变成了`Controller`、`Service`、`Repository`三层。
>
> `Controller`层负责暴露接口供前端调用。`Service`层负责核心业务逻辑。`Repository`层负责数据持久化。

每一层中，会定义对应的`VO`、`BO「DTO」`、`Entity`。一般情况下只会定义数据，不会定义方法。

所有操作这些数据的业务逻辑都定义在对应层的其他类中。这就是典型的面向过程编程风格。

这是现在常见的WEB项目开发模式，是基于**贫血模型**的开发模式。

***

> 不得不承认，在我们进行面向过程编码的过程中，很容易且不由自主的写出面向过程风格的代码。
>
> 因为在日常生活中，要去完成一个任务的时候，一般会先去思考「应该先做什么、后做什么，如何一步一步的顺序执行一系列操作」，最后完成整个任务。
>
> **面向过程编程风格恰恰符合人的这种流程化思维模式。**
>
> 而面向对象编程正好相反，他是**自底向上**的思考模式。
>
> 它不是先去按照执行流程分接任务，而是将任务翻译成一个一个小的模块「类」,设计类之间的交互，最后按照流程将类组装起来，完成整个任务。
>
> 面向对象更难一些，需要考虑数据和方法的组合，如何设计类的关系，如何设计类的交互等等诸多设计问题。
>
> 基于这两点，日常代码可能也就不由自主的变成面向过程编程风格了。

且。**面向过程一定不会被彻底摒弃**。

面向对象编程离不开面向过程变成的基础，因为，类中方法的实现逻辑就是面向过程风格的代码。

如果不是，那他下一个level也是、使用到的标准开发库是、字节码执行的汇编语言也是。你根本跑不了。

**我们最后的目的还是要写出易维护、易读、易复用、易扩展的高质量代码。**

## 接口和抽象类

接口和抽象类不同。

- 接口是一种has-a关系，表示了这个类有这个接口的功能。就像一个打在类上的功能tag。
- 抽象类是is-a关系，肯定是有继承实现的父类。

### 抽象类

```java
// 抽象类
public abstract class Logger {
  private String name;
  private boolean enabled;
  private Level minPermittedLevel;

  public Logger(String name, boolean enabled, Level minPermittedLevel) {
    this.name = name;
    this.enabled = enabled;
    this.minPermittedLevel = minPermittedLevel;
  }
  
  public void log(Level level, String message) {
    boolean loggable = enabled && (minPermittedLevel.intValue() <= level.intValue());
    if (!loggable) return;
    doLog(level, message);
  }
  
  protected abstract void doLog(Level level, String message);
}
// 抽象类的子类：输出日志到文件
public class FileLogger extends Logger {
  private Writer fileWriter;

  public FileLogger(String name, boolean enabled,
    Level minPermittedLevel, String filepath) {
    super(name, enabled, minPermittedLevel);
    this.fileWriter = new FileWriter(filepath); 
  }
  
  @Override
  public void doLog(Level level, String mesage) {
    // 格式化level和message,输出到日志文件
    fileWriter.write(...);
  }
}
// 抽象类的子类: 输出日志到消息中间件(比如kafka)
public class MessageQueueLogger extends Logger {
  private MessageQueueClient msgQueueClient;
  
  public MessageQueueLogger(String name, boolean enabled,
    Level minPermittedLevel, MessageQueueClient msgQueueClient) {
    super(name, enabled, minPermittedLevel);
    this.msgQueueClient = msgQueueClient;
  }
  
  @Override
  protected void doLog(Level level, String mesage) {
    // 格式化level和message,输出到消息中间件
    msgQueueClient.send(...);
  }
}
```

`Logger`是一个记录日志的抽象类，`FileLogger`和`MessageQueueLogger`继承`Logger`分别实现两种不同的日志记录方式：记录在文件中或发送到消息队列中。两个子类复用了父类`Logger`中的`name`、`enabled`、`minPermittedLevel`属性和`log()`方法，但因为两个子类日志记录方式不同，他们又各自重写了父类的抽象方法`doLog()`。

- 抽象类不允许被实例化，只能被继承。也就是不能直接`new Logger()`。
- 抽象类可以包含属性和方法。也可以有不包含代码的需要由子类实现的抽象方法。
- 子类继承抽象类，必须重写抽象类中的所有抽象方法。

### 接口

```java
// 接口
public interface Filter {
  void doFilter(RpcRequest req) throws RpcException;
}
// 接口实现类：鉴权过滤器
public class AuthencationFilter implements Filter {
  @Override
  public void doFilter(RpcRequest req) throws RpcException {
    //...鉴权逻辑..
  }
}
// 接口实现类：限流过滤器
public class RateLimitFilter implements Filter {
  @Override
  public void doFilter(RpcRequest req) throws RpcException {
    //...限流逻辑...
  }
}
// 过滤器使用Demo
public class Application {
  // filters.add(new AuthencationFilter());
  // filters.add(new RateLimitFilter());
  private List<Filter> filters = new ArrayList<>();
  
  public void handleRpcRequest(RpcRequest req) {
    try {
      for (Filter filter : filters) {
        filter.doFilter(req);
      }
    } catch(RpcException e) {
      // ...处理过滤结果...
    }
    // ...省略其他处理逻辑...
  }
}
```

定义了一个`Filter`接口。`AuthencationFilter`和`RateLimitFilter`是接口的两个实现类。`Application`实现了对RPC请求的鉴权和限流的过滤。

- 接口不能声明属性。
- 接口只能声明方法，方法不能包含代码实现。
- 类实现接口的时候，必须实现接口中声明的所有方法。

### 抽象类和接口能解决什么问题

#### 抽象类

> 抽象类实际使用的是继承解决了代码复用的问题。但是继承并不要求父类一定是抽象类。那抽象类还有什么用呢？

我们把`Logger`改为普通父类，删除`log()`、`doLog()`方法，新增`isLoggable()`方法。

```java
// 父类：非抽象类，就是普通的类. 删除了log(),doLog()，新增了isLoggable().
public class Logger {
  private String name;
  private boolean enabled;
  private Level minPermittedLevel;

  public Logger(String name, boolean enabled, Level minPermittedLevel) {
    //...构造函数不变，代码省略...
  }

  protected boolean isLoggable() {
    boolean loggable = enabled && (minPermittedLevel.intValue() <= level.intValue());
    return loggable;
  }
}
// 子类：输出日志到文件
public class FileLogger extends Logger {
  private Writer fileWriter;

  public FileLogger(String name, boolean enabled,
    Level minPermittedLevel, String filepath) {
    //...构造函数不变，代码省略...
  }
  
  public void log(Level level, String mesage) {
    if (!isLoggable()) return;
    // 格式化level和message,输出到日志文件
    fileWriter.write(...);
  }
}
// 子类: 输出日志到消息中间件(比如kafka)
public class MessageQueueLogger extends Logger {
  private MessageQueueClient msgQueueClient;
  
  public MessageQueueLogger(String name, boolean enabled,
    Level minPermittedLevel, MessageQueueClient msgQueueClient) {
    //...构造函数不变，代码省略...
  }
  
  public void log(Level level, String mesage) {
    if (!isLoggable()) return;
    // 格式化level和message,输出到消息中间件
    msgQueueClient.send(...);
  }
}
```

这样做可以达到代码复用，但是无法使用多台特性。

```java
//这样的写法就会报错，因为Logger中没有定义log()方法
Logger logger = new FileLogger("access-log", true, Level.WARN, "/tmp/access.log");
logger.log(Level.ERROR, "This is a test log message.");
```

那在父类`Logger`中定义一个空的`log()`方法，不就行了吗？

```java
public class Logger {
  // ...省略部分代码...
  public void log(Level level, String mesage) { // do nothing... }
}
public class FileLogger extends Logger {
  // ...省略部分代码...
  @Override
  public void log(Level level, String mesage) {
    if (!isLoggable()) return;
    // 格式化level和message,输出到日志文件
    fileWriter.write(...);
  }
}
public class MessageQueueLogger extends Logger {
  // ...省略部分代码...
  @Override
  public void log(Level level, String mesage) {
    if (!isLoggable()) return;
    // 格式化level和message,输出到消息中间件
    msgQueueClient.send(...);
  }
}
```

**不优雅。**

- `Logger`中的空方法影响代码的可读性。得看到子类对`log()`方法重写之后，才能明白设计意图。
- 如果新创建子类不重写`log()`方法，就会导致日志无法记录。
- `Logger`可以被实例化。但是无法记录日志。

#### 接口 

> 抽象类更多是为了代码复用，而接口侧重于解耦。
>
> 请看「基于接口和基于实现」部分。

## 基于接口和基于实现

> 「基于接口而非实现」这条原则的英文描述是『Program to an interface,not an implementation.』
>
> 原则本身跟任何一种编程语言都没有关系，它是一条比较抽象、泛化的设计思想。
>
> 理解这条原则的关键，就是理解『接口』两个字。本质上，**接口就是一组协议或约定，是功能提供者提供给使用者的功能列表。**比如服务端与客户端之间的接口，类库提供的接口，甚至一组通信的协议都可以叫做接口。
>
> 如果落实在具体的编码上，接口就是编程语言中的接口或者抽象类。

应用「基于接口而非实现」这条原则，可以**将接口和实现相分离，封装不稳定的实现，暴露稳定的接口**。

上游系统面向接口而非实现编程，不依赖不稳定的实现细节。当实现发生变化的时候，上游系统的代码基本上不需要改动，耦合度降低了，扩展性提升了。

软件开发中，最大的挑战之一就是需求的不断变化，这也是考验代码设计好坏的一个标准。**越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。**好的代码设计，不仅能应对当下的需求，而且在将来需求发生变化的时候，仍然能够在不破坏原有代码设计的情况下灵活应对。抽象就是提高代码扩展性、灵活性、可维护性最有效的手段之一。

> 假设系统中有很多涉及图片处理和存储的业务逻辑，图片经过处理之后上传阿里云。
>
> 为了代码复用，封装了一个图片存储相关的组件，提供了统一的AliyunImageStore类。

```java
public class AliyunImageStore {
  //...省略属性、构造函数等...
  
  public void createBucketIfNotExisting(String bucketName) {
    // ...创建bucket代码逻辑...
    // ...失败会抛出异常..
  }
  
  public String generateAccessToken() {
    // ...根据accesskey/secrectkey等生成access token
  }
  
  public String uploadToAliyun(Image image, String bucketName, String accessToken) {
    //...上传图片到阿里云...
    //...返回图片存储在阿里云上的地址(url）...
  }
  
  public Image downloadFromAliyun(String url, String accessToken) {
    //...从阿里云下载图片...
  }
}

// AliyunImageStore类的使用举例
public class ImageProcessingJob {
  private static final String BUCKET_NAME = "ai_images_bucket";
  //...省略其他无关代码...
  
  public void process() {
    Image image = ...; //处理图片，并封装为Image对象
    AliyunImageStore imageStore = new AliyunImageStore(/*省略参数*/);
    imageStore.createBucketIfNotExisting(BUCKET_NAME);
    String accessToken = imageStore.generateAccessToken();
    imagestore.uploadToAliyun(image, BUCKET_NAME, accessToken);
  }
  
}
```

整个上传流程包含三个步骤：创建bucket「目录」、生成assess token、携带access token上传图片到指定bucket中。乍一看问题不大。

**软件开发中唯一不变的就是变化**。过了一段时间，自建了私有云不再将图片存储在阿里云上了。为了满足这个需求的变化，就需要修改代码。

> 需要设计一个存储图片到私有云的`PrivateImageStore`类，并用它替换掉所有`AliyunImageStore`类对象。简单一想不复杂，只是简单替换而已对整体代码改动不大。不过隐藏了很多容易出问题的「魔鬼细节」。

新的`PrivateImageStore`类需要实现哪些方法，才能在尽量最小化代码修改的情况下，替换掉`AliyunImageStore`类呢？这就要求我们必须将`AliyunImageStore`类中所定义的所有public方法，在`PrivateImageStore`类中逐一定义并重新实现一遍。

- 有些函数命名暴露了实现细节。

  比如`updateToAliyun()`和`downloadFromAliyun()`，照搬到`PrivateImageStore`中显然不合适。

- 流程不同。

  阿里云的图片上传和下载，需要生产`access token`。而私有云不需要。所以`generateAccessToken()`不能照搬，但是客户代码中用到了这个方法，就需要对客户代码也做修改。

为了避免这样的问题，从`AliyunImageStore`设计的时候，就需要遵从「基于接口而非实现编程」的原则。

- 函数命名不能暴露任何实现细节。

  `updateToAliyun()`不符合要求，要改为抽象的命名方式`update()`

- 封装具体的实现细节。

  流程上的不同不能暴露给客户代码，比如`generateAccessToken()`不应该交给客户代码调用。

- 客户代码「使用者」依赖接口编程，而不是具体的实现类。

重构如下。

```java
public interface ImageStore {
  String upload(Image image, String bucketName);
  Image download(String url);
}

public class AliyunImageStore implements ImageStore {
  //...省略属性、构造函数等...

  public String upload(Image image, String bucketName) {
    createBucketIfNotExisting(bucketName);
    String accessToken = generateAccessToken();
    //...上传图片到阿里云...
    //...返回图片在阿里云上的地址(url)...
  }

  public Image download(String url) {
    String accessToken = generateAccessToken();
    //...从阿里云下载图片...
  }

  private void createBucketIfNotExisting(String bucketName) {
    // ...创建bucket...
    // ...失败会抛出异常..
  }

  private String generateAccessToken() {
    // ...根据accesskey/secrectkey等生成access token
  }
}

// 上传下载流程改变：私有云不需要支持access token
public class PrivateImageStore implements ImageStore  {
  public String upload(Image image, String bucketName) {
    createBucketIfNotExisting(bucketName);
    //...上传图片到私有云...
    //...返回图片的url...
  }

  public Image download(String url) {
    //...从私有云下载图片...
  }

  private void createBucketIfNotExisting(String bucketName) {
    // ...创建bucket...
    // ...失败会抛出异常..
  }
}

// ImageStore的使用举例
public class ImageProcessingJob {
  private static final String BUCKET_NAME = "ai_images_bucket";
  //...省略其他无关代码...
  
  public void process() {
    Image image = ...;//处理图片，并封装为Image对象
    ImageStore imageStore = new PrivateImageStore(...);
    imagestore.upload(image, BUCKET_NAME);
  }
}
```

***

但。也**不应该为任何一个类都定义接口**。

做任何事情都要讲求一个「度」。多度使用这条原则，接口满天飞，也会导致不必要的开发负担。至于哪些需要定接口；哪些不需要，还是要回归到设计原则诞生的初衷『将接口与实现分离，封装不稳定的实现，暴露稳定的接口。如果发生修改，上游代码基本不需要改动，以此降低代码见的耦合性，提高代码的扩展性』上来。

如果业务场景中，某个功能只有一种实现，未来也不可能被其他方式替换，就没必要设计接口。直接使用实现类就可以了。

越不稳定的系统，我们越要在代码的扩展性、维护性上下功夫。如果一个系统特别稳定，开发完之后，基本不需要维护，那么也就没有必要为其扩展性投入不必要的开发时间。

## 继承还是组合

> 在面向对象编程中，有一条经典的设计原则：「组合优先于继承，多用组合少用继承」。

### 为什么不推荐使用继承

> 继承是面向对象的四大特性之一，用来表示类之间的is-a关系，可以解决代码复用的问题。

但如果继承层级过深、过复杂，也会影响到代码的可维护性。

假设我们要设计一个关于鸟的类。我们将「鸟类」这样一个抽象的事物概念，定义为一个抽象类`AbstractBird`，所有更细分的鸟，比如麻雀、鸽子、乌鸦等，都继承这个抽象类。

大部分鸟都会飞，那我们可以可以在`AbstractBird`抽象类中，定义一个`fly()`方法？不可以。尽管大部分鸟会飞，但也有特例，比如鸵鸟不会飞。鸵鸟继承具有`fly()`方法的父类是，鸵鸟就有了「飞」这样的行为。那鸵鸟重写`fly()`方法，并抛出`UnSupportedMethodException`异常不就可以了吗？

```java
public class AbstractBird {
  //...省略其他属性和方法...
  public void fly() { //... }
}

public class Ostrich extends AbstractBird { //鸵鸟
  //...省略其他属性和方法...
  public void fly() {
    throw new UnSupportedMethodException("I can't fly.'");
  }
}
```

解决了问题，但是不够优美。

因为除了鸵鸟之外，不会飞的鸟还有很多，比如企鹅。对于这些不会飞的鸟来说，我们都需要重写`fly()`方法，抛出异常。

- 徒增了编码的工作量

- 违背了最小值是原则「least knowledge principle也叫最少知识原则或者迪米特法则」。

  暴露不该暴露的接口给外部，增加了类使用过程中误用的概率。

那如果，从`AbstractBird`类派生出两个更加细分的抽象类：会飞的鸟类`AbstractFlyableBird`和不会飞的鸟类`AbstractUnFlyableBird`，这样做行不行呢？

单从这一个问题来看，继承关系还比较简单，从二层变成了三层。但是也就因为我们只关注了这一个问题。如果我们还关注「鸟会不会叫」呢？这两个问题，会组合出4中不同的情况：会飞会叫、会飞不会叫、不会飞会叫、不会飞不会叫。沿用之前的设计思路就需要定义四个抽象类。那如果我们还需要考虑「会不会下蛋」呢？这样的组合是一种指数级的爆炸。类的继承层级会越来越深，继承关系也就越来越复杂。

- 导致代码的可读性变差。

  我们要搞清楚某个类具有哪些方法、属性，必须阅读父类的代码、父类的父类的代码……一直追溯到最顶级父类的代码。

- 破坏了类的封装特性，将父类的实现细节暴露给了子类。

  子类的实现依赖父类的实现，两者高度耦合。一旦父类代码修改，就会影响所有子类的逻辑。

### 组合有哪些优势

我们可以使用组合「composition」、接口、委托「delegation」三个技术，解决刚刚继承存在的问题。

- 针对会飞的问题，定义一个`Flyable`接口，只让会飞的鸟去实现这个接口。
- 针对会叫的问题，定义一个`Tweetable`接口。
- 针对会下蛋问题，定义一个`EggLayable`接口。

```java
public interface Flyable {
  void fly();
}
public interface Tweetable {
  void tweet();
}
public interface EggLayable {
  void layEgg();
}
public class Ostrich implements Tweetable, EggLayable {//鸵鸟
  //... 省略其他属性和方法...
  @Override
  public void tweet() { //... }
  @Override
  public void layEgg() { //... }
}
public class Sparrow impelents Flyable, Tweetable, EggLayable {//麻雀
  //... 省略其他属性和方法...
  @Override
  public void fly() { //... }
  @Override
  public void tweet() { //... }
  @Override
  public void layEgg() { //... }
}
```

接口只声明方法，不定义实现。

如果每个会下蛋的鸟都需要重新实现一遍`layEgg()`方法，并且实现逻辑是一样的，就会导致代码重复问题。

我们分别针对三个接口定义三个能力类。

- 实现了`Flyable`接口的`FlyAbility`类。
- 实现了`Tweetable`接口的`TweetAbility`类。
- 实现了`EggLayable`接口的`EggLayAbility`类。

在通过组合和委托来消除代码重复。

```java
public interface Flyable {
  void fly()；
}
public class FlyAbility implements Flyable {
  @Override
  public void fly() { //... }
}
//省略Tweetable/TweetAbility/EggLayable/EggLayAbility

public class Ostrich implements Tweetable, EggLayable {//鸵鸟
  private TweetAbility tweetAbility = new TweetAbility(); //组合
  private EggLayAbility eggLayAbility = new EggLayAbility(); //组合
  //... 省略其他属性和方法...
  @Override
  public void tweet() {
    tweetAbility.tweet(); // 委托
  }
  @Override
  public void layEgg() {
    eggLayAbility.layEgg(); // 委托
  }
}
```

- 继承的is-a关系。通过组合和接口的has-a关系替代。
- 多态特性。利用接口实现。
- 代码复用。通过组合和委托来实现。

所以从理论上讲，通过组合、接口、委托三个技术，我们可以完全替换掉继承。

### 如何判断使用组合还是继承

> 尽管鼓励多用组合少用继承，但组合也并不是完美的，继承也并不是一无是处。

> 从上面的例子来看，继承改写成组合意味着，要做更细力度的类的拆分。也就意味着要定义更多的类和接口，或多或少的增加了代码的复杂程度和维护成本。实际开发中，要根据具体的情况来具体选择继承还是组合。

如果类之间的**继承结构稳定**「不会轻易改变」，**继承层次比较浅**「比如最多两层继承关系」，继承关系不复杂，可以大胆使用继承。

反之，系统越不稳定，继承层级越深，继承关系复杂，尽量使用组合替代继承。

除此之外还有一些设计模式会固定使用继承或者组合。

> 前面我们讲到继承可以实现代码复用。利用继承特性，我们把相同的属性和方法，抽取出来，定义到父类中。子类复用父类中的属性和方法，达到代码复用的目的。但是，有的时候，从业务含义上，A 类和 B 类并不一定具有继承关系。比如，Crawler 类和 PageAnalyzer 类，它们都用到了 URL 拼接和分割的功能，但并不具有继承关系（既不是父子关系，也不是兄弟关系）。仅仅为了代码复用，生硬地抽象出一个父类出来，会影响到代码的可读性。如果不熟悉背后设计思路的同事，发现 Crawler 类和 PageAnalyzer 类继承同一个父类，而父类中定义的却只是 URL 相关的操作，会觉得这个代码写得莫名其妙，理解不了。这个时候，使用组合就更加合理、更加灵活。
>
> ```java
> public class Url {
>   //...省略属性和方法
> }
> 
> public class Crawler {
>   private Url url; // 组合
>   public Crawler() {
>     this.url = new Url();
>   }
>   //...
> }
> 
> public class PageAnalyzer {
>   private Url url; // 组合
>   public PageAnalyzer() {
>     this.url = new Url();
>   }
>   //..
> }
> ```

> 还有一些特殊的场景要求我们必须使用继承。如果你不能改变一个函数的入参类型，而入参又非接口，为了支持多态，只能采用继承来实现。
>
> 比如下面这样一段代码，其中 FeignClient 是一个外部类，我们没有权限去修改这部分代码，但是我们希望能重写这个类在运行时执行的 encode() 函数。这个时候，我们只能采用继承来实现了。
>
> ```java
> public class FeignClient { // Feign Client框架代码
>   //...省略其他代码...
>   public void encode(String url) { //... }
> }
> 
> public void demofunction(FeignClient feignClient) {
>   //...
>   feignClient.encode(url);
>   //...
> }
> 
> public class CustomizedFeignClient extends FeignClient {
>   @Override
>   public void encode(String url) { //...重写encode的实现...}
> }
> 
> // 调用
> FeignClient client = new CustomizedFeignClient();
> demofunction(client);
> ```

之所以「多用组合少用继承」这个口号喊得这么响，只是因为长期以来我们过度使用继承。

**组合并不是不完美，继承也不是一无是处。**

只要我们控制好他们的副作用、发挥它们各自的优势，在不同的场合下，恰当的使用继承还是组合才是我们追求的境界。



## MVC向DDD的转变

> 前面在「滥用全局变量和全局方法」的时候提到，很多业务系统都是基于贫血模型MVC三层架构来实现的，但是它确是一种彻彻底底的面向过程的编程风格。

特别是在**领域驱动设计「Domain Driven Design」**盛行之后，那种基于贫血模型的传统开发模式更加被人诟病。越来越多人开始提倡基于充血模型的DDD开发模式。

### 基于贫血模型的开发模式

> 目前大多数项目都是前后端分离。在这种情况下，后段项目分为`Repository层`「负责持久化数据的访问」、`Service层`「负责业务逻辑」、`Controller层`「负责暴露接口」。
>
> 下面是一个业务后端系统的日常demo。

```java
////////// Controller+VO(View Object) //////////
public class UserController {
  private UserService userService; //通过构造函数或者IOC框架注入
  
  public UserVo getUserById(Long userId) {
    UserBo userBo = userService.getUserById(userId);
    UserVo userVo = [...convert userBo to userVo...];
    return userVo;
  }
}

public class UserVo {//省略其他属性、get/set/construct方法
  private Long id;
  private String name;
  private String cellphone;
}

////////// Service+BO(Business Object) //////////
public class UserService {
  private UserRepository userRepository; //通过构造函数或者IOC框架注入
  
  public UserBo getUserById(Long userId) {
    UserEntity userEntity = userRepository.getUserById(userId);
    UserBo userBo = [...convert userEntity to userBo...];
    return userBo;
  }
}

public class UserBo {//省略其他属性、get/set/construct方法
  private Long id;
  private String name;
  private String cellphone;
}

////////// Repository+Entity //////////
public class UserRepository {
  public UserEntity getUserById(Long userId) { //... }
}

public class UserEntity {//省略其他属性、get/set/construct方法
  private Long id;
  private String name;
  private String cellphone;
}
```

- `UserVo`和`UserController`属于接口层。
- `UserBo`和`UserService`属于业务逻辑层。
- `UserEntity`和`UserRepository`属于数据访问层。

`UserBo`是一个纯粹的数据结构，只包含数据，不包含任何业务逻辑。业务逻辑在`UserService`中，通过`UserService`操作`UserBo`。`Service层`的数据和业务逻辑，被分割在了`Bo`和`Service`两个类中。

像`UserBo`这样的，**只包含数据，不包含业务逻辑的类，就叫做贫血模型「Anemic Domain Model」**。

同理UserEntity、UserVo都是基于贫血模型设计的。这种贫血模型将数据与操作分离，破坏了面向对象的封装特性，是一种典型的面向过程编程风格。

### 基于充血模型的DDD开发模式

> 充血模型跟贫血模型恰恰相反「其实也没有那么恰恰，是反义词」，数据和对应业务逻辑被封装在同一个类中。因此充血模型满足面向对象的封装特性，是面向对象编程风格。

领域驱动设计，主要用来指导如何解耦业务系统，划分业务模块，定义领域模型及其交互。

> 领域驱动设计早在2004年就被提出，到现在已经十几年了。被大众熟知，还主要是因为微服务的兴起。
>
> 除了监控、调用链追踪、API网关等服务治理系统的开发之外，微服务还有另外一个更加重要的工作，就是对项目业务，合理地做微服务拆分。而领域驱动设计恰好可以用来指导划分服务，所以微服务加速了领域驱动设计的盛行。
>
> 但是这样的概念像SOA、PAAS、敏捷开发等概念一样，是优化，不是颠覆。
>
> 即使没有听说过领域驱动设计，只要在开发业务系统，或多或少都会使用到它。如果对业务熟悉，在优化重构的过程中自然会像DDD发展，因为是优化；如果不熟悉业务，也并不能做出合理的领域设计。
>
> **领域驱动设计不是银弹。**

基于充血模型的DDD开发模式的实现，也可以在传统MVC架构下完成。

`Controller层`还是负责暴露接口。`Repository层`还是负责持久化数据存储。

那`Service层`就得变。`Service层`分为`Service类`和`Domain类`两部分。

- `Domain类`相当于贫血模型中的`BO`,但是也包含了一部分之前存在于Service中的业务结构。
- `Service类`内容减少，但不是没有，比如日志、消息、持久化、RPC调用还可以放在这一层。

后面会举例。

### 贫血模型的传统开发模式为什么如此受欢迎

> 目前几乎所有的web项目，都是基于这种贫血模型的开发模式。就连spring框架的官方demo，都是按照这种开发模式来编写的。
>
> 那为啥还会这么受欢迎呢？

- 项目业务简单。

  简单到就是基于SQL的CRUD操作。根本不需要动脑子设计充血模型，贫血模型足够了。

  甚至设计成充血模型之后，模型本身业务逻辑很少很单薄。似乎跟本身就贫血差不多。

- 有更低的设计难度

  如果我们要从一开始就设计好针对数据要暴露哪些操作，定义哪些业务逻辑。就会增加设计难度。

  贫血模型就很简单，定义数据就好。需要啥功能的业务，在Service层定义操作就完，不需要事先设计。

- 转型有成本

  思维固化、习以为常会带来一些问题。如果之前贫血模型解决了十年的web项目开发问题，也没啥问题，那这个开发痛点就不会被意识到。

  且。学习成本和转型成本势必有一些。

### 什么项目适合DDD

- 业务比较简单的系统适合贫血模型的传统开发模式。

  如果一个业务，仅仅需要增加SQL然后展示这样的SQL驱动模式。SQL体量不大，没有复用，就用贫血模型。

- 业务复杂的系统适合DDD开发。比如`Bo类`有计算模型：金融系统有复杂的利息计算模型、还款模型等等。

如果我们在项目中，应用基于充血模型的 DDD 的开发模式，那对应的开发流程就完全不一样了。在这种开发模式下，我们需要事先理清楚所有的业务，定义领域模型所包含的属性和方法。领域模型相当于可复用的业务中间层。新功能需求的开发，都基于之前定义好的这些领域模型来完成。

越复杂的系统，对代码的复用性、易维护性要求就越高，我们就越应该花更多的时间和精力在前期设计上。而基于充血模型的 DDD 开发模式，正好需要我们前期做大量的业务调研、领域模型设计，所以它更加适合这种复杂系统的开发。



