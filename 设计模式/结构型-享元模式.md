# 结构型-享元模式

顾名思义就是**共享单元**。享元模式的意图是**复用对象，节省内存**。

> 前提是享元对象是不可变对象。当一个系统中存在大量重复的对象时，如果这些重复的对象是不可变的，我们就可以利用享元模式将对象设计成享元，在内存中只保留一份实例，供多处代码引用。
>
> 这样可以减少内存中对象的数量，起到节省内存的目的。

不仅相同对象可以设计成享元，对于相似对象，也可以将这些对象中的相同部分抽取出来设计成享元，让这些大量相似的对象引用这些享元。

> **不可变对象**指的是，一旦通过构造函数初始化完成后，它的状态「对象的成员变量或者属性」都不会再被修改。
>
> 所以不可变对象不能暴露任何`setter`方法等修改内部状态的方法。
>
> 避免一处修改，影响到其他代码的使用。

## 棋牌游戏

假设在开发一个棋牌游戏，比如象棋。

一个游戏厅内有成千上万个「房间」，每个房间对应一起棋局。棋局保存每个棋子的数据。

- 棋子类型「将、相、士、炮……」
- 棋子颜色「红、黑」
- 棋子在棋局中的位置。

一个棋子类`ChessPiece`

```java
public class ChessPiece {//棋子
  private int id;
  private String text;
  private Color color;
  private int positionX;
  private int positionY;

  public ChessPiece(int id, String text, Color color, int positionX, int positionY) {
    this.id = id;
    this.text = text;
    this.color = color;
    this.positionX = positionX;
    this.positionY = positionX;
  }

  public static enum Color {
    RED, BLACK
  }

  // ...省略其他属性和getter/setter方法...
}
```

一个棋局类`ChessBoard`

```java
public class ChessBoard {//棋局
  private Map<Integer, ChessPiece> chessPieces = new HashMap<>();

  public ChessBoard() {
    init();
  }

  private void init() {
    chessPieces.put(1, new ChessPiece(1, "車", ChessPiece.Color.BLACK, 0, 0));
    chessPieces.put(2, new ChessPiece(2,"馬", ChessPiece.Color.BLACK, 0, 1));
    //...省略摆放其他棋子的代码...
  }

  public void move(int chessPieceId, int toPositionX, int toPositionY) {
    //...省略...
  }
}
```

为了记录每个房间当前的棋局情况，需要给每个房间创建一个`ChessBoard`棋局对象。那么保存这么多棋局对象就会消耗大量的内存。

这时候享元模式就派上用场了。对于棋子`ChessPiece`来说，`id`、`text`、`color`这三个属性是相同的「一个棋局跟另一个棋局都有相同的棋子」，唯独`positionX`/`positionY`不同。

我们可以将棋子的`id`、`text`、`color`抽取出来设计成享元。

```java
// 享元类
public class ChessPieceUnit {
  private int id;
  private String text;
  private Color color;

  public ChessPieceUnit(int id, String text, Color color) {
    this.id = id;
    this.text = text;
    this.color = color;
  }

  public static enum Color {
    RED, BLACK
  }

  // ...省略其他属性和getter方法...
}
```

利用工厂类来缓存这些`ChessPieceUnit`对象，通过工厂获取享元。

```java
public class ChessPieceUnitFactory {
  private static final Map<Integer, ChessPieceUnit> pieces = new HashMap<>();

  static {
    pieces.put(1, new ChessPieceUnit(1, "車", ChessPieceUnit.Color.BLACK));
    pieces.put(2, new ChessPieceUnit(2,"馬", ChessPieceUnit.Color.BLACK));
    //...省略摆放其他棋子的代码...
  }

  public static ChessPieceUnit getChessPiece(int chessPieceId) {
    return pieces.get(chessPieceId);
  }
}
```

棋子类`ChessPiece`和棋盘类`ChessBoard`重构后是这样。

```java
public class ChessPiece {
  private ChessPieceUnit chessPieceUnit;
  private int positionX;
  private int positionY;

  public ChessPiece(ChessPieceUnit unit, int positionX, int positionY) {
    this.chessPieceUnit = unit;
    this.positionX = positionX;
    this.positionY = positionY;
  }
  // 省略getter、setter方法
}

public class ChessBoard {
  private Map<Integer, ChessPiece> chessPieces = new HashMap<>();

  public ChessBoard() {
    init();
  }

  private void init() {
    chessPieces.put(1, new ChessPiece(
            ChessPieceUnitFactory.getChessPiece(1), 0,0));
    chessPieces.put(1, new ChessPiece(
            ChessPieceUnitFactory.getChessPiece(2), 1,0));
    //...省略摆放其他棋子的代码...
  }

  public void move(int chessPieceId, int toPositionX, int toPositionY) {
    //...省略...
  }
}
```

***

在使用享元模式之前，记录一万个棋局，相当于需要创建30万个棋子的`ChessPieceUnit`对象。

利用享元模式，只需要创建30个享元对象，供所有棋局共享使用即可。

***

那么问题来了：**对于棋局来说`positionX`和`positionY`也都是固定位置，优先的穷举。有没有必要做成享元呢？**

这个问题很微妙。

- 一个对象头占4字节「在64位系统开启指针压缩情况下32位」，还要加上实例对象的对象头+成员引用+对齐占位。一个int在java中占4个字节32位，把这一部分设计成享元对象，反而增大了内存的占用。

- 另一方面 Integer做了享元模式。默认情况下`-128~127`范围内的int成员指向的内存地址是同一个。

  这个会在下一部分Integer、String源码中的享元模式讲解。

