# 创建型-单例模式

**单例设计模式**「Singleton Design Pattern」是说：一个类只允许创建一个对象，那这个类就是一个单例类，这种设计模式就叫做单例模式。

## 为什么要使用单例模式

### 处理访问资源冲突问题

```java
public class Logger {
  private FileWriter writer;
  
  public Logger() {
    File file = new File("/tmp/log.txt");
    writer = new FileWriter(file, true); //true表示追加写入
  }
  
  public void log(String message) {
    writer.write(message);
  }
}

// Logger类的应用示例：
public class UserController {
  private Logger logger = new Logger();
  
  public void login(String username, String password) {
    // ...省略业务逻辑代码...
    logger.log(username + " logined!");
  }
}

public class OrderController {
  private Logger logger = new Logger();
  
  public void create(OrderVo order) {
    // ...省略业务逻辑代码...
    logger.log("Created an order: " + order.toString());
  }
}
```

像代码中所写的，定义了`Logger`类进行日志汇总到文件`/tmp/log.txt`中。在`UserController`和`OrderController`中，分别创建了两个Logger对象。在web容器的多线程环境下，如果两个servlet线程同时访问`login()`和`create()`两个函数，那在同时写入日志文件`log.txt`是就可能存在日志信息互相覆盖的情况。

这个`log.txt`文件就是共享变量，也就是竞争资源。

假设两个线程同时写入文件。

| 线程1写入文件                 | 线程2写入文件                 |
| ----------------------------- | ----------------------------- |
| 读取待写入位置 position = 105 |                               |
|                               | 读取待写入位置 position = 105 |
| 在position = 105处写入「abc」 |                               |
|                               | 在position = 105处写入「def」 |

线程2写入的「def」最终覆盖了线程1写入的「abc」。

我们能最先想到的方式就是：让日志写入串行执行，在`log()`加锁。

```java
public class Logger {
  private FileWriter writer;

  public Logger() {
    File file = new File("/Users/wangzheng/log.txt");
    writer = new FileWriter(file, true); //true表示追加写入
  }
  
  public void log(String message) {
    synchronized(this) {
      writer.write(mesasge);
    }
  }
}
```

但是这并不能解决并发问题，因为这个锁是对象级别的锁，两个实例是两个锁，也就锁不住`log()`函数。

> 其实这里加不加`log()`的对象锁都一样，因为`FileWriter`对象是线程安全的，内部使用了对象锁。
>
> ```java
> 		//StreamEncoder extend Writer
> 		public void write(char[] var1, int var2, int var3) throws IOException {
>         synchronized(this.lock) {
>             this.ensureOpen();
>             if (var2 >= 0 && var2 <= var1.length && var3 >= 0 && var2 + var3 <= var1.length && var2 + var3 >= 0) {
>                 if (var3 != 0) {
>                     this.implWrite(var1, var2, var3);
>                 }
>             } else {
>                 throw new IndexOutOfBoundsException();
>             }
>         }
>     }
> ```

那就换成类级别锁。

```java
public class Logger {
  private FileWriter writer;

  public Logger() {
    File file = new File("/Users/wangzheng/log.txt");
    writer = new FileWriter(file, true); //true表示追加写入
  }
  
  public void log(String message) {
    synchronized(Logger.class) { // 类级别的锁
      writer.write(mesasge);
    }
  }
}
```

这样就解决了问题。

> 解决资源竞争问题的办法还有很多。
>
> - 分布式锁是最常听到的一种解决方案。不过实现一个安全可靠、无bug、高性能的分布式锁并不是一件容易的事。
> - 使用并发队列。「生产者-消费者」模式，多线程往并发队列里『写日志』，单线程消费写入日志文件。

但是，问题就来了。

在一个单体项目中单线程记录日志，一方面分布式锁和并发队列太重量级；另一方面创建两个对象就没有必要。

单例模式相对于之前的解决方案恰好就解决了这一点，不用创建那么多`Logger`对象：

- 节省了对象占用的内存空间
- 节省了系统文件句柄「对于操作系统来说，文件句柄也是一种资源，不能随便浪费」

那么我们把`Logger`设计成一个单例类，在Logger类加载之初，就创建好静态属性，使得每一次的`Logger`对象都从类上获取，共享同一个`FileWriter`对象。而`FileWriter`是对象级别线程安全的，也就避免了多线程情况下写日志覆盖的问题。

```java
public class Logger {
  private FileWriter writer;
  private static final Logger instance = new Logger();

  private Logger() {
    File file = new File("/Users/wangzheng/log.txt");
    writer = new FileWriter(file, true); //true表示追加写入
  }
  
  public static Logger getInstance() {
    return instance;
  }
  
  public void log(String message) {
    writer.write(mesasge);
  }
}

// Logger类的应用示例：
public class UserController {
  public void login(String username, String password) {
    // ...省略业务逻辑代码...
    Logger.getInstance().log(username + " logined!");
  }
}

public class OrderController {  
  public void create(OrderVo order) {
    // ...省略业务逻辑代码...
    Logger.getInstance().log("Created a order: " + order.toString());
  }
}
```

### 表示全局唯一类

在业务概念上，如果有些数据在系统中只应该保存一份，那就比较适合设计成单例类。

- 配置信息类。

  在系统中只有一个配置文件，当配置文件被加载到内存之后以对象形式存在，理应只有一份。

- 唯一递增ID生成器

  如果程序中有两个这个对象，那就会产生重复ID，也要设计成单例

当然，单例的实现方式有很多种，各有优缺点。暂时还不涉及这部分的改造。

