# 基于设计原则和规范与重构实战性能计数器

> 背景。
>
> 我们希望设计开发一个小框架，能够获取接口调用的各种统计信息「比如响应时间的最大值max、最小值min、平均值avg、百分位值percentile、接口调用次数count、频率tps等」，并且支持将统计结果以各种显示格式「比如JSON格式、网页格式、自定义显示格式等」输出到各种终端「Console命令行、HTTP网页、Email、日志文件、自定义输出终端等」，以方便查看。

## 需求分析

性能计数器作为一个跟业务无关的功能，我们完全可以把它开发成一个独立的框架或者类库，集成到很多业务系统中。而作为可复用的框架，除了功能性需求之外，非功能性需求也非常重要。

### 功能性需求分析

> 相对于一大长串的文字描述，人脑更容易理解短的、罗列的比较规整、分门别类的列表信息。

我们需要把需求拆分成一个一个的需求点。

- 接口统计信息：包括接口响应时间的统计信息，以及接口调用次数的统计信息等等。
- 统计信息的类型：max、min、avg、percentile、count、tps等。
- 统计信息显示格式：JSON、HTML、自定义显示格式。
- 统计信息显示终端：Console、Email、HTTP网页、日志、自定义显示终端。

其实，还能挖掘出下面几个隐藏的需求点。

- 统计触发方式：主动和被动都有。

  主动表示以一定的频率定时统计数据，并主动推送到显示终端，比如邮件推送、日志等。

  被动推送表示用户触发统计，比如console命令行，HTTP网页查询。

- 统计时间区间：需要支持自定义统计时间区间。

  比如最近10分钟内某个接口的tps；或者统计12月11日一整天接口响应时间的最大值、最小值、平均值等。

- 统计时间间隔：对于系统主动触发，我们还要支持指定统计时间间隔。

  比如每个10s统计一次接口信息并输出到日志中；每间隔24小时发送一封统计信息邮件。

### 非功能性需求分析

对于这样一个通用的框架开发，我们还需要考虑很多非功能性的需求。

- **易用性**

  **在开发这样一个技术框架的时候，也要有产品意识。**

  框架是否易集成、易插拔、跟业务代码是否松耦合、提供的接口是否够灵活等等，都是应该花心思去思考和设计的。

  有的时候，文档写的好坏甚至都有可能决定一个框架是否受欢迎。

- **性能**

  对于需要集成到业务系统的框架来说，我们**不希望框架本身的代码执行效率，对业务系统有太多性能上的影响。**

  一方面：希望它低延迟，统计代码不影响或很少影响接口本身的相应时间。

  另一方面：希望框架本身对内存的消耗不要太大。

- **扩展性**

  这个扩展性跟代码的可扩展性有点类似，都是指在不修改或尽量少修改代码的情况下添加新的功能。

  但也有差别，代码的可扩展性是从框架代码开发者的角度来说的。

  这里的扩展性是从框架使用者的角度来说的，特指使用者可以在不修改框架源码，甚至在不拿到框架源码的情况下，为框架扩展新的功能。类似给框架开发插件。

  > 比如，`Feign`是一个HTTP客户端框架，我们可以在不修改框架源码的情况下，用下面的方式来扩展自定义的解码方式、日志、拦截等。
  >
  > ```java
  > Feign feign = Feign.builder()
  >         .logger(new CustomizedLogger())
  >         .encoder(new FormEncoder(new JacksonEncoder()))
  >         .decoder(new JacksonDecoder())
  >         .errorDecoder(new ResponseErrorDecoder())
  >         .requestInterceptor(new RequestHeadersInterceptor()).build();
  > 
  > public class RequestHeadersInterceptor implements RequestInterceptor {  
  >   @Override
  >   public void apply(RequestTemplate template) {
  >     template.header("appId", "...");
  >     template.header("version", "...");
  >     template.header("timestamp", "...");
  >     template.header("token", "...");
  >     template.header("idempotent-token", "...");
  >     template.header("sequence-id", "...");
  > }
  > 
  > public class CustomizedLogger extends feign.Logger {
  >   //...
  > }
  > 
  > public class ResponseErrorDecoder implements ErrorDecoder {
  >   @Override
  >   public Exception decode(String methodKey, Response response) {
  >     //...
  >   }
  > }
  > ```

- **容错性**

  这一点非常重要。

  对于性能计数器框架来说，**不能因为框架本身的异常导致接口请求出错**。

  所以，要对框架可能存在的各种异常情况都考虑全面，对外暴露的接口抛出的所有运行时、非运行时异常都进行异常捕获。

- **通用性**

  为了提高框架的复用性，能够灵活应用到各种场景中。

  框架在设计的时候，**要尽可能通用**。

  我们要去思考一下，除了接口统计这样一个需求，还可以适用到哪些其他场景中，比如是否还可以处理其他时间的统计信息，比如SQL请求时间的统计信息、业务统计信息比如支付成功率等等。

## 框架设计

> 对于稍微复杂系统的开发，很多人觉得不知如何开始。
>
> 我个人喜欢**推荐TDD「测试驱动开发」和Prototype「最小原型」的思想，先聚焦于一个简单的应用场景，基于此设计实现一个简单的原型。**这个最小原型系统在功能和非功能特性上当然都不完善，但它看得见、摸得着，比较具体、不抽象，能够很有效地帮助缕清更复杂的设计思路，是迭代设计的基础。
>
> 「就好比做算法题。当我们想要一下子就想出一个最优解法时，可以先写几组测试数据，找找规律，再先像一个最简单的算法去解决它。当然这个最简单的算法在时间、空间、复杂度上都不令人满意，但是我们可以基于此来做优化，这样思路就会更加顺畅。」

对于性能计数器这个框架的开发来说，我们可以先聚焦于一个非常具体、简单的应用场景。

统计用户注册、登录这两个接口的相应时间的最大值和平均值、接口调用次数，并且将统计结果以JSON的格式输出到命令行中。

> 这个需求简单、明确、具体，设计实现起来难度降低很多。

场景代码。

```java
//应用场景：统计下面两个接口(注册和登录）的响应时间和访问次数
public class UserController {
  public void register(UserVo user) {
    //...
  }
  
  public UserVo login(String telephone, String password) {
    //...
  }
}
```

要输出接口的响应时间的最大值、平均值和接口调用次数，首先要采集每次接口请求的响应时间，并且存储起来，然后再按照某个时间间隔做聚合统计，最后才是将结果输出。

在原型系统的代码实现中，可以把所有代码都塞到一个类中，暂时不用考虑任何代码质量、线程安全、性能、扩展性等等问题，怎么简单就怎么来。

```java
public class Metrics {
  // Map的key是接口名称，value对应接口请求的响应时间或时间戳；
  private Map<String, List<Double>> responseTimes = new HashMap<>();
  private Map<String, List<Double>> timestamps = new HashMap<>();
  private ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();

  public void recordResponseTime(String apiName, double responseTime) {
    responseTimes.putIfAbsent(apiName, new ArrayList<>());
    responseTimes.get(apiName).add(responseTime);
  }

  public void recordTimestamp(String apiName, double timestamp) {
    timestamps.putIfAbsent(apiName, new ArrayList<>());
    timestamps.get(apiName).add(timestamp);
  }

  public void startRepeatedReport(long period, TimeUnit unit){
    executor.scheduleAtFixedRate(new Runnable() {
      @Override
      public void run() {
        Gson gson = new Gson();
        Map<String, Map<String, Double>> stats = new HashMap<>();
        for (Map.Entry<String, List<Double>> entry : responseTimes.entrySet()) {
          String apiName = entry.getKey();
          List<Double> apiRespTimes = entry.getValue();
          stats.putIfAbsent(apiName, new HashMap<>());
          stats.get(apiName).put("max", max(apiRespTimes));
          stats.get(apiName).put("avg", avg(apiRespTimes));
        }
  
        for (Map.Entry<String, List<Double>> entry : timestamps.entrySet()) {
          String apiName = entry.getKey();
          List<Double> apiTimestamps = entry.getValue();
          stats.putIfAbsent(apiName, new HashMap<>());
          stats.get(apiName).put("count", (double)apiTimestamps.size());
        }
        System.out.println(gson.toJson(stats));
      }
    }, 0, period, unit);
  }

  private double max(List<Double> dataset) {//省略代码实现}
  private double avg(List<Double> dataset) {//省略代码实现}
}
```

- `recordResponseTime`用来记录接口请求时间
- `recordTimestamp`用来记录接口访问时间
- `startRepeatedReport`以指定频率统计数据并输出结果

那具体的「侵入代码」就是这样。

```java
//应用场景：统计下面两个接口(注册和登录）的响应时间和访问次数
public class UserController {
  private Metrics metrics = new Metrics();
  
  public UserController() {
    metrics.startRepeatedReport(60, TimeUnit.SECONDS);
  }

  public void register(UserVo user) {
    long startTimestamp = System.currentTimeMillis();
    metrics.recordTimestamp("regsiter", startTimestamp);
    //...
    long respTime = System.currentTimeMillis() - startTimestamp;
    metrics.recordResponseTime("register", respTime);
  }

  public UserVo login(String telephone, String password) {
    long startTimestamp = System.currentTimeMillis();
    metrics.recordTimestamp("login", startTimestamp);
    //...
    long respTime = System.currentTimeMillis() - startTimestamp;
    metrics.recordResponseTime("login", respTime);
  }
}
```

最小原型的代码虽然简陋，但它却帮我们将思路理顺了很多，我们现在就基于它做最终的框架设计。

![image-20210901150718387](https://gitee.com/wangigor/typora-images/raw/master/image-20210901150718387.png)

- **数据采集**

  负责打点采集原始数据，包括记录每次接口请求的响应时间和请求时间。

  数据采集过程要高度容错，不能影响到接口本身的可用性。

  除此之外，因为这部分功能是暴露给框架的使用者的，所以在设计数据采集API的时候，我们也要尽量考虑其易用性。

- **存储**

  负责将采集的原始数据保存下来，以便侯曼做聚合统计。

  数据的存储方式有很多种，比如：Redis、Mysql、HBase、日志、文件、内存等。

  数据存储比较耗时，为了尽量地减少对接口性能的影响，采集和存储过程异步完成。

- **聚合统计**

  负责将原始数据聚合为统计数据，比如：max、min、avg、pencentile、count、tps等。

  为了支持更多的聚合统计规则，代码希望尽可能灵活、可扩展。

- **显示**

  负责将统计数据以各种格式显示到终端，比如输出到命令行、邮件、网页、自定义显示终端等。

  

  