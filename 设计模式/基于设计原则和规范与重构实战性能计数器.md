# 基于设计原则和规范与重构实战性能计数器

> 背景。
>
> 我们希望设计开发一个小框架，能够获取接口调用的各种统计信息「比如响应时间的最大值max、最小值min、平均值avg、百分位值percentile、接口调用次数count、频率tps等」，并且支持将统计结果以各种显示格式「比如JSON格式、网页格式、自定义显示格式等」输出到各种终端「Console命令行、HTTP网页、Email、日志文件、自定义输出终端等」，以方便查看。

## 需求分析

性能计数器作为一个跟业务无关的功能，我们完全可以把它开发成一个独立的框架或者类库，集成到很多业务系统中。而作为可复用的框架，除了功能性需求之外，非功能性需求也非常重要。

### 功能性需求分析

> 相对于一大长串的文字描述，人脑更容易理解短的、罗列的比较规整、分门别类的列表信息。

我们需要把需求拆分成一个一个的需求点。

- 接口统计信息：包括接口响应时间的统计信息，以及接口调用次数的统计信息等等。
- 统计信息的类型：max、min、avg、percentile、count、tps等。
- 统计信息显示格式：JSON、HTML、自定义显示格式。
- 统计信息显示终端：Console、Email、HTTP网页、日志、自定义显示终端。

其实，还能挖掘出下面几个隐藏的需求点。

- 统计触发方式：主动和被动都有。

  主动表示以一定的频率定时统计数据，并主动推送到显示终端，比如邮件推送、日志等。

  被动推送表示用户触发统计，比如console命令行，HTTP网页查询。

- 统计时间区间：需要支持自定义统计时间区间。

  比如最近10分钟内某个接口的tps；或者统计12月11日一整天接口响应时间的最大值、最小值、平均值等。

- 统计时间间隔：对于系统主动触发，我们还要支持指定统计时间间隔。

  比如每个10s统计一次接口信息并输出到日志中；每间隔24小时发送一封统计信息邮件。

### 非功能性需求分析

对于这样一个通用的框架开发，我们还需要考虑很多非功能性的需求。

- **易用性**

  **在开发这样一个技术框架的时候，也要有产品意识。**

  框架是否易集成、易插拔、跟业务代码是否松耦合、提供的接口是否够灵活等等，都是应该花心思去思考和设计的。

  有的时候，文档写的好坏甚至都有可能决定一个框架是否受欢迎。

- **性能**

  对于需要集成到业务系统的框架来说，我们**不希望框架本身的代码执行效率，对业务系统有太多性能上的影响。**

  一方面：希望它低延迟，统计代码不影响或很少影响接口本身的相应时间。

  另一方面：希望框架本身对内存的消耗不要太大。

- **扩展性**

  这个扩展性跟代码的可扩展性有点类似，都是指在不修改或尽量少修改代码的情况下添加新的功能。

  但也有差别，代码的可扩展性是从框架代码开发者的角度来说的。

  这里的扩展性是从框架使用者的角度来说的，特指使用者可以在不修改框架源码，甚至在不拿到框架源码的情况下，为框架扩展新的功能。类似给框架开发插件。

  > 比如，`Feign`是一个HTTP客户端框架，我们可以在不修改框架源码的情况下，用下面的方式来扩展自定义的解码方式、日志、拦截等。
  >
  > ```java
  > Feign feign = Feign.builder()
  >         .logger(new CustomizedLogger())
  >         .encoder(new FormEncoder(new JacksonEncoder()))
  >         .decoder(new JacksonDecoder())
  >         .errorDecoder(new ResponseErrorDecoder())
  >         .requestInterceptor(new RequestHeadersInterceptor()).build();
  > 
  > public class RequestHeadersInterceptor implements RequestInterceptor {  
  >   @Override
  >   public void apply(RequestTemplate template) {
  >     template.header("appId", "...");
  >     template.header("version", "...");
  >     template.header("timestamp", "...");
  >     template.header("token", "...");
  >     template.header("idempotent-token", "...");
  >     template.header("sequence-id", "...");
  > }
  > 
  > public class CustomizedLogger extends feign.Logger {
  >   //...
  > }
  > 
  > public class ResponseErrorDecoder implements ErrorDecoder {
  >   @Override
  >   public Exception decode(String methodKey, Response response) {
  >     //...
  >   }
  > }
  > ```

- **容错性**

  这一点非常重要。

  对于性能计数器框架来说，**不能因为框架本身的异常导致接口请求出错**。

  所以，要对框架可能存在的各种异常情况都考虑全面，对外暴露的接口抛出的所有运行时、非运行时异常都进行异常捕获。

- **通用性**

  为了提高框架的复用性，能够灵活应用到各种场景中。

  框架在设计的时候，**要尽可能通用**。

  我们要去思考一下，除了接口统计这样一个需求，还可以适用到哪些其他场景中，比如是否还可以处理其他时间的统计信息，比如SQL请求时间的统计信息、业务统计信息比如支付成功率等等。

