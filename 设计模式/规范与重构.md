# 规范与重构

## 重构

> 「重构」这个词大家都不陌生。
>
> - 大部分人都是『听得多看得少』。
> - 真正进行过代码重构的人不多。
> - **把持续重构作为开发的一部分的人，更是少之又少。**

一方面，**重构代码是对工程师能力的要求，比单纯写代码高得多。**

重构需要能洞察出代码存在的坏味道或者设计上的不足，并且能合理、熟练地利用设计思想、原则、模式、编程规范等理论知识解决这些问题。

另一方面，**对为什么要重构、到底重构什么、什么时候重构、如何重构等相关问题理解不深。**

对重构没有系统性、全局性的认识，面对一堆烂代码，没有重构技巧的指导，只能想到哪改到哪，并不能全面地改善代码质量。

### 为什么要重构

> 软件设计大师Martin Fowler是这样定义重构的：『**重构是一种对软件内部结构的改善，目的是在不改变软件的可见行为的情况下，使其更容易理解，修改成本更低**』。
>
> 这个定义中有一个值得强调的点『重构不改变外部的可见行为』。我们可以把重构理解为，在保持功能不变的前提下，利用设计思想、原则、模式、编程规范等理论来优化代码，修改设计上的不足，提高代码质量。

首先，**重构是时刻保证代码质量的一个极其有效的手段，不至于让代码腐化到无可救药的地步**。

项目在演进，代码在不停的堆砌。如果没有人为代码的质量负责，代码总是会往越来越混乱的方向演化。当混乱到一定程度之后，量变引起质变，项目的维护成本已经高过重新开发一套新代码的成本，想要再去重构，已经没人能够做到了。

其次，**优秀的代码和框架不是一开始就能完全设计好的**。

就像优秀的公司和产品也都是迭代出来的。我们无法100%预见未来的需求，也没有足够的精力、时间、资源为遥远的未来买单。所以随着系统的演进，重构代码是不可避免的。

最后，**重构是避免过度设计的有效手段**。

在我们维护代码的过程中，真正遇到问题的时候再对代码进行重构，能有效避免前期投入太多时间做过度的设计，能够有的放矢。

**除此之代，重构对一个工程师本身技术的成长也有重要的意义。**

- 重构实际上是对我们学习的经典设计思想、设计原则、设计模式、编程规范的一种应用。重构是一个很好的能够锻炼我们熟练使用这些理论知识能力的实践场景。

- 平时堆砌业务逻辑，总会觉得没啥成长。而将一个比较烂的代码重构成一个比较好的代码，会很有成就感。

- 重构能力也是衡量一个工程师代码能力的有效手段。

  所谓「初级工程师在维护代码，高级工程师在设计代码，资深工程师在重构代码」，这句话意思就是说：

  初级工程师在已有代码框架下修改bug，修改添加功能代码。

  高级工程师从零开始设计代码结构、搭建代码框架。

  资深工程师为代码质量负责，需要发掘代码存在的问题，重构代码，时刻保持代码质量处于一个可控的状态。

  > 当然，这里的初级、高级、资深只是一个相对的概念，并不是一个确定的职级。

### 到底重构什么

> 根据重构的规模，可以笼统的分为大规模高层次重构「大重构」和小规模低层次重构「小重构」。

**大重构**，指的是对顶层代码设计的重构。

- 重构目标：包括系统、模块、代码结构、类与类之间的关系等。
- 重构手段：分层、模块化、解耦、抽象可复用组件等等。
- 重构工具：设计思想、设计原则和经典设计模式。

涉及改动代码会比较多，影响面比较大，难度也不较大，耗时会比较长，引入bug的风险也就比较大。

**小重构**，指的是对代码细节的重构。

- 重构目标：主要针对类、函数、变量等代码级别的重构。
- 重构手段：规范命名、规范注释、消除超大类或函数、提取重复代码等等。
- 重构工具：编码规范。

修改的地方比较集中，比较简单，可操作性强，耗时比较短，引入bug的封箱相对来说比较小。

### 什么时候重构

> 是代码烂到一定程度之后才去重构吗？不是。
>
> 当代码真的烂到出现「开发效率低，招了很多人，天天加班，出活却不多，线上bug频发，领导发飙，中层束手无策，工程师抱怨不断，查找bug困难」的时候，基本上重构也无法解决问题了。

平时不注重代码质量，堆砌烂代码，是在维护不了了再大刀阔斧的重构、甚至重写。这样是不行的，有的时候项目代码太多，重构很难做的彻底，最后又搞出来一个「四不像」的怪物，那就更麻烦了。

寄希望于在代码烂到一定程度之后，集中重构解决所有问题是不现实的，我们必须探索一条『**可持续、可演进**』的方式：**==持续重构==**。平时没有事情的时候，看看项目中有哪些写的不够好的、可以优化的代码，主动重构一下。或者，在修改、添加某个功能代码的时候，顺手把不符合编码规范、不好的设计重构一下。就像把单元测试、Code Review作为开发的一部分，我们如果能把持续重构也作为开发的一部分，成为一种开发习惯，对项目、对自己都会很有好处。

**重构的能力很重要，但持续重构的意识更重要**。

技术在更新、需求在变化、人员在流动，代码质量总会下降，代码总会存在不完美，重构就会持续在进行。

时刻具有持续重构意识，才能避免开发初期就过度设计，避免代码维护过程中的质量下降。

而那些看到别人代码有点瑕疵就一顿乱骂，或者花尽心思去构思一个完美设计的人，往往都是因为没有树立正确的代码质量观，没有持续重构意识。

### 如何重构

- 对于大重构来说。

  涉及模块、代码比较多，如果代码质量比较差，耦合比较严重，往往牵一发而动全身。

  > 如果计划一天完成，你会发现越改越多、越改越乱。而新的业务开发又与重构相冲突，最后只能半途而废，revert调所有的改动，很失落的又去堆砌烂代码了。
  >
  
  要提前做好完善的重构计划，有条不紊的分阶段来进行。每个阶段完成一小部分代码的重构，然后提交、测试、运行，发现没有问题之后，再继续进行下一阶段的重构，保证代码仓库的代码一直处于可运行、逻辑正确的状态。每个阶段我们都要控制好重构影响到的代码范围，考虑好如何兼容老代码的逻辑，必须的时候还需要写一些兼容过度代码。
  
  只有这样我们才能让每一阶段的重构不至于耗时太长「最好一天就能完成」，不至于与新功能开发相冲突。
  
  大规模高层次的重构一定是有组织、有计划，并且非常谨慎的，需要有经验、熟悉业务的资深同事来主导。
  
- 对于小重构来说。

  影响范围小，改动耗时短。所以只要有时间且愿意，随时都可以去做。

  除了人工去发现低层次的代码问题，还可以借助很多乘数的静态代码分析工具「比如CheckStyle、FindBugs、PMD、sonar等」来自动发现代码中的问题，然后针对性的进行重构优化。

> 对于重构这件事情，资深的工程师、项目 leader 要负起责任来，没事就重构一下代码，时刻保证代码质量处在一个良好的状态。否则，一旦出现“破窗效应”，一个人往里堆了一些烂代码，之后就会有更多的人往里堆更烂的代码。毕竟往项目里堆砌烂代码的成本太低了。不过，保持代码质量最好的方法还是打造一种好的技术氛围，以此来驱动大家主动去关注代码质量，持续重构代码。

## 单元测试

> 如果面对项目中的烂代码，也像重构一下，但又担心重构之后出问题，出力不讨好。特别是如果重构的是别的同事开发的代码，又不是特别熟悉，在没有任何保障的情况下，重构引入bug的风险还是很大的。
>
> 怎么能够保证重构不出错呢？
>
> 需要账务各种设计原则、思想、模式，还需要对所重构代码和业务有足够的了解。除了这些个人能力因素之外，最可靠的执行、最有效的保证重构不出错的手段应该就是**单元测试**了。
>
> 当重构完成之后，如果新的代码仍然能通过单元测试，那就说明代码原有逻辑的正确性未被破坏，原有的外部可见行为未变，符合重构的定义。

### 什么是单元测试

单元测试由研发工程师自己编写，用来测试自己写的代码的正确性。

> 常常将它跟基层测试放到一块对比，单元测试相对于集成测试来说，测试的粒度更小。继承测试的测试对象是整个系统或者某个功能模块，比如测试用户注册、登录功能是否正常，以一种端到端「end to end」的测试。而单元测试的测试对象是类或者函数，用来测试这个类和函数是否都按照预期的逻辑执行。
>
> 这是代码层级的测试。

举个例子。

```java
public class Text {
  private String content;

  public Text(String content) {
    this.content = content;
  }

  /**
   * 将字符串转化成数字，忽略字符串中的首尾空格；
   * 如果字符串中包含除首尾空格之外的非数字字符，则返回null。
   */
  public Integer toNumber() {
    if (content == null || content.isEmpty()) {
      return null;
    }
    //...省略代码实现...
    return null;
  }
}
```

如果我们要测试`Test`类中的`toNumber()`函数的正确定，应该如何编写单元测试呢？

> 写单元测试本身不需要什么高深技术。
>
> 它更多的是考研程序员思维的缜密程度，看能否设计出覆盖各种正常及异常情况的测试用例，来保证代码在任何预期或非预期的情况下都能正确运行。

为了保证测试的全面性，针对`toNumber()`函数，我们需要设计下面几个测试用例。

- 如果字符串只包含数字：”123“，输出对应的整数：123。
- 如果字符串为空或者null，输出null。
- 如果字符串首尾有空格：” 123“/"123 "/" 123 "，输出对应的整数：123。
- 如果字符串包含多个首尾空格：”   123    “，输出对应的整数：123。
- 如果字符串包含非数字字符：”123a4“/"123 4"，输出null。

剩下的就是将其翻译成代码了。

```java

public class Assert {
  public static void assertEquals(Integer expectedValue, Integer actualValue) {
    if (actualValue != expectedValue) {
      String message = String.format(
              "Test failed, expected: %d, actual: %d.", expectedValue, actualValue);
      System.out.println(message);
    } else {
      System.out.println("Test succeeded.");
    }
  }

  public static boolean assertNull(Integer actualValue) {
    boolean isNull = actualValue == null;
    if (isNull) {
      System.out.println("Test succeeded.");
    } else {
      System.out.println("Test failed, the value is not null:" + actualValue);
    }
    return isNull;
  }
}

public class TestCaseRunner {
  public static void main(String[] args) {
    System.out.println("Run testToNumber()");
    new TextTest().testToNumber();

    System.out.println("Run testToNumber_nullorEmpty()");
    new TextTest().testToNumber_nullorEmpty();

    System.out.println("Run testToNumber_containsLeadingAndTrailingSpaces()");
    new TextTest().testToNumber_containsLeadingAndTrailingSpaces();

    System.out.println("Run testToNumber_containsMultiLeadingAndTrailingSpaces()");
    new TextTest().testToNumber_containsMultiLeadingAndTrailingSpaces();

    System.out.println("Run testToNumber_containsInvalidCharaters()");
    new TextTest().testToNumber_containsInvalidCharaters();
  }
}

public class TextTest {
  public void testToNumber() {
    Text text = new Text("123");
    Assert.assertEquals(123, text.toNumber());
  }

  public void testToNumber_nullorEmpty() {
    Text text1 = new Text(null);
    Assert.assertNull(text1.toNumber());

    Text text2 = new Text("");
    Assert.assertNull(text2.toNumber());
  }

  public void testToNumber_containsLeadingAndTrailingSpaces() {
    Text text1 = new Text(" 123");
    Assert.assertEquals(123, text1.toNumber());

    Text text2 = new Text("123 ");
    Assert.assertEquals(123, text2.toNumber());

    Text text3 = new Text(" 123 ");
    Assert.assertEquals(123, text3.toNumber());
  }

  public void testToNumber_containsMultiLeadingAndTrailingSpaces() {
    Text text1 = new Text("  123");
    Assert.assertEquals(123, text1.toNumber());

    Text text2 = new Text("123  ");
    Assert.assertEquals(123, text2.toNumber());

    Text text3 = new Text("  123  ");
    Assert.assertEquals(123, text3.toNumber());
  }

  public void testToNumber_containsInvalidCharaters() {
    Text text1 = new Text("123a4");
    Assert.assertNull(text1.toNumber());

    Text text2 = new Text("123 4");
    Assert.assertNull(text2.toNumber());
  }
}
```

这里没有使用任何测试框架。

### 为什么要写单元测试

> 单元测试除了能有效的为重构保驾护航之外，也是保证代码质量最有效的手段之一。

#### 单元测试能有效地帮你发现代码中的bug

能否写出`bug free`的代码，是判断工程师代码能力的重要标准之一。

> 在离开 Google 之后，尽管我「王争」就职的很多公司，其开发模式都是“快、糙、猛”，对单元测试根本没有要求，但我还是坚持为自己提交的每一份代码，都编写完善的单元测试。**得益于此，我写的代码几乎是 bug free 的。这也节省了我很多 fix 低级 bug 的时间，能够有时间去做其他更有意义的事情，我也因此在工作上赢得了很多人的认可。**可以这么说，坚持写单元测试是保证我的代码质量的一个“杀手锏”，也是帮助我拉开与其他人差距的一个“小秘密”。

#### 写单元测试能帮你发现代码设计上的问题

> 前面提到，代码的可测试性是判断代码质量的一个重要标准。

对于一段代码，如果很难为其编写单元测试，或者单元测试写起来很吃力，需要依靠单元测试框架里很高级的特性才能完成，那往往意味着代码设计的不够合理，比如，没有使用依赖注入、大量使用静态函数、全局变量、代码高度耦合等。

#### 单元测试是对集成测试的有力补充

**程序运行的bug往往出现在一些边界条件、异常情况下。**比如除数未判空、网络超时。而大部分异常情况都比较难在测试环境中模拟。而单元测试可以利用mock的方式，控制mock的代码返回我们需要模拟的异常，来测试代码在这些异常情况的表现。

除此之外，**对于一些复杂系统来说，集成测试无法覆盖全面**。复杂系统往往有很多模块，每个模块都有各种输入、输出、异常情况，组合起来整个系统就有无数测试场景需要模拟，无数的测试用例需要设计，在强大的测试团队也无法穷举完备。

尽管单元测试无法完全替代集成测试，但如果我们能保证每个类、每个函数都能按照我们的预期执行，底层bug少了，那组装起来的整个系统，出问题的概率也就相应减少了。

#### 写单元测试的过程本身就是代码重构的过程

> 前面提到，要把持续重构作为开发的一部分执行，那写单元测试实际上就是落地执行持续重构的一个有效途径。

设计和实现代码的时候，很难把所有问题都想清楚。而编写单元测试就相当于对代码的一次自我code review。

在这个过程中，或许可以发现一些设计上的问题「比如代码设计的不可测试」以及代码编写方便的问题「比如一些边界条件处理不当」等，然后针对性的进行重构。

#### 阅读单元测试能帮助你快速熟悉代码

> 阅读代码最有效的手段，就是先去了解它的业务背景和设计思路，然后再去看代码，这样代码读起来就会轻松很多。

但是，很多程序员都不怎么喜欢写文档和注释，而大部分代码又很难做到『不言自明』。在没有文档和注释的情况下，单元测试就起到了替代性作用。

**单元测试用例实际上就是用户用例，反映了代码的功能和如何使用。**借助单元测试，我们不需要深入的阅读代码，便能知道代码实现了什么功能，有哪些特殊情况需要考虑，有哪些边界条件需要处理。

#### 单元测试是TDD可落地执行的改进方案

> 测试驱动开发「Test-Driven Development 简称TDD」是一个经常被提及但很少被执行的开发模式。
>
> 核心思想就是测试用例先于代码编写。
>
> 不过执行下去挺难得，毕竟如果连单元测试都懒得写，更何况在编写代码之前先写好测试用例了。

单元测试正好是对TDD的一种改进方案，先写代码，紧接着写单元测试，然后根据单元测试返回出来的问题，再回头去重构代码。这个开发流程就很容易被接收，更加容易落地执行，并且又兼顾了TDD的优点。

### 如何编写单元测试

> 写单元测试就是针对代码设计覆盖各种输入、异常、边界条件的测试用例，并将这些测试用例翻译成代码的过程。

在把测试用例翻译成代码的时候，我们可以利用单元测试框架，来简化测试代码的编写。

比如，Junit、TestNG、Spring Test等。这些框架提供了通用的执行流程「比如执行测试用例的TestCaseRunner」和工具类库「比如各种Assert判断函数」，在编写测试代码的时候，只需要关注测试用例本身的编写即可。

还是以之前的`Test.toNumber()`为例，使用Junit单元测试框架重新实现以下。

```java

import org.junit.Assert;
import org.junit.Test;

public class TextTest {
  @Test
  public void testToNumber() {
    Text text = new Text("123");
    Assert.assertEquals(new Integer(123), text.toNumber());
  }

  @Test
  public void testToNumber_nullorEmpty() {
    Text text1 = new Text(null);
    Assert.assertNull(text1.toNumber());

    Text text2 = new Text("");
    Assert.assertNull(text2.toNumber());
  }

  @Test
  public void testToNumber_containsLeadingAndTrailingSpaces() {
    Text text1 = new Text(" 123");
    Assert.assertEquals(new Integer(123), text1.toNumber());

    Text text2 = new Text("123 ");
    Assert.assertEquals(new Integer(123), text2.toNumber());

    Text text3 = new Text(" 123 ");
    Assert.assertEquals(new Integer(123), text3.toNumber());
  }

  @Test
  public void testToNumber_containsMultiLeadingAndTrailingSpaces() {
    Text text1 = new Text("  123");
    Assert.assertEquals(new Integer(123), text1.toNumber());

    Text text2 = new Text("123  ");
    Assert.assertEquals(new Integer(123), text2.toNumber());

    Text text3 = new Text("  123  ");
    Assert.assertEquals(new Integer(123), text3.toNumber());
  }

  @Test
  public void testToNumber_containsInvalidCharaters() {
    Text text1 = new Text("123a4");
    Assert.assertNull(text1.toNumber());

    Text text2 = new Text("123 4");
    Assert.assertNull(text2.toNumber());
  }
}
```

代码简化了很多。

- **写单元测试真的是件很耗时的事情吗？**

  尽管单元测试的代码量可能是被测试代码本身的1~2呗，写的过程很繁琐。但并不是很耗时，因为不需要考虑太多代码设计上的问题，测试代码实现起来比较简单。

  不同测试用例之间的代码差异可能不大，简单cv改改就行。

- **对单元测试的代码质量有什么要求吗？**

  单元测试代码不会在产线上运行，而且每个类的测试代码也比较独立，基本不互相依赖。

  所以相对于被测代码，单元测试代码的质量可以放低一些要求。命名稍微不规范、代码稍微有重复，也都不是什么大问题。

- **单元测试只要覆盖率高就够了吗？**

  单元测试覆盖率是比较容易量化的指标，常常作为单元测试写的好坏的评判标准。

  有很多线程的工具专门用来做覆盖率的统计，比如JaCoCo、Cobertura、Emma、Clover。覆盖率的计算方式有很多种，计较简单的是语句覆盖，稍微高级点的有：条件覆盖、判断覆盖、路径覆盖。

  不管覆盖率的计算方式如何高级，**将覆盖率作为衡量单元测试质量的唯一标准是不合理的。**

  比如：

  ```java
  public double cal(double a, double b) {
    if (b != 0) {
      return a / b;
    }
  }
  ```

  可以很容易做到100%覆盖率，比如`call(2.0,1.0)`。但并不代表测试足够全面了「还需要考虑除数为0的情况」。

  再比如，getter/setter方法，没有必要测试。

  从过往的经验上来讲，一个项目的单元测试覆盖率在 60～70% 即可上线。如果项目对代码质量要求比较高，可以适当提高单元测试覆盖率的要求。

- **写单元测试需要了解代码的实现逻辑吗？**

  单元测试不要依赖被测试函数的具体实现逻辑，只需要关心被测函数实现了什么功能。

  否则，针对实现逻辑编写单元测试，一旦代码重构，在代码外部行为不变的情况下，对代码的实现逻辑进行了修改，那原本的单元测试都会运行失败，也就起不到保驾护航的作用了。

- **如果选择单元测试框架？**

  单元测试本身不需要复杂计数，大部分单元测试框架都能满足。

  团队内部统一就行。

  如果自己写的代码用已经选定的单元测试框架无法测试，多半是代码写的不够好，代码的可测试性不够好。重构代码，让其容易测试，而不是去找另一个更加高级的单元测试框架。

### 单元测试为何难落地

> 虽然很多书籍中都会讲到，单元测试是保证重构不出错的有效手段；也有非常多人已经认识到单元测试的重要性。
>
> 但是有多少项目有完善的、高质量的单元测试呢？据我了解，真的非常非常少，包括 BAT 这样级别公司的项目。如果不相信的话，你可以去看一下国内很多大厂开源的项目，有很多项目完全没有单元测试，还有很多项目的单元测试写得非常不完备，仅仅测试了逻辑是否运行正确而已。所以，100% 落实执行单元测试是件“知易行难”的事。

写单元测试确实是一件考验耐心的活儿。一般情况下，单元测试的代码量要大于被测试代码量，甚至是要多出好几倍。很多人往往会觉得写单元测试比较繁琐，并且没有太多挑战，而不愿意去做。有很多团队和项目在刚开始推行单元测试的时候，还比较认真，执行得比较好。**但当开发任务紧了之后，就开始放低对单元测试的要求，一旦出现破窗效应，慢慢的，大家就都不写了，这种情况很常见。**

还有一种情况就是，由于历史遗留问题，原来的代码都没有写单元测试，代码已经堆砌了十几万行了，不可能再一个一个去补单元测试。这种情况下，**我们首先要保证新写的代码都要有单元测试，其次，每次在改动到某个类时，如果没有单元测试就顺便补上，不过这要求工程师们有足够强的主人翁意识（ownership），毕竟光靠 leader 督促，很多事情是很难执行到位的。**

除此之外，还有人觉得，有了测试团队，写单元测试就是浪费时间，没有必要。程序员这一行业本该是智力密集型的，但现在很多公司把它搞成劳动密集型的，包括一些大厂，在开发过程中，既没有单元测试，也没有 Code Review 流程。即便有，做的也是差强人意。写好代码直接提交，然后丢给黑盒测试狠命去测，测出问题就反馈给开发团队再修改，测不出的问题就留在线上出了问题再修复。

**在这样的开发模式下，团队往往觉得没有必要写单元测试，但如果我们把单元测试写好、做好 Code Review，重视起代码质量，其实可以很大程度上减少黑盒测试的投入。**我在 Google 的时候，很多项目几乎没有测试团队参与，代码的正确性完全靠开发团队来保障，线上 bug 反倒非常少。

现在互联网信息如此的公开透明，网上有很多文章可以参考，对于程序员这个具有很强学习能力的群体来说，学会如何写单元测试并不是一件难事，难的是能够真正感受到它的作用，并且打心底认可、能 100% 落地执行。

## 代码的可测试性

> 写单元测试并不难，也不需要太多技巧，相反，写出可测试的代码反倒是件非常有挑战的事情。

### 编写可测试代码案例实战

`Transaction`是经过抽象简化之后的一个电商系统的交易类，用来记录每笔订单交易的情况。

`execute()`函数负责执行转账操作，将钱从买家的钱包`buyerId`转到卖家的钱包`sellerId`中。

真正的转账操作是通过调用`WalletRpcService`远程调用服务来完成的。

代码中还涉及到一个分布式锁`DistributedLock`单例类，用来避免并发操作，导致用户的钱被重复转出。

```java
public class Transaction {
  private String id;
  private Long buyerId;
  private Long sellerId;
  private Long productId;
  private String orderId;
  private Long createTimestamp;
  private Double amount;
  private STATUS status;
  private String walletTransactionId;
  
  // ...get() methods...
  
  public Transaction(String preAssignedId, Long buyerId, Long sellerId, Long productId, String orderId) {
    if (preAssignedId != null && !preAssignedId.isEmpty()) {
      this.id = preAssignedId;
    } else {
      this.id = IdGenerator.generateTransactionId();
    }
    if (!this.id.startWith("t_")) {
      this.id = "t_" + preAssignedId;
    }
    this.buyerId = buyerId;
    this.sellerId = sellerId;
    this.productId = productId;
    this.orderId = orderId;
    this.status = STATUS.TO_BE_EXECUTD;
    this.createTimestamp = System.currentTimestamp();
  }
  
  public boolean execute() throws InvalidTransactionException {
    if ((buyerId == null || (sellerId == null || amount < 0.0) {
      throw new InvalidTransactionException(...);
    }
    if (status == STATUS.EXECUTED) return true;
    boolean isLocked = false;
    try {
      isLocked = RedisDistributedLock.getSingletonIntance().lockTransction(id);
      if (!isLocked) {
        return false; // 锁定未成功，返回false，job兜底执行
      }
      if (status == STATUS.EXECUTED) return true; // double check
      long executionInvokedTimestamp = System.currentTimestamp();
      if (executionInvokedTimestamp - createdTimestap > 14days) {
        this.status = STATUS.EXPIRED;
        return false;
      }
      WalletRpcService walletRpcService = new WalletRpcService();
      String walletTransactionId = walletRpcService.moveMoney(id, buyerId, sellerId, amount);
      if (walletTransactionId != null) {
        this.walletTransactionId = walletTransactionId;
        this.status = STATUS.EXECUTED;
        return true;
      } else {
        this.status = STATUS.FAILED;
        return false;
      }
    } finally {
      if (isLocked) {
       RedisDistributedLock.getSingletonIntance().unlockTransction(id);
      }
    }
  }
}
```

对比之前`Test`类的代码，这段代码要复杂很多。

- 正常情况下，交易成功。回填`walletTransactionId`、交易状态为`STATUS.EXECUTED`、返回true。
- `buyerId、sellerId`为空，`amount`小于0。抛出`InvalidTransactionException异常`
- 交易已过期「`createdTimestamp`超过14天」。交易状态为`STATUS.EXPIRED`，返回false。
- 交易重复执行「状态为`STATUS.EXECUTED`」,不在重复执行赚钱逻辑，直接返回true。
- 钱包转账RPC远程调用`WalletRpcService`失败。交易状态为`STATUS.FAILED`，返回false。
- 交易重复执行且未完成「获取分布式锁失败」。直接失败，返回false。

测试用例设计完了，但是测试用例落实到具体代码却很难。比如要编写测试用例1的代码实现：

```java
public void testExecute() {
  Long buyerId = 123L;
  Long sellerId = 234L;
  Long productId = 345L;
  Long orderId = 456L;
  Transction transaction = new Transaction(null, buyerId, sellerId, productId, orderId);
  boolean executedResult = transaction.execute();
  assertTrue(executedResult);
}
```

因为`execute()`函数依赖两个外部服务：`RedisDistributedLock`和`WalletRpcService`，会导致以下几个问题。

- 如果要让这个单元测试能够运行，我们需要搭建这两个外部服务，搭建和维护的成本比较高。

  而且对于单元测试来说没有必要。

- 如果我们需要保证将伪造的交易数据发送给远程服务之后，能够返回期望的结构，然而这个服务可能是第三方接口，对于我们来说并不可控。

- 远程调用需要走网络，耗时可能会比较长。对这个单元测试的执行性能也会有影响。

- 网络中断、超时、外部服务不可用，都会影响单元测试的执行结果。

然而**单元测试主要是测试程序员自己编写的代码逻辑的正确性，并非是端到端的集成测试，他不需要测试依赖的外部系统的逻辑正确性。**所以，如果代码中依赖了外部系统或者不可控组件，比如数据库、网络通信、文件系统等，我们就需要将这些被测代码与外部系统解依赖，这种解依赖的方法叫做**mock**。所谓mock就是用一个「假」服务替换真正的外部服务。mock服务完全在我们的控制之下，模拟输出我们想要的数据。

> mock方式有两种：**手动mock**和**利用框架mock**。
>
> 利用框架mock仅仅是为了简化代码编写，每个框架的mock方式不同。
>
> 常用的mock框架有：**Mockito**和**PowerMock**。
>
> **Mockito**是一个优秀的、最常用的单元测试mock框架，它能满足大部分时间的测试要求（public方法）。
>
> **PowerMock**可以去解决一些更难的问题（比如静态方法、私有方法、Final方法等），它是在 EasyMock 以及 Mockito 基础上的扩展，通过提供定制的类加载器以及一些字节码篡改，实现更强大的测试功能。

手动mock是通过继承，重写服务类来完成的。比如`WalletRpcService.moveMoney()`的mock：

```java
public class MockWalletRpcServiceOne extends WalletRpcService {
  public String moveMoney(Long id, Long fromUserId, Long toUserId, Double amount) {
    return "123bac";
  } 
}

public class MockWalletRpcServiceTwo extends WalletRpcService {
  public String moveMoney(Long id, Long fromUserId, Long toUserId, Double amount) {
    return null;
  } 
}
```

新的问题就来了：`execute()`函数内部通过new方式创建的`WalletRpcService`，没办法进行动态替换。

这就说明了`Transaction`的可测试性差，需要通过依赖注入进行重构。

将`WalletRpcService`对象的创建反转给上层逻辑，在外部创建好之后，再注入到`Transaction`对象中。

```java
public class Transaction {
  //...
  // 添加一个成员变量及其set方法
  private WalletRpcService walletRpcService;
  
  public void setWalletRpcService(WalletRpcService walletRpcService) {
    this.walletRpcService = walletRpcService;
  }
  // ...
  public boolean execute() {
    // ...
    // 删除下面这一行代码
    // WalletRpcService walletRpcService = new WalletRpcService();
    // ...
  }
}
```

进行了这一步重构之后，测试代码就可以写成

```java
public void testExecute() {
  Long buyerId = 123L;
  Long sellerId = 234L;
  Long productId = 345L;
  Long orderId = 456L;
  Transction transaction = new Transaction(null, buyerId, sellerId, productId, orderId);
  // 使用mock对象来替代真正的RPC服务
  transaction.setWalletRpcService(new MockWalletRpcServiceOne()):
  boolean executedResult = transaction.execute();
  assertTrue(executedResult);
  assertEquals(STATUS.EXECUTED, transaction.getStatus());
}
```

这是`WalletRpcService`的mock替换问题。再来看`RedisDistributedLock`。

`RedisDistributedLock`是一个单例类。相当于一个全局变量，我们无法继承或重写方法，也无法通过依赖注入的方式替换它。

如果这个服务使我们自己维护的，可以自由修改、重构。那可以将它改为非单例的模式，或者定义一个接口比如`IDistributedLock`，让`RedisDistributedLock`实现这个接口。我们就能通过上面的方式重写这个接口的mock实现了。

但如果这不是我们维护的，无权修改这一部分代码。

我们还可以对上锁逻辑进行重新封装，使代码可测试性更好。

```java
public class TransactionLock {
  public boolean lock(String id) {
    return RedisDistributedLock.getSingletonIntance().lockTransction(id);
  }
  
  public void unlock() {
    RedisDistributedLock.getSingletonIntance().unlockTransction(id);
  }
}

public class Transaction {
  //...
  private TransactionLock lock;
  
  public void setTransactionLock(TransactionLock lock) {
    this.lock = lock;
  }
 
  public boolean execute() {
    //...
    try {
      isLocked = lock.lock(id);
      //...
    } finally {
      if (isLocked) {
        lock.unlock(id);
      }
    }
    //...
  }
}
```

重构之后，测试用例就变成了下面这样。

```java
public void testExecute() {
  Long buyerId = 123L;
  Long sellerId = 234L;
  Long productId = 345L;
  Long orderId = 456L;
  
  TransactionLock mockLock = new TransactionLock() {
    public boolean lock(String id) {
      return true;
    }
  
    public void unlock() {}
  };
  
  Transction transaction = new Transaction(null, buyerId, sellerId, productId, orderId);
  transaction.setWalletRpcService(new MockWalletRpcServiceOne());
  transaction.setTransactionLock(mockLock);
  boolean executedResult = transaction.execute();
  assertTrue(executedResult);
  assertEquals(STATUS.EXECUTED, transaction.getStatus());
}
```

至此，测试用例1就写好了，我们通过代码重构「依赖注入」和mock，让单元测试代码不依赖任何外部不可控接口。那测试用例4、5、6都可以依此完成。

还有一个测试用例3的问题：交易过期「`createTimestamp`超过14天」。

```java
public void testExecute_with_TransactionIsExpired() {
  Long buyerId = 123L;
  Long sellerId = 234L;
  Long productId = 345L;
  Long orderId = 456L;
  Transction transaction = new Transaction(null, buyerId, sellerId, productId, orderId);
  //手动设置createdTimestamp
  transaction.setCreatedTimestamp(System.currentTimestamp() - 14days);
  boolean actualResult = transaction.execute();
  assertFalse(actualResult);
  assertEquals(STATUS.EXPIRED, transaction.getStatus());
}
```

但是，如果`createdTimestamp`没有暴露`setter`方法，而且不暴露是更符合业务场景的选择。因为这个字段理应在构造函数中，随对象创建自动生成，不应该人为修改。所以通过set方式重设createdTimestamp是不可能的。

> 这类问题也比较常见，就是**代码中包含跟「时间」有关的「未决行为」逻辑**。一般的处理方式就是将这种未决行为逻辑重新封装。

针对`Transaction`类，需要将「交易是否过期」的逻辑，封装到`isExired()`函数中。

```java
public class Transaction {

  protected boolean isExpired() {
    long executionInvokedTimestamp = System.currentTimestamp();
    return executionInvokedTimestamp - createdTimestamp > 14days;
  }
  
  public boolean execute() throws InvalidTransactionException {
    //...
      if (isExpired()) {
        this.status = STATUS.EXPIRED;
        return false;
      }
    //...
  }
}
```

测试用例3就变成了下面这样。

```java
public void testExecute_with_TransactionIsExpired() {
  Long buyerId = 123L;
  Long sellerId = 234L;
  Long productId = 345L;
  Long orderId = 456L;
  //匿名内部类
  Transction transaction = new Transaction(null, buyerId, sellerId, productId, orderId) {
    protected boolean isExpired() {
      return true;
    }
  };
  boolean actualResult = transaction.execute();
  assertFalse(actualResult);
  assertEquals(STATUS.EXPIRED, transaction.getStatus());
}
```

这个过期问题的测试用例就解决了。

还有问题吗？

可以有。比如构造函数中交易id的赋值逻辑中，`IdGenerator.generateTransactionId()`不知道是干什么的，或许会存在问题，最好也要测试一下。

为了保证这一部分逻辑的正确性和方便测试，可以把id赋值这部分逻辑单独抽象到一个函数中。

```java
  public Transaction(String preAssignedId, Long buyerId, Long sellerId, Long productId, String orderId) {
    //...
    fillTransactionId(preAssignId);
    //...
  }
  
  protected void fillTransactionId(String preAssignedId) {
    if (preAssignedId != null && !preAssignedId.isEmpty()) {
      this.id = preAssignedId;
    } else {
      this.id = IdGenerator.generateTransactionId();
    }
    if (!this.id.startWith("t_")) {
      this.id = "t_" + preAssignedId;
    }
  }
```

如果这个被测试方法不是`public`的，而是`private/protected`的。怎么测试？

如果你看过guava源码，就会发现一个很好用的注解`@VisibleForTesting`。可以解决这样的问题。

> 实际上，可测试性差的代码，本身代码设计得也不够好，很多地方都没有遵守我们之前讲到的设计原则和思想，比如“基于接口而非实现编程”思想、依赖反转原则等。重构之后的代码，不仅可测试性更好，而且从代码设计的角度来说，也遵从了经典的设计原则和思想。这也印证了我们之前说过的，代码的可测试性可以从侧面上反应代码设计是否合理。除此之外，在平时的开发中，我们也要多思考一下，这样编写代码，是否容易编写单元测试，这也有利于我们设计出好的代码。

### 常见反模式「anti-patterns」

> 经典的、常见的可测试性不好的代码总结。

#### 未决行为

未决行为逻辑就是，代码的输出是随机或者说不确定的，比如跟时间、随机数有关的代码。

可以抽成函数。

#### 全局变量

滥用全局变量也让编写单元测试变得困难。

比方说，`RangeLimiter`是一个[ -5 , 5 ]区间，初始化位置`position`在0，`move()`函数负责移动`position`返回是否移动出规定区间。

```java
public class RangeLimiter {
  private static AtomicInteger position = new AtomicInteger(0);
  public static final int MAX_LIMIT = 5;
  public static final int MIN_LIMIT = -5;

  public boolean move(int delta) {
    int currentPos = position.addAndGet(delta);
    boolean betweenRange = (currentPos <= MAX_LIMIT) && (currentPos >= MIN_LIMIT);
    return betweenRange;
  }
}

public class RangeLimiterTest {
  public void testMove_betweenRange() {
    RangeLimiter rangeLimiter = new RangeLimiter();
    assertTrue(rangeLimiter.move(1));
    assertTrue(rangeLimiter.move(3));
    assertTrue(rangeLimiter.move(-5));
  }

  public void testMove_exceedRange() {
    RangeLimiter rangeLimiter = new RangeLimiter();
    assertFalse(rangeLimiter.move(6));
  }
}
```

`position`是类的静态变量，对于测试方法`testMove_betweenRange`和`testMove_exceedRange`来说，虽然都是`new RangeLimiter()`，但是共用`position`。那**单元测试结果可能会受到测试框架的影响**。

比如单元测试框架顺序执行两个测试用例：用例1执行完之后`position`值是-1，再执行用例2的时候，`position`值是5，返回true。用例2就运行失败了。

那，如果在每个测试用例之前都对`position`进行「清零」操作，可以解决上面的问题，但是无法解决并发问题。

比如单元测试框架是并行执行所有测试用例，即便每次都清零，16、17、18跟23行代码会存在并发问题，影响测试结果。

#### 静态方法

很难mock。

#### 复杂继承

相比组合关系，继承关系的代码结构更加耦合、不灵活、更加不易扩展、不易维护。实际上，继承关系也很难测试。

如果父类需要mock某一个依赖对象才能进行单元测试，那所有的子类、子类的子类……在编写单元测试的时候都要mock这个依赖对象。对于继承层次很深「纵向」、结构复杂「横向」的继承关系，继承越深的子类要mock的对象可能就会越多，这样就会导致，子类单元测试编写的时候，需要mock很多父类依赖对象，而且需要查看父类代码，去了解如何mock这些依赖。

如果我们利用组合而非继承，类之间的结构层次比较扁平，在编写单元测试的时候，只需要mock类所依赖的对象就行。

#### 高耦合代码

如果一个类的职责很重，需要依赖十几个外部对象才能完成工作，代码高度耦合。

那在编写单元测试的时候，可能需要mock十几个依赖对象。

不管是从代码设计的角度来说，还是从编写单元测试的角度来说，都是不合理的。

## 解耦

> 重构可以分为大重构和小重构。
>
> 大重构是对系统、模块、代码结构、类之间关系等顶层代码设计进行的重构。
>
> 对于大重构来说，解耦是最有效的手段。

解耦的目的是实现代码高内聚、松耦合。

### 解耦为何如此重要

> 软件设计与开发最重要的工作之一就是应对复杂性。人处理复杂性的能力是有限的。
>
> 过于复杂的代码往往在可读性、可维护性上都不友好。

解耦可以保证代码松耦合、高内聚。

如果说重构是保证代码质量不至于腐化到无可救药地步的有效手段。那么解耦，就是保证代码不至于复杂到无法控制的有效手段。

- 不管是阅读代码还是修改代码。「高内聚、松耦合」的特性可以让我们聚焦在某一模块或类中，不需要了解太多其他模块或类的代码，让我们的焦点不至于过于发散，降低阅读和修改代码的难度。

- 而且，因为依赖关系简单，耦合小，修改代码不至于牵一发而动全身，代码改动比较集中，引入bug的风险也就减少了很多。

- 同时『高内聚、松耦合』的代码可测试性也更加好，容易mock或者减少需要mock外部依赖的类或模块。

- 代码结构清晰、分层和模块化合理、依赖关系简单、模块和类之间的耦合小，整体代码质量就不会差。

  即使某个具体的类或模块设计不合理，代码质量不怎么搞，影响的范围也非常有限。只要聚焦于这个类或者模块，做相应的小重构就好。

### 代码是否需要解耦

那。如何判断系统需要解耦重构呢？

间接的衡量标准很多，前面提到过，比如看修改代码会不会牵一发而动全身。

除此之外，还有一个直接的衡量标准，那就是**把模块与模块之间、类与类之间的依赖关系画出来，根据依赖关系图的复杂性判断是否需要解耦重构。**

如果依赖关系复杂、混乱，那从代码结构上来讲，可读性和可维护性肯定不好，那就需要考虑是否可以通过解耦的方式，让依赖关系变得清晰、简单。

当然这种判断有比较强的主观色彩，但是可以作为一种参考和梳理依赖的手段，配合简介的衡量标准一起使用。

### 如果给代码解耦

#### 封装和抽象

封装和抽象是两个非常通用的设计思想，可以应用到很多设计场景中，比如系统、模块、lib、组件、接口、类等的设计。封装和抽象可以有效的隐藏实现的复杂性，隔离实现的异变性，给依赖的模块提供稳定且易用的抽象接口。

> 比如，Unix系统提供的open()文件操作函数，用起来非常简单，但是底层实现却非常复杂，涉及权限控制、并发控制、物理存储等等。通过将其封装成一个抽象的open函数，能够有效控制代码复杂性的蔓延，将复杂性封装在局部代码中。
>
> 除此之外，因为open()函数基于抽象而非具体的实现来定义，所以再改动open()函数的底层实现的时候，并不需要改动依赖它的上层代码。

#### 中间层

引入中间层能够简化模块或类之间的依赖关系。如下图。

![image-20210827152141559](https://wangigor-typora-images.oss-cn-chengdu.aliyuncs.com/image-20210827152141559.png)

除此之外，在进行重构的时候，引入中间层可以起到过度的作用，能够让开发和重构同步进行，不互相干扰。

> 比如，某个接口设计的有问题，我们需要修改他的定义，同时所有调用这个接口的代码都要做响应的改动。
>
> 如果新开发的代码也用到这个接口，那开发就跟重构冲突了。
>
> 为了让重构能小步快跑，可以分下面四个阶段来完成接口的修改。
>
> - 引入一个中间层，包裹老的接口，提供新的接口定义。
> - 新开发的代码依赖中间层提供的新接口。
> - 将依赖老街口的代码改为调用新接口。
> - 确保所有代码都调用新接口之后，删除掉老接口。
>
> 这样每个阶段的开发量都不会很大，可以很短的时间内完成。重构跟开发冲突的概率也就变小了。

#### 模块化

模块化是构建复杂系统常用的手段。

对于一个大型复杂系统来说，没人能掌握所有细节。之所以能搭建出复杂的系统，并且能够维护得了，主要原因就是将系统划分成各个独立的模块，让不同的人负责不同的模块，这样即使在不了解全部细节的情况下，管理者也能协调各个模块，让整个系统有效运转。

> 聚焦到软件开发上面，很多大型软件（比如 Windows）之所以能做到几百、上千人有条不紊地协作开发，也归功于模块化做得好。不同的模块之间通过 API 来进行通信，每个模块之间耦合很小，每个小的团队聚焦于一个独立的高内聚模块来开发，最终像搭积木一样将各个模块组装起来，构建成一个超级复杂的系统。

我们再聚焦到代码层面。合理地划分模块能有效地解耦代码，提高代码的可读性和可维护性。所以，我们在开发代码的时候，一定要有模块化意识，将每个模块都当作一个独立的 lib 一样来开发，只提供封装了内部实现细节的接口给其他模块使用，这样可以减少不同模块之间的耦合度。

实际上，模块化的思想无处不在，想SOA、微服务、lib库、系统内模块划分，甚至类、函数的设计，都体现了模块化思想。

如果追本溯源，模块化思想更加本质的东西就是分而治之。

#### 其他设计思想和原则

- 单一职责原则

  内聚性和耦合性并非独立的。

  高内聚会让代码更加松耦合，而实现高内聚的重要指导原则，就是单一职责原则。

  模块或者类的职责设计的单一，而不是大而全，那依赖他的类和他依赖的类就会比较少，代码耦合也就相应的降低了。

- 基于接口而非实现编程

  基于接口而非实现编程能通过这样一个中间层，隔离变化和具体的实现。

  好处就是，在依赖关系的两个模块和类之间，一个模块或者类的改动，不会影响到另一个模块和类。实际上，这就相当于将一种强依赖关系解耦为弱依赖关系。

- 依赖注入

  跟基于接口而非实现编程思想类似，依赖注入也是将代码之间的强耦合变为弱耦合。尽管依赖注入无法将本应该有依赖关系的两个类，解耦为没有依赖关系，但可以让耦合关系没那么紧密，容易做到插拔替换。

- 多用组合少用继承

  继承是一种强依赖关系，父类与子类高度耦合，且这种耦合关系非常脆弱，牵一发而动全身，父类的每一次改动都会影响所有子类。

  相反，组合关系是一种弱依赖关系，更加灵活。

  所以对于继承结构比较复杂的代码，利用组合替换继承，也是一种解耦的有效手段。

- 迪米特法则

  迪米特法则讲的是，不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。从定义上，我们明显可以看出，这条原则的目的就是为了实现代码的松耦合。

## 快速改善代码质量的编程规范

编码规范大部分都简单明了，在代码细节方面，能立竿见影的改善质量。

而且小重构「低层次、小规模重构」依赖的基本上都是编码规范。

### 命名与注释

#### 1、命名多长最合适

有两种截然不同的命名方式。

- 准确达意，但名字也非常长。
- 使用缩写，名字非常短，得通过注释或者上下文才知道是干嘛的。

实际上，在足够表达含义的情况下，命名当然是越短越好。但大多数情况下，短的命名都没有长的命名更能达意。

对于一些默认、大家都比较熟知的词，推荐使用缩写「能让命名更短一些，也不影响阅读理解」。

- 作用域比较小的变量，可以使用相对短的命名，比如函数内的临时变量。

- 相反，对于类名这种作用域比较大的，更推荐更长的命名方式。

**原则是以准确达意为目标。**

#### 2、利用上下文简化命名

比如。

```java
public class User {
  private String userName;
  private String userPassword;
  private String userAvatarUrl;
  //...
}
```

在`User`类这样一个上下文中，成员变量的命名中重复使用`user`前缀。冗余。

可以借助对象这样一个上下文，表达也足够明确。

```java
public class User {
  private String name;
  private String password;
  private String avatarUrl;
  //...
}
User user = new User();
user.getName(); // 借助user对象这个上下文
```

除了成员变量之外，函数入参的命名也可以借助上下文简化命名。

```java
public void uploadUserAvatarImageToAliyun(String userAvatarImageUri);
//利用上下文简化为：
public void uploadUserAvatarImageToAliyun(String imageUri);
```

#### 3、命名要可读、可搜索

可读，就是不要使用一些特别生僻、难发音的英文单词来命名。

> 过去我曾参加过两个项目，一个叫 plateaux，另一个叫 eyrie，从项目立项到结束，自始至终都没有几个人能叫对这两个项目的名字。在沟通的时候，每当有人提到这两个项目的名字的时候，都会尴尬地卡顿一下。虽然我们并不排斥一些独特的命名方式，但起码得让大部分人看一眼就能知道怎么读。比如，我在 Google 参与过的一个项目，名叫 inkstone，虽然你不一定知道它表示什么意思，但基本上都能读得上来，不影响沟通交流，这就算是一个比较好的项目命名。

可搜索，指的是编写代码的时候，经常会用到「关键词联想」的方法自动补全和搜索。

- 比如键入`对象.get`，希望IDE返回这个对象的所有get开头的方法。

- 比如通过IDE搜索框输入「Array」，搜索已加载类库中数组相关的类。

所以，在命名的时候，最好能符合整个项目的命名习惯。

大家都用`selectXXX`表示查询，你就不要用`queryXXX`；大家都用`insertXXX`表示插入一条数据，你就不要用`addXXX`。

这样统一的规约很重要，能减少不必要的麻烦。

#### 4、如何命名接口和抽象类

接口的命名，一般有两种比较常见的方式。

- 接口前缀「I」。比如IUserService接口，实现类UserService。
- 不加前缀。比如接口UserService，实现类UserServiceImpl。

抽象类也有两种命名方式。

- 前缀「Abstract」
- 不加前缀。

选择哪种命名方式都可以，主要项目里能够统一就行。

#### 5、注释应该写什么

注释的目的就是让代码更容易看懂。只要符合这个要求的内容，就可以将它写到注释里。

注释的内容主要包含三个方面：做什么、为什么、怎么做。

```java
/**
* (what) Bean factory to create beans. 
* 
* (why) The class likes Spring IOC framework, but is more lightweight. 
*
* (how) Create objects from different sources sequentially:
* user specified object > SPI > configuration > default object.
*/
public class BeansFactory {
  // ...
}
```

- **注释比代码承载的信息更多。**

  命名的主要目的是解释「做什么」。

  比如`void increaseWalletAvailableBalance(BigDecimal amount) `表明这个函数用来增加钱包的可用余额，`boolean isValidatedPassword ()`表明这个变量用来标识是否是合法密码。

  函数和变量如果命名得好，确实可以不用再在注释中解释他是做什么的。

  但是对于类来说，包含的信息比较多，一个简单的命名就不够全面详尽。这个时候在注释中写明「做什么」就合情合理了。

- **注释起到总结性作用、文档作用。**

  **代码之下无秘密。**阅读代码确实可以明确的知道代码是「怎么做」的，也就是直到代码是如何实现的。

  在主食中，关于具体的代码实现思路，可以写一些总结性的说明、特殊情况的说明。这样能让阅读代码的人通过注释就能大概了解代码的实现思路，阅读起来就更加容易。

  对于有些比较复杂的类或者接口，可能还需要在注释中写清楚「怎么用」，举一些quick start的例子，让使用者在不阅读代码的情况下，能快速知道该如何使用。

- **一些总结性注释能让代码结构更清晰。**

  比如逻辑复杂的代码或者比较长的函数，如果不好提炼、不好拆分成小的函数调用，可以借助总结性的注释来让代码结构更清晰、更有条例。

  ```java
  public boolean isValidPasword(String password) {
    // check if password is null or empty
    if (StringUtils.isBlank(password)) {
      return false;
    }
  
    // check if the length of password is between 4 and 64
    int length = password.length();
    if (length < 4 || length > 64) {
      return false;
    }
      
    // check if password contains only a~z,0~9,dot
    for (int i = 0; i < length; ++i) {
      char c = password.charAt(i);
      if (!((c >= 'a' && c <= 'z') || (c >= '0' && c <= '9') || c == '.')) {
        return false;
      }
    }
    return true;
  }
  ```

#### 6、注释是不是越多越好

注释太多和太少都有问题。

- 太多。有可能意味着代码写的不够可读，需要写很多注释来补充。

  除此之外，注释太多也会对代码本身的阅读起到干扰。而且后期的维护成本比较高，有时候代码改了，注释忘了同步修改，就会让代码阅读者更加迷惑。

- 如果代码中一行注释也没有，那只能说明这个程序员很懒。

**类和函数一定要写注释，而且要写得尽可能全面、详细。**

而**函数内部的注释要相对少一些**，一般都是靠好的命名、提炼函数、解释性变量、总结性注释来提高代码的可读性。

### 代码风格

> 很难说哪种代码风格更好。
>
> 最重要的，也是最需要做到的，是在团队、项目中保持风格统一，让代码像一个人写出来的，整齐划一。
>
> 这样**能减少阅读干扰，提高代码的可读性**。

#### 1、类和函数多大合适

总体来说，类和函数的代码行数不能太多，但也不能太少。

- 太多。一个类上千行，一个函数几百行，逻辑过于繁杂，阅读代码的时候，很容易就会看了后面忘了前面。
- 太少。在代码总量相同的情况下，被分割成的类和函数就会相应增多，调用关系就会变得更复杂，阅读me讴歌代码逻辑的时候，需要频繁的在n个类或者n个函数之间跳来跳去，阅读体验不好。

确实很难给出一个精确的量化阈值。

网上有一种说法，那就是不要超过一个显示屏的垂直高度。比如在我的电脑上，如果要让一个函数的代码完整的显示在IDE中，那最大代码行数不能超过60。

这个说法挺有道理的，因为超过一个屏之后，在阅读代码的时候，为了串联前后的代码逻辑，就需要频繁频繁的上下滚动屏幕，阅读天不好不说，还容易出错。

但是这个限制，在日常能见到的代码中，除了一些简单的POJO，却很难见到。

还是不能单单依靠行数来判断是否符合代码规范，当一个类的代码阅读起来让你感觉头大了，是某个功能时不知道该用哪个函数了，想用哪个函数翻半天都找不到了，只用到一个小功能就要引入整个类「类中包含很多无关此功能实现的函数」的时候，这就说明类的函数过多了。

#### 2、一行代码多长最合适

> 在[Google Java Style Guide](https://google.github.io/styleguide/javaguide.html)文档中，一行代码最长限制为100个字符。

不过，不同的编程语言、不同的规范、不同的项目团队，对此的限制可能都不同。

不管这个限制是多少，总体上来讲要遵循的一个原则是：一行代码最长不能超过IDE显示的宽度。需要滚动鼠标才能查看一行的代码，显然不利于代码的阅读。

当然，这个限制也不能太小，太小会导致很多稍长点的语句被折成两行，也会影响到代码的整洁，不利于阅读。

#### 3、善用空行分隔单元块

对于比较长的函数，如果逻辑上可以分为独立的代码块，在不方便将这些独立的代码块抽取成小函数的情况下，为了让逻辑更加清晰，除了用总结性注释方法之外，还可以善用空行来分割各个代码块。

除此之外，在类的成员变量与函数之间、静态成员变量与普通成员变量之间、各函数之间、甚至各成员变量之间，都可以添加空行，界限更加明晰。

写代码就像写文章，善于应用空行，可以让代码的整体结构看起来更加清晰、有条理。

#### 4、四格缩进还是两格缩进

> 这似乎是一个古老的话题，一直存在争议「就像豆腐脑要喝甜的还是咸的一样那么古老且一直存在争议」。

取决于个人喜好，只要跟项目内部统一就行。

不过两格缩进可以节省代码空间。特别是在代码嵌套层级比较深的情况下，累计缩进比较多的话，容易导致一个语句被折成两行，影响代码可读性。

一般不推荐使用tab键缩进：因为在不同的IDE下，tab键的显示宽度不同，有的显示四格缩进，有的显示两格缩进。如果不统一，就会导致代码中有的显示两格缩进、有的显示四格缩进。

当然IDEA可以手动设置tab键的宽度。

<img src="https://wangigor-typora-images.oss-cn-chengdu.aliyuncs.com/image-20210830102949981.png" alt="image-20210830102949981" style="zoom:50%;" />

#### 5、大括号是否要另起一行

```php
// PHP
class ClassName
{
    public function foo()
    {
        // method body
    }
}
```

```java
// Java
public class ClassName {
  public void foo() {
    // method body
  }
}
```

比较推荐将括号跟语句放在同一行的风格。节省代码行数。

不过，大括号另起一行也有他的优势：左右括号可以垂直对齐，哪些代码属于哪一个代码块，更一目了然。

还是那句话，只要团队统一、业内统一、跟开源项目看起就好，没有绝对优劣之分。

#### 6、类中成员的排列顺序

> 在Java类文件中，先要写类所述的包名，然后再罗列import引入的依赖类。在Google编码规范中，依赖类按照字母序从小到大排列。

在类中。成员变量排在函数前面。成员变量或者函数之间，都是按照「先静态、后普通」的方式来排列。

除此之外，成员变量和函数之间，还可以按照作用域范围从大到小的顺序排列，先写public的、然后是protected的、最后是private的。

实际上，还有另一种排列习惯，就是把有调用关系的函数放在一块，比如一个public函数调用了另外一个private函数，那就把这两者放在一块。

### 编程技巧

> 这部分比较琐碎，也很难落泪全面。
>
> 仅仅总结一些比较关键的，更多的技巧需要在实践中慢慢总结、积累。

#### 1、把代码分隔成更小的单元块

> 大部分人阅读代码的习惯都是，先看整体再看细节。
>
> 所以我们要有模块化和抽象思维，善于将大块的复杂逻辑提炼层类或者函数，屏蔽掉细节，让阅读代码的人不至于秘事在细节中，这样能极大地提高代码的可读性。
>
> 不过，只有代码逻辑比较复杂的时候，我们其实才建议提炼类或函数。毕竟如果提炼出来的函数只有两三行代码，在阅读代码的时候，还得跳过去看，反而增加了阅读成本。

比如下面这个例子。

```java
// 重构前的代码
public void invest(long userId, long financialProductId) {
  Calendar calendar = Calendar.getInstance();
  calendar.setTime(date);
  calendar.set(Calendar.DATE, (calendar.get(Calendar.DATE) + 1));
  if (calendar.get(Calendar.DAY_OF_MONTH) == 1) {
    return;
  }
  //...
}

// 重构后的代码：提炼函数之后逻辑更加清晰
public void invest(long userId, long financialProductId) {
  if (isLastDayOfMonth(new Date())) {
    return;
  }
  //...
}

public boolean isLastDayOfMonth(Date date) {
  Calendar calendar = Calendar.getInstance();
  calendar.setTime(date);
  calendar.set(Calendar.DATE, (calendar.get(Calendar.DATE) + 1));
  if (calendar.get(Calendar.DAY_OF_MONTH) == 1) {
   return true;
  }
  return false;
}
```

让名字就能清晰表达它的功能。

#### 2、避免函数参数过多

函数包裹3、4个参数的时候还是能接受的，大于等于5个的时候，就觉得参数有点多了，会影响代码的可读性，使用起来也不方便。

一般有两种处理方式。

- 拆分成多个函数

  根据函数是否职责单一，进行拆分。

  ```java
  public User getUser(String username, String telephone, String email);
  
  // 拆分成多个函数
  public User getUserByUsername(String username);
  public User getUserByTelephone(String telephone);
  public User getUserByEmail(String email);
  ```

- 把函数的参数封装成对象

  ```java
  public void postBlog(String title, String summary, String keywords, String content, String category, long authorId);
  
  // 将参数封装成对象
  public class Blog {
    private String title;
    private String summary;
    private String keywords;
    private Strint content;
    private String category;
    private long authorId;
  }
  public void postBlog(Blog blog);
  ```

  这样还可以提高接口的兼容性，比如往老接口中添加新的参数，老的接口调用者有可能就不需要修改代码来兼容新的接口。

#### 3、勿用函数参数来控制逻辑

不要在函数中使用布尔类型的参数控制内部逻辑：true的时候走这段逻辑，false的时候走另一段逻辑。

这明显违背了单一职责原则和接口隔离原则。建议将其拆分成两个函数。

```java
public void buyCourse(long userId, long courseId, boolean isVip);

// 将其拆分成两个函数
public void buyCourse(long userId, long courseId);
public void buyCourseForVip(long userId, long courseId);
```

不过，如果函数是private私有函数，影响范围有限，或者拆分之后的两个函数经常同时被调用，可以酌情考虑保留标识参数。

```java
// 拆分成两个函数的调用方式
boolean isVip = false;
//...省略其他逻辑...
if (isVip) {
  buyCourseForVip(userId, courseId);
} else {
  buyCourse(userId, courseId);
}

// 保留标识参数的调用方式更加简洁
boolean isVip = false;
//...省略其他逻辑...
buyCourse(userId, courseId, isVip);
```

除了布尔类型作为标识参数来控制逻辑之外，还要一种「根据参数是否为null」来判断逻辑的情况。针对这种情况，也应该将其拆分成多个函数，拆分之后的函数职责更加明确，不容易出错。

```java
public List<Transaction> selectTransactions(Long userId, Date startDate, Date endDate) {
  if (startDate != null && endDate != null) {
    // 查询两个时间区间的transactions
  }
  if (startDate != null && endDate == null) {
    // 查询startDate之后的所有transactions
  }
  if (startDate == null && endDate != null) {
    // 查询endDate之前的所有transactions
  }
  if (startDate == null && endDate == null) {
    // 查询所有的transactions
  }
}

// 拆分成多个public函数，更加清晰、易用
public List<Transaction> selectTransactionsBetween(Long userId, Date startDate, Date endDate) {
  return selectTransactions(userId, startDate, endDate);
}

public List<Transaction> selectTransactionsStartWith(Long userId, Date startDate) {
  return selectTransactions(userId, startDate, null);
}

public List<Transaction> selectTransactionsEndWith(Long userId, Date endDate) {
  return selectTransactions(userId, null, endDate);
}

public List<Transaction> selectAllTransactions(Long userId) {
  return selectTransactions(userId, null, null);
}

private List<Transaction> selectTransactions(Long userId, Date startDate, Date endDate) {
  // ...
}
```

#### 4、函数设计要求职责单一

> 在设计原则的单一职责原则时，针对的是类、模块这样的应用对象。实际上对于函数的设计来说，更要满足单一职责原则。
>
> 相对于类和模块，函数的粒度比较小，代码行数少，所以不像类或者模块的那样模棱两可，能多单一就多单已。

```java
public boolean checkUserIfExisting(String telephone, String username, String email)  { 
  if (!StringUtils.isBlank(telephone)) {
    User user = userRepo.selectUserByTelephone(telephone);
    return user != null;
  }
  
  if (!StringUtils.isBlank(username)) {
    User user = userRepo.selectUserByUsername(username);
    return user != null;
  }
  
  if (!StringUtils.isBlank(email)) {
    User user = userRepo.selectUserByEmail(email);
    return user != null;
  }
  
  return false;
}

// 拆分成三个函数
public boolean checkUserIfExistingByTelephone(String telephone);
public boolean checkUserIfExistingByUsername(String username);
public boolean checkUserIfExistingByEmail(String email);
```

#### 5、移除过深的嵌套层级

代码嵌套层级过深往往是因为`if-else`、`switch-case`、`for循环`过度嵌套导致的。

建议，嵌套最好不要超过两层，超过两层之后就要思考一下是否可以减少嵌套。

过深的嵌套本身理解起来就比较费劲，除此之外，嵌套过深很容易因为代码多次缩进，导致嵌套内部的语句超过一行的长度而拆成两行，影响代码的整洁。

有4中常见思路。

- 去掉多余的`if`或`else`语句

  ```java
  // 示例一
  public double caculateTotalAmount(List<Order> orders) {
    if (orders == null || orders.isEmpty()) {
      return 0.0;
    } else { // 此处的else可以去掉
      double amount = 0.0;
      for (Order order : orders) {
        if (order != null) {
          amount += (order.getCount() * order.getPrice());
        }
      }
      return amount;
    }
  }
  
  // 示例二
  public List<String> matchStrings(List<String> strList,String substr) {
    List<String> matchedStrings = new ArrayList<>();
    if (strList != null && substr != null) {
      for (String str : strList) {
        if (str != null) { // 跟下面的if语句可以合并在一起
          if (str.contains(substr)) {
            matchedStrings.add(str);
          }
        }
      }
    }
    return matchedStrings;
  }
  ```

- 使用`continue`、`break`、`return`关键字，提前退出嵌套。

  ```java
  // 重构前的代码
  public List<String> matchStrings(List<String> strList,String substr) {
    List<String> matchedStrings = new ArrayList<>();
    if (strList != null && substr != null){ 
      for (String str : strList) {
        if (str != null && str.contains(substr)) {
          matchedStrings.add(str);
          // 此处还有10行代码...
        }
      }
    }
    return matchedStrings;
  }
  
  // 重构后的代码：使用continue提前退出
  // 逻辑代码在逻辑控制代码的层级少了一层。
  public List<String> matchStrings(List<String> strList,String substr) {
    List<String> matchedStrings = new ArrayList<>();
    if (strList != null && substr != null){ 
      for (String str : strList) {
        if (str == null || !str.contains(substr)) {
          continue; 
        }
        matchedStrings.add(str);
        // 此处还有10行代码...
      }
    }
    return matchedStrings;
  }
  ```

- 调整执行顺序

  ```java
  // 重构前的代码
  public List<String> matchStrings(List<String> strList,String substr) {
    List<String> matchedStrings = new ArrayList<>();
    if (strList != null && substr != null) {
      for (String str : strList) {
        if (str != null) {
          if (str.contains(substr)) {
            matchedStrings.add(str);
          }
        }
      }
    }
    return matchedStrings;
  }
  
  // 重构后的代码：先执行判空逻辑，再执行正常逻辑
  public List<String> matchStrings(List<String> strList,String substr) {
    if (strList == null || substr == null) { //先判空
      return Collections.emptyList();
    }
  
    List<String> matchedStrings = new ArrayList<>();
    for (String str : strList) {
      if (str != null) {
        if (str.contains(substr)) {
          matchedStrings.add(str);
        }
      }
    }
    return matchedStrings;
  }
  ```

- 将部分嵌套逻辑封装成函数调用

  ```java
  // 重构前的代码
  public List<String> appendSalts(List<String> passwords) {
    if (passwords == null || passwords.isEmpty()) {
      return Collections.emptyList();
    }
    
    List<String> passwordsWithSalt = new ArrayList<>();
    for (String password : passwords) {
      if (password == null) {
        continue;
      }
      if (password.length() < 8) {
        // ...
      } else {
        // ...
      }
    }
    return passwordsWithSalt;
  }
  
  // 重构后的代码：将部分逻辑抽成函数
  public List<String> appendSalts(List<String> passwords) {
    if (passwords == null || passwords.isEmpty()) {
      return Collections.emptyList();
    }
  
    List<String> passwordsWithSalt = new ArrayList<>();
    for (String password : passwords) {
      if (password == null) {
        continue;
      }
      passwordsWithSalt.add(appendSalt(password));
    }
    return passwordsWithSalt;
  }
  
  private String appendSalt(String password) {
    String passwordWithSalt = password;
    if (password.length() < 8) {
      // ...
    } else {
      // ...
    }
    return passwordWithSalt;
  }
  ```

  除此之外，常用的还有通过使用多台替代条件判断的方法。

#### 6、使用解释性变量

- 常量取代魔法数字

  ```java
  public double CalculateCircularArea(double radius) {
    return (3.1415) * radius * radius;
  }
  
  // 常量替代魔法数字
  public static final Double PI = 3.1415;
  public double CalculateCircularArea(double radius) {
    return PI * radius * radius;
  }
  ```

- 使用解释性变量解释复杂表达式

  ```java
  if (date.after(SUMMER_START) && date.before(SUMMER_END)) {
    // ...
  } else {
    // ...
  }
  
  // 引入解释性变量后逻辑更加清晰
  boolean isSummer = date.after(SUMMER_START)&&date.before(SUMMER_END);
  if (isSummer) {
    // ...
  } else {
    // ...
  } 
  ```



## ID生成器实战

### 需求背景

> `ID`中文翻译为「标识Identifier」。
>
> 这个概念在生活、工作中随处可见，比如身份证、商品条形码、二维码、车牌号、驾照号等等。
>
> 聚焦到软件开发中，ID常用来标识一些业务信息的唯一标识，比如订单的单号或数据库中的唯一主键。

后端业务系统的开发中，为了方便在请求出错时排查问题，我们在编写代码的时候会在关键路径上打印日志。某个请求出错之后，我们希望能够搜索出这个请求对应的所有日志，以此来查找问题的原因。而实际的情况是，在日志文件中，不同请求的日志是交织在一起的。如果没有来标识哪些日志属于同一个请求的唯一标识，我们就无法关联同一个请求的所有日志。

> 很像微服务中的调用链路追踪。
>
> 不过微服务中的调用链追踪是服务间的追踪，我们现在要实现的是服务内的追踪。

借鉴微服务调用链追踪的实现思路，我们可以给每个请求分配一个唯一ID，并且保存在请求的上下文`Context`「处理请求的工作线程的局部变量」中。

- 比如线程的`ThreadLocal`中。
- 比如`Slf4j`日志框架的`MDC(Mapped Diagnostic Contexts)`，底层也是基于线程`ThreadLocal`。

每次打印日志的时候，我们从请求上下文中取出请求ID，跟日志一块输出。

现在就需要一个ID生成器。

### 能用的代码

假设我们设计的ID生成规则是「IP最后一位+当前毫秒时间戳+8位随机字符串」。

> 并不是绝对唯一，但是这样的极小重复概率完全可以被接受。

```java
public class IdGenerator {
  private static final Logger logger = LoggerFactory.getLogger(IdGenerator.class);

  public static String generate() {
    String id = "";
    try {
      String hostName = InetAddress.getLocalHost().getHostName();
      String[] tokens = hostName.split("\\.");
      if (tokens.length > 0) {
        hostName = tokens[tokens.length - 1];
      }
      char[] randomChars = new char[8];
      int count = 0;
      Random random = new Random();
      while (count < 8) {
        int randomAscii = random.nextInt(122);
        if (randomAscii >= 48 && randomAscii <= 57) {
          randomChars[count] = (char)('0' + (randomAscii - 48));
          count++;
        } else if (randomAscii >= 65 && randomAscii <= 90) {
          randomChars[count] = (char)('A' + (randomAscii - 65));
          count++;
        } else if (randomAscii >= 97 && randomAscii <= 122) {
          randomChars[count] = (char)('a' + (randomAscii - 97));
          count++;
        }
      }
      id = String.format("%s-%d-%s", hostName,
              System.currentTimeMillis(), new String(randomChars));
    } catch (UnknownHostException e) {
      logger.warn("Failed to get the host name.", e);
    }

    return id;
  }
}
```

#### 发现代码质量问题

从大处着眼的话，可以参考之前的代码质量评审标准，看这段代码是否可读、可扩展、可维护、灵活、简洁、可复用、可测试等等。

落实到具体细节，我们可以从以下几点来评审代码「**非业务**」：

- 目录设置是否合理、模块划分十分清晰、代码结构是否满足「高内聚、松耦合」。
- 是否遵循经典的设计模式和设计思想「SOLID、DRY、KISS、YAGNI、LOD等」。
- 设计模式是否应用得当。是否过度设计。
- 代码是否容易扩展。如果要添加新功能，是否容易实现。
- 代码是否可以复用。是否可以服用已有的项目代码或类库。是否重复造轮子。
- 是否容易测试。单元测试是否全面覆盖各种正常或异常情况。
- 代码是否易读。是否符合编码规范「比如命名和注释是否恰当、代码风格是否一致」。

以上是一些通用的关注点，可以作为常规检查项，套用在任何代码的重构上。

除此之外，我们还要关注代码实现是否满足业务本身特有的功能和非功能需求。比如「**业务**」：

- 代码是否实现了预期的业务需求。
- 逻辑是否正确。能否处理各种异常需求。
- 日志打印书否得当。是否方便debug排查问题。
- 接口是否易用。是否支持幂等、事务等。
- 代码是否存在并发问题。是否线程安全。
- 性能是否有优化空间，比如SQL、算法是否可以优化。
- 是否有安全漏洞。比如输入输出校验是否全面。
- ……

#### 运行时出错应该返回啥

函数运行时出错的返回类型，总结了下面4中情况。

##### 1、返回错误码

这是一种从C语言延续下来的异常返回机制，因为C语言没有异常这样的语法机制。

但在Java、Python这样的编程语言中，大部分情况下，都用异常来处理函数出错情况。或者在外部调用接口比如API、前后端Restful，需要约定错误类型的时候，经常使用错误码。

错误码的返回方式有两种

- 一种直接占用函数返回值，函数正常执行的返回值预置在入参中。

  ```java
  //pathname/flags/mode为入参；fd为出参，存储打开的文件句柄。
  int open(const char *pathname, int flags, mode_t mode, int* fd) {
    if (/*文件不存在*/) {
      return EEXIST;
    }
    
    if (/*没有访问权限*/) {
      return EACCESS;
    }
    
    if (/*打开文件成功*/) {
      return SUCCESS; // C语言中的宏定义：#define SUCCESS 0
    }
    // ...
  }
  //使用举例
  int fd;
  int result = open(“c:\test.txt”, O_RDWR, S_IRWXU|S_IRWXG|S_IRWXO, &fd);
  if (result == SUCCESS) {
    // 取出fd使用
  } else if (result == EEXIST) {
    //...
  } else if (result == EACESS) {
    //...
  }
  ```

- 另外一种是将错误码定义为全局变量，在函数执行出错时，调用者通过这个全局变量获取错误码。

  ```java
  //函数返回打开的文件句柄，错误码放到errno中。
  int errno; // 线程安全的全局变量
  int open(const char *pathname, int flags, mode_t mode）{
    if (/*文件不存在*/) {
      errno = EEXIST;
      return -1;
    }
    
    if (/*没有访问权限*/) {
      errno = EACCESS;
      return -1;
    }
    
    // ...
  }
  // 使用举例
  int hFile = open(“c:\test.txt”, O_RDWR, S_IRWXU|S_IRWXG|S_IRWXO);
  if (-1 == hFile) {
    printf("Failed to open file, error no: %d.\n", errno);
    if (errno == EEXIST ) {
      // ...        
    } else if(errno == EACCESS) {
      // ...    
    }
    // ...
  }
  ```

如果编程语言中有异常语法机制，就尽量不要使用错误码。异常相对于错误码，有诸多方面的优势，比如可以携带更多的错误信息「message、stack trace等信息」。

##### 2、返回Null值

在很多编程语言中，`null`表示不存在。

不过很多人不建议返回`null`值，认为这是一种不好的设计思路。主要是因为

- 某个函数有可能返回`null`值，如果调用者忘了做`null`值判断，就会抛出空指针异常「NullPointException」。

- 如果我们定义了很多返回值可能是`null`的函数，那代码中就会充斥大量的`null`值判断逻辑。

  一方面写起来比较繁琐，另一方面他们跟正常的业务逻辑耦合在一起，会影响代码的可读性。

举个例子。

```java
public class UserService {
  private UserRepo userRepo; // 依赖注入
  
  public User getUser(String telephone) {
    // 如果用户不存在，则返回null
    return null;
  }
}

// 使用函数getUser()
User user = userService.getUser("18917718965");
if (user != null) { // 做NULL值判断，否则有可能会报NPE
  String email = user.getEmail();
  if (email != null) { // 做NULL值判断，否则有可能会报NPE
    String escapedEmail = email.replaceAll("@", "#");
  }
}
```

> 那么能不能用异常来替代`null`呢？在用户找不到的时候，让函数抛出`UserNotFoundException`。

尽管返回`null`值有弊端，但对于get、find、select、search、query等单词开头的查找函数来说，**数据不存在，并非一种异常情况，这是一种正常的业务行为**。所以返回不存在`null`比返回异常更加合理。

但是，刚刚这个理由，也并不是特别有说服力。对于查找数据不存在的情况，到底应该返回`null`值还是抛出异常，有一个比较重要的参考标准，看项目中其他类似查找函数是如何定义的，只要整个项目遵从统一的约定即可。

也要结合代码本身业务来看。

- 比如有些查找允许查询不到对应结果，比如条件查询啥的，返回null就比较合理，由调用者做判断。
- 比如有些获取数据不允许找不到结果，比如通过id进行加载，返回null就不符合业务要求，适合抛出异常，有调用者捕获异常处理。

对于查找函数来说，除了返回数据对象之外，有的还会返回下标位置。

比如Java的`indexOf()`「用来实现在某个字符串中查找另一个模式串第一次出现的位置」，返回值类型为int。这个时候，就不能用`null`值来表示不存在的情况了。对于这种情况，有两种思路。

- 抛出`NotFoundException`

- 返回一个特殊值，比如`-1`。

它选择`-1`的理由跟上面例子一样，就是「没有找到」是一种正常而非异常的行为。

> 应对这个返回`null`值问题，有一个比较经典的策略，就是应用空对象设计模式「Null Object Design Pattern」。后续经典设计模式会讲到。

##### 3、返回空对象

还有量种比较特殊的空对象就是**空字符串**和**空集合**。

当函数返回的数据是字符串类型或者集合类型的时候，可以使用空字符串或空集合代替`null`值表示不存在。这样调用者就可以不做`null`值判断。

```java
// 使用空集合替代NULL
public class UserService {
  private UserRepo userRepo; // 依赖注入
  
  public List<User> getUsers(String telephonePrefix) {
   // 没有查找到数据
    return Collections.emptyList();
  }
}
// getUsers使用示例
List<User> users = userService.getUsers("189");
for (User user : users) { //这里不需要做NULL值判断
  // ...
}

// 使用空字符串替代NULL
public String retrieveUppercaseLetters(String text) {
  // 如果text中没有大写字母，返回空字符串，而非NULL值
  return "";
}
// retrieveUppercaseLetters()使用举例
String uppercaseLetters = retrieveUppercaseLetters("wangzheng");
int length = uppercaseLetters.length();// 不需要做NULL值判断 
System.out.println("Contains " + length + " upper case letters.");
```

##### 4、抛出异常

**异常可以将正常逻辑和异常逻辑的处理分离开**，这样代码的可读性就会更好。

> 对于运行时异常，我们在编译写代码的时候，可以不用主动`try-catch`，编译器在编译代码的时候，并不会检查代码是否有对运行时异常做了处理。
>
> 对于编译时异常，需要主动`try-catch`或者在函数定义中声明，否则编译就会报错。
>
> 运行时异常叫做非受检异常「Unchecked Exception」。
>
> 编译时异常叫做受检异常「Checked Exception」。

**对于代码bug「比如数组越界」以及不可恢复异常「比如数据库连接失败」**，即便我们捕获了，也做不了太多事情，所以我们**倾向于使用非受检异常**。

**对于可恢复异常、业务异常，比如提现金额大于余额的异常**，我们更**倾向于使用受检异常**，明确告知调用者需要捕获异常。

举个例子。

> 当`Redis`的地址`address`没有设置的时候，使用默认的地址「本机地址+默认端口」。
>
> 当`Redis`地址格式不正确的时候，我们希望程序能fail-fast，也就是说，把这种情况当成不可恢复的异常，直接抛出运行时异常，将程序终止掉。

```java
// address格式："192.131.2.33:7896"
public void parseRedisAddress(String address) {
  this.host = RedisConfig.DEFAULT_HOST;
  this.port = RedisConfig.DEFAULT_PORT;
  
  if (StringUtils.isBlank(address)) {
    return;
  }

  String[] ipAndPort = address.split(":");
  if (ipAndPort.length != 2) {
    throw new RuntimeException("...");
  }
  
  this.host = ipAndPort[0];
  // parseInt()解析失败会抛出NumberFormatException运行时异常
  this.port = Integer.parseInt(ipAndPort[1]);
}
```

实际上，Java支持的受检异常一直被人诟病，很多人主张所有的异常情况都应该使用非受检异常。理由主要有三个：

- 受检异常需要显式地在函数定义中声明。

  如果函数会抛出很多受检异常，那函数的定义就会非常冗长，这就会影响代码的可读性，使用起来不方便。

- 编译器强制我们必须显式地捕获所有的受检异常，代码实现会比较繁琐。

  而非受检异常正好相反，不需要再定义中显式声明，并且是否需要捕获处理，可以自由决定。

- 受检异常的使用违反开闭原则。

  如果我们给某个函数新增了一个受检异常，这个函数所在的函数调用链上所有位于其之上的函数都需要做响应的代码修改，直到调用链上的某个函数将这个新增的异常`try-catch`处理掉位置。

  而新增非受检异常可以不改动调用链上的代码。我们可以灵活地选择在某个函数中几种处理，比如在`Spring`的`AOP`切面中集中处理异常。

不过，非受检异常也有弊端，它的优点其实也就是他的缺点。过于灵活就会带来不可控，非受检异常不需要显式地在函数定义中声明，那我们在使用函数的时候，就需要查看代码才能知道具体会抛出哪些异常。非受检异常不强制捕获处理，那程序员就有可能漏掉一些本该捕获处理的异常。

> 对于应用该受检异常还是非受检异常，网上的争论有很多，并没有一个非常强有力的理由能够说明一个就一定比另一个更好。

调用者可以如何处理函数抛出的异常，一把有下面三种处理办法。

###### 直接吞掉

```java
public void func1() throws Exception1 {
  // ...
}

public void func2() {
  //...
  try {
    func1();
  } catch(Exception1 e) {
    log.warn("...", e); //吞掉：try-catch打印日志
  }
  //...
}
```

###### 原封不动地re-throw

```java
public void func1() throws Exception1 {
  // ...
}


public void func2() throws Exception1 {//原封不动的re-throw Exception1
  //...
  func1();
  //...
}
```

###### 包装成新的异常re-throw

```java
public void func1() throws Exception1 {
  // ...
}


public void func2() throws Exception2 {
  //...
  try {
    func1();
  } catch(Exception1 e) {
   throw new Exception2("...", e); // wrap成新的Exception2然后re-throw
  }
  //...
}
```

这三种处理方式应该如何选择，有下面三个参考原则：

- 如果`func1()`抛出的异常是可以恢复的，且`func2()`的调用方并不关心此异常。

  完全可以在`func2()`内将`func1()`抛出的异常直接吞掉。

- 如果`func1()`抛出的异常对调用方`func2()`来说，是可以理解的且关心的，在业务概念上有一定的相关性。

  我们可以直接将`func1()`抛出的异常re-throw。

- 如果`func1()`抛出的异常太底层，对`func2()`的调用方来说，缺乏背景去理解、且在业务概念上无关。

  我们可以将异常重新包装秤调用方可以理解的新异常，然后re-throw。

总之，

是否往上继续抛出，要看调用方代码是否关心这个异常。关心就抛出，否则直接吞掉。

是否需要包装成新的异常，看上层代码能否理解这个异常、是否业务相关。能理解且业务相关就直接抛出，否则要进行包装。

#### 对照检测标准罗列问题

##### 业务无关的代码质量关注点

- `IdGenerator`代码比较简单，只有一个类。所以不涉及目录设置、模块划分、代码结构问题。

- 不违反SOLID、DRY、KISS、YAGNI、LOD原则，但是设计成了实现类而非接口，调用者直接以来实现而非接口，违反了基于接口而非实现编程的设计思想。

  但这问题也不大，如果哪天ID生成算法改变了，我们只需要修改实现类的代码就可以。

  加入项目中需要同时存在两种ID生成算法，这个时候我们就需要将`IdGenerator`定义为接口，并且为不同的生成算法定义不同的实现类了。

- 没有应用设计模式，也就不存在不合理使用或过度设计的问题。

- 第二点解释了扩展行和复用性问题。

- `generate()`函数定义为静态函数，影响使用该函数的代码的可测试性。

  代码实现依赖运行环境「本机名」、时间函数、随机函数，本身的可测试性不好。

  没有编写单元测试代码。

- 虽然`IdGenerator`只包含一个函数，且代码行数不多，但可读性并不好。

  特别是随机字符串生成的那个部分，一方面没有注释，另一方面代码里有很多魔法数。

##### 业务本身的功能和非功能需求

- 虽然生成的ID并非绝对唯一，但对于追踪日志来说，是可以接受小概率ID冲突的，满足预期的业务需求。

- 获取`hostName`这部分代码并未处理「hostName为空的情况」。

  尽管捕获了「获取不到本机名的异常」，但处理方式是直接吞掉，然后打印了一条报警日志，并没有继续往上抛出。

- 日志输出采用通用的日志框架，合理。

  debug排查问题方便。

- `IdGenerator`只暴露了`generate()`一个方法，定义简单，不存在不易用问题。

  不存在幂等问题。

- 函数中没有涉及共享变量，编程安全，不存在并发问题。

- ID的生成不依赖外部存储，全部在内存中生成，性能方便足够应对应用场景。

  但是获取主机名比较耗时，考虑优化。

  `randomAscii`取值范围是0\~122，但是可用数组仅包含三段子区间「48\~57，65\~90，97\~122」，可能大部分随机生成的都是无效数字，循环次数可能很多。考虑优化。

- 没有安全漏洞，没有输入参数。



> 现在，可以有一招的罗列出这段的质量缺陷，并且做到有章可循、系统全面、无遗漏。

### 开始重构

重构要循序渐进、小步快跑。每次改动一点点，改好以后在进行下一轮优化，保证每次对代码的改动不会太大，能在很短的时间内完成。

> 因为代码没有完善的测试用例，再加上重构过程中会涉及函数增加。
>
> 所以完善单元测试这一环节没有放在第一步。本来每一步重构都要进行之前的单元测试的，但是现在不行。

- 第一轮：提高代码的可读性。
- 第二轮：提高代码的可测试性。
- 第三轮：编写完善的单元测试。
- 第四轮：所有重构完成之后增加注释。

#### 第一轮：提高代码的可读性

首先，要解决最明显、最急需改进的代码可读性问题。

- `hostName`变量不应该被重复使用，尤其两次使用时的含义还不同。
- 将`hostName`获取的代码抽离出来，定义为`getLastFieldOfHostName()`函数。
- 删除代码中的魔法数。
- 将随机数生成的函数抽离出来，定义为`generateRandomAlphameric()`函数。
- `generate()`函数中的三个`if`逻辑重复了，且实现过于复杂，简化。
- 对`IdGenerator`重命名，抽象出来接口。

重点讨论一下「命名」的修改。对于ID生成器的代码，有三种命名方式。

|            | 接口                | 实现类                    |
| ---------- | ------------------- | ------------------------- |
| 命名方式一 | IdGenerator         | LogTraceIdGenerator       |
| 命名方式二 | LogTraceIdGenerator | HostNameMillisIdGenerator |
| 命名方式三 | LogTraceIdGenerator | RandomIdGenerator         |

- **命名方式一**

  这种命名方式多个ID生成需求抽取一个公共接口。

  比如 用户ID「`UserIdGenerator`」、订单ID「`OrderIdGenerator`」和日志ID「`LogTraceIdGenerator`」，抽取出一个公共接口`IdGenerator`。

  这不是扩展性要的。扩展性需要不是像这样的基于业务的纵向扩展。

  ```java
  IdGenearator idGenerator = new LogTraceIdGenerator();
  替换为:
  IdGenearator idGenerator = new UserIdGenerator();
  ```

  扩展性要的是日志ID要更换其他实现方式时的扩展。

  所以这样的接口抽取没有意义。

- **命名方式二**

  不合理，实现类暴露了太多实现细节。

  只要代码微微改动，就可能需要改动命名。

- **命名方式三**

  合理。

  目前的ID生成器实现中，生成的ID是一个随机ID。不是递增有序的，所以`RandomIdGenerator`合理，即便内部生成算法有所改动，只要生成的还是随机的ID，就不需要改动命名。

  如果后续需要扩展新的递增有序ID，那就命名为`SequenceIdGenerator`。

还有一种命名方式是结合「命名方式一」和「命名方式三」。

抽取两个接口，一个`IdGenerator`一个`LogTraceIdGenerator`，`LogTraceIdGenerator`继承`IdGenerator`。实现接口为`RandomIdGenerator`实现`LogTraceIdGenerator`。这样，实现类可以服用到多个业务模块中，比如订单、用户。

根据上面的优化策略，第一轮的重构代码如下。

```java

public interface IdGenerator {
  String generate();
}

public interface LogTraceIdGenerator extends IdGenerator {
}

public class RandomIdGenerator implements LogTraceIdGenerator {
  private static final Logger logger = LoggerFactory.getLogger(RandomIdGenerator.class);

  @Override
  public String generate() {
    String substrOfHostName = getLastfieldOfHostName();
    long currentTimeMillis = System.currentTimeMillis();
    String randomString = generateRandomAlphameric(8);
    String id = String.format("%s-%d-%s",
            substrOfHostName, currentTimeMillis, randomString);
    return id;
  }

  private String getLastfieldOfHostName() {
    String substrOfHostName = null;
    try {
      String hostName = InetAddress.getLocalHost().getHostName();
      String[] tokens = hostName.split("\\.");
      substrOfHostName = tokens[tokens.length - 1];
      return substrOfHostName;
    } catch (UnknownHostException e) {
      logger.warn("Failed to get the host name.", e);
    }
    return substrOfHostName;
  }

  private String generateRandomAlphameric(int length) {
    char[] randomChars = new char[length];
    int count = 0;
    Random random = new Random();
    while (count < length) {
      int maxAscii = 'z';
      int randomAscii = random.nextInt(maxAscii);
      boolean isDigit= randomAscii >= '0' && randomAscii <= '9';
      boolean isUppercase= randomAscii >= 'A' && randomAscii <= 'Z';
      boolean isLowercase= randomAscii >= 'a' && randomAscii <= 'z';
      if (isDigit|| isUppercase || isLowercase) {
        randomChars[count] = (char) (randomAscii);
        ++count;
      }
    }
    return new String(randomChars);
  }
}

//代码使用举例
LogTraceIdGenerator logTraceIdGenerator = new RandomIdGenerator();
```

#### 第二轮：提高代码的可测试性

关于代码的可测试性问题，主要包含以下两个方面：

- `generate()`函数为静态函数。

  这个问题，已经在第一轮重构中解决了。将`RandomIdGenerator`类中的`generate()`重新定义为普通函数。调用者可以通过依赖注入的方式，在外部创建好`RandomIdGenerator`对象后注入到代码中。

- `generate()`代码实现依赖运行环境「本机名」、时间函数、随机函数。

第二个问题的改动，主要包含以下三点：

- 把`getLastFieldOfHostName()`函数中逻辑复杂的部分「split出hostName的最后一位」，抽取成`getLastSubstrSplittedByDot()`函数。着重测试这个函数就行。获取主机名的方法要在它自己的测试用例里进行，而不是这里。
- 将`generateRandomAlphameric()`和`getLastSubstrSplittedByDot()`访问权限设置为`protected`。方便在单元测试中直接调用。当然也可以保留原有的`private`，增加guava的注解@VisibleForTesting也行。

```java
public class RandomIdGenerator implements LogTraceIdGenerator {
  private static final Logger logger = LoggerFactory.getLogger(RandomIdGenerator.class);

  @Override
  public String generate() {
    String substrOfHostName = getLastfieldOfHostName();
    long currentTimeMillis = System.currentTimeMillis();
    String randomString = generateRandomAlphameric(8);
    String id = String.format("%s-%d-%s",
            substrOfHostName, currentTimeMillis, randomString);
    return id;
  }

  private String getLastfieldOfHostName() {
    String substrOfHostName = null;
    try {
      String hostName = InetAddress.getLocalHost().getHostName();
      substrOfHostName = getLastSubstrSplittedByDot(hostName);
    } catch (UnknownHostException e) {
      logger.warn("Failed to get the host name.", e);
    }
    return substrOfHostName;
  }

  @VisibleForTesting
  protected String getLastSubstrSplittedByDot(String hostName) {
    String[] tokens = hostName.split("\\.");
    String substrOfHostName = tokens[tokens.length - 1];
    return substrOfHostName;
  }

  @VisibleForTesting
  protected String generateRandomAlphameric(int length) {
    char[] randomChars = new char[length];
    int count = 0;
    Random random = new Random();
    while (count < length) {
      int maxAscii = 'z';
      int randomAscii = random.nextInt(maxAscii);
      boolean isDigit= randomAscii >= '0' && randomAscii <= '9';
      boolean isUppercase= randomAscii >= 'A' && randomAscii <= 'Z';
      boolean isLowercase= randomAscii >= 'a' && randomAscii <= 'z';
      if (isDigit|| isUppercase || isLowercase) {
        randomChars[count] = (char) (randomAscii);
        ++count;
      }
    }
    return new String(randomChars);
  }
}
```

类中还有一个日志Logger的静态属性，这个是不是也需要通过依赖注入的方式注入到类中呢？会不会影响测试呢？

不会。依赖注入之所以能提高代码可测试性，主要是因为，通过这样的方式我们能够轻松mock出各种生产情况。当这个对象与逻辑执行有关且有不可控的时候，需要改为依赖注入。

但是对于`logger`对象来说，我们只是写入数据，不读取数据，不参与业务逻辑执行，不会影响代码逻辑的正确性，所以没有必要mock`Logger`对象。

此外，一些只是为了存储数据的值对象，比如String、Map、Vo，也没有必要通过依赖注入的方式创建，直接在类中通过new创建就可以了。

#### 第三轮：编写完善的单元测试

`RandomIdGenerator`类中有4个函数：

```java
public String generate();
private String getLastfieldOfHostName();
@VisibleForTesting
protected String getLastSubstrSplittedByDot(String hostName);
@VisibleForTesting
protected String generateRandomAlphameric(int length);
```

这里使用了JUnit测试框架。

先测试之前分隔出来的`getLastSubstrSplittedByDot`和`generateRandomAlphameric`函数。

```java

public class RandomIdGeneratorTest {
  @Test
  public void testGetLastSubstrSplittedByDot() {
    RandomIdGenerator idGenerator = new RandomIdGenerator();
    String actualSubstr = idGenerator.getLastSubstrSplittedByDot("field1.field2.field3");
    Assert.assertEquals("field3", actualSubstr);

    actualSubstr = idGenerator.getLastSubstrSplittedByDot("field1");
    Assert.assertEquals("field1", actualSubstr);

    actualSubstr = idGenerator.getLastSubstrSplittedByDot("field1#field2$field3");
    Assert.assertEquals("field1#field2#field3", actualSubstr);
  }

  // 此单元测试会失败，因为我们在代码中没有处理hostName为null或空字符串的情况
  // 后面重构
  @Test
  public void testGetLastSubstrSplittedByDot_nullOrEmpty() {
    RandomIdGenerator idGenerator = new RandomIdGenerator();
    String actualSubstr = idGenerator.getLastSubstrSplittedByDot(null);
    Assert.assertNull(actualSubstr);

    actualSubstr = idGenerator.getLastSubstrSplittedByDot("");
    Assert.assertEquals("", actualSubstr);
  }

  @Test
  public void testGenerateRandomAlphameric() {
    RandomIdGenerator idGenerator = new RandomIdGenerator();
    String actualRandomString = idGenerator.generateRandomAlphameric(6);
    Assert.assertNotNull(actualRandomString);
    Assert.assertEquals(6, actualRandomString.length());
    for (char c : actualRandomString.toCharArray()) {
      Assert.assertTrue(('0' < c && c < '9') || ('a' < c && c < 'z') || ('A' < c && c < 'Z'));
    }
  }

  // 此单元测试会失败，因为我们在代码中没有处理length<=0的情况
  // 后面重构
  @Test
  public void testGenerateRandomAlphameric_lengthEqualsOrLessThanZero() {
    RandomIdGenerator idGenerator = new RandomIdGenerator();
    String actualRandomString = idGenerator.generateRandomAlphameric(0);
    Assert.assertEquals("", actualRandomString);

    actualRandomString = idGenerator.generateRandomAlphameric(-1);
    Assert.assertNull(actualRandomString);
  }
}
```

这里留一个扣子「在`getLastSubstrSplittedByDot`和`generateRandomAlphameric`都有异常输入的情况」，后面讨论。

针对`generate()`函数的代码实现，可以有三种不同的功能定义：

- **生成一个随机唯一ID**

  需要多次调用然后看是否唯一。
  
- **生成一个只包含数字、大小写字母和中划线的唯一ID**

  需要测试生成ID的格式。

- **生成唯一ID，格式为{主机名substr}-{时间戳}-{8位随机字符}**

  那么既要验证唯一性，也要验证格式。

#### 添加注释

主要是写清楚：做什么、为什么、怎么做、怎么用，对一些边界条件、特殊情况进行说明，一级对函数输入、输出、异常进行说明。

```java

/**
 * Id Generator that is used to generate random IDs.
 *
 * <p>
 * The IDs generated by this class are not absolutely unique,
 * but the probability of duplication is very low.
 */
public class RandomIdGenerator implements LogTraceIdGenerator {
  private static final Logger logger = LoggerFactory.getLogger(RandomIdGenerator.class);

  /**
   * Generate the random ID. The IDs may be duplicated only in extreme situation.
   *
   * @return an random ID
   */
  @Override
  public String generate() {
    //...
  }

  /**
   * Get the local hostname and
   * extract the last field of the name string splitted by delimiter '.'.
   *
   * @return the last field of hostname. Returns null if hostname is not obtained.
   */
  private String getLastfieldOfHostName() {
    //...
  }

  /**
   * Get the last field of {@hostName} splitted by delemiter '.'.
   *
   * @param hostName should not be null
   * @return the last field of {@hostName}. Returns empty string if {@hostName} is empty string.
   */
  @VisibleForTesting
  protected String getLastSubstrSplittedByDot(String hostName) {
    //...
  }

  /**
   * Generate random string which
   * only contains digits, uppercase letters and lowercase letters.
   *
   * @param length should not be less than 0
   * @return the random string. Returns empty string if {@length} is 0
   */
  @VisibleForTesting
  protected String generateRandomAlphameric(int length) {
    //...
  }
}
```

#### 异常情况

**如果主机名获取失败，函数返回什么比较合理？**

在目前的代码中，如果主机名获取失败，`substrOfHostName`为null，`generator()`函数会返回类似`null-16723733647-83Ab3uK6”`。如果主机名获取失败，`substrOfHostName`为空字符串，`generator()`函数会返回类似`-16723733647-83Ab3uK6”`。

以上哪种情况合理呢？

很难讲，要看具体的业务如何设计，我更倾向于明确的将异常告知调用者。

所以这里最好是抛出受检异常，而非特殊值。

```java

  public String generate() throws IdGenerationFailureException {
    String substrOfHostName = getLastFieldOfHostName();
    if (substrOfHostName == null || substrOfHostName.isEmpty()) {
      throw new IdGenerationFailureException("host name is empty.");
    }
    long currentTimeMillis = System.currentTimeMillis();
    String randomString = generateRandomAlphameric(8);
    String id = String.format("%s-%d-%s",
            substrOfHostName, currentTimeMillis, randomString);
    return id;
  }
```

那`getLastFieldOfHoseName()`也需要做相应修改，因为之前`UnknownHostException`被吞掉了。这个异常是应该直接抛出还是封装成新异常抛出呢？

因为这个`UnknownHostException`对于`getLastFieldOfHostName()`来说业务相关，也就是说`getLastFieldOfHostName()`能够理解异常的含义，所以直接抛出即可。

```java
 private String getLastFieldOfHostName() throws UnknownHostException{
    String substrOfHostName = null;
    String hostName = InetAddress.getLocalHost().getHostName();
    substrOfHostName = getLastSubstrSplittedByDot(hostName);
    return substrOfHostName;
 }
```

之后再回头重构`generate()`方法，对于它的调用者来说`UnknownHostException`异常显然过于底层了「你就告诉我生成失败就行了，不用告诉我为啥」，所以要把这个异常包装成`IdGenerationFailureException`异常抛出。

> 并且，如果`generate()`抛出了`UnknownHostException`异常，就暴露给了上层实现细节。

```java
  public String generate() throws IdGenerationFailureException {
    String substrOfHostName = null;
    try {
      substrOfHostName = getLastFieldOfHostName();
    } catch (UnknownHostException e) {
      throw new IdGenerationFailureException("host name is empty.");
    }
    long currentTimeMillis = System.currentTimeMillis();
    String randomString = generateRandomAlphameric(8);
    String id = String.format("%s-%d-%s",
            substrOfHostName, currentTimeMillis, randomString);
    return id;
  }
```

虽然在前面这一步，在主机名获取失败的情况下，抛出了异常。

但是对于`getLastSubstrSplittedByDot(String hostName)`函数来说，它本身也不能不管。那就是**如果hostName为null或者空字符串，这个函数该返回什么呢？**

> 理论上讲，参数传递的正确性应该由程序员来保证，我们无需做null值或者空字符串的判断和特殊处理。调用者不应该把null值或者空字符串传进来。如果传进来，那就是bug，需要修复。
>
> 但是话说回来，谁也保证不了程序员就一定不会传递null或者空字符串。那到底该不该做这一特殊的判断呢？
>
> - 如果函数是私有的「private」，只在类内部调用，那完全在自己的掌握之下，自己保证不传递null或空字符串就行。
> - 如果函数是public的，无法掌控会被谁调用以及如何调用，为了提高代码的健壮性要做判断。
> - 之前设置为protected是为了方便测试，不过单元测试当然需要做一些`corner case`。所以我们也要加上这一特殊情况的校验。

```java
  @VisibleForTesting
  protected String getLastSubstrSplittedByDot(String hostName) {
    if (hostName == null || hostName.isEmpty()) {
      throw IllegalArgumentException("..."); //运行时异常
    }
    String[] tokens = hostName.split("\\.");
    String substrOfHostName = tokens[tokens.length - 1];
    return substrOfHostName;
  }
```

为了保证不传递null或空字符串进`getLastSubstrSplittedByDot()`方法，`getLastFieldOfHostName`也要做响应修改。

```java
 private String getLastFieldOfHostName() throws UnknownHostException{
    String substrOfHostName = null;
    String hostName = InetAddress.getLocalHost().getHostName();
    if (hostName == null || hostName.isEmpty()) { // 此处做判断
      throw new UnknownHostException("...");
    }
    substrOfHostName = getLastSubstrSplittedByDot(hostName);
    return substrOfHostName;
 }
```

***

**对于另外一个` generateRandomAlphameric(int length)` 函数，如果 `length < 0` 或 `length == 0`，这个函数应该返回什么？**

- **length<0**

  这种情况，不符合常规逻辑，应该算一种异常行为。

  他是属于输入参数非法，应该抛出`IllegalArgumentException`异常。

- **length==0**

  这种情况可以接受。

  既可以被定义为一种异常行为，抛出`IllegalArgumentException`异常；也可以当场一种正常行为，直接返回空字符串。但要在函数注释中声明。

  对于这个ID生成器来说，`length==0的`情况也不合理，属于异常行为。不然，1ms内的调用全部会重复。

重构后的代码如下。

```java
public class RandomIdGenerator implements IdGenerator {
  private static final Logger logger = LoggerFactory.getLogger(RandomIdGenerator.class);

  @Override
  public String generate() throws IdGenerationFailureException {
    String substrOfHostName = null;
    try {
      substrOfHostName = getLastFieldOfHostName();
    } catch (UnknownHostException e) {
      throw new IdGenerationFailureException("...", e);
    }
    long currentTimeMillis = System.currentTimeMillis();
    String randomString = generateRandomAlphameric(8);
    String id = String.format("%s-%d-%s",
            substrOfHostName, currentTimeMillis, randomString);
    return id;
  }

  private String getLastFieldOfHostName() throws UnknownHostException{
    String substrOfHostName = null;
    String hostName = InetAddress.getLocalHost().getHostName();
    if (hostName == null || hostName.isEmpty()) {
      throw new UnknownHostException("...");
    }
    substrOfHostName = getLastSubstrSplittedByDot(hostName);
    return substrOfHostName;
  }

  @VisibleForTesting
  protected String getLastSubstrSplittedByDot(String hostName) {
    if (hostName == null || hostName.isEmpty()) {
      throw new IllegalArgumentException("...");
    }

    String[] tokens = hostName.split("\\.");
    String substrOfHostName = tokens[tokens.length - 1];
    return substrOfHostName;
  }

  @VisibleForTesting
  protected String generateRandomAlphameric(int length) {
    if (length <= 0) {
      throw new IllegalArgumentException("...");
    }

    char[] randomChars = new char[length];
    int count = 0;
    Random random = new Random();
    while (count < length) {
      int maxAscii = 'z';
      int randomAscii = random.nextInt(maxAscii);
      boolean isDigit= randomAscii >= '0' && randomAscii <= '9';
      boolean isUppercase= randomAscii >= 'A' && randomAscii <= 'Z';
      boolean isLowercase= randomAscii >= 'a' && randomAscii <= 'z';
      if (isDigit|| isUppercase || isLowercase) {
        randomChars[count] = (char) (randomAscii);
        ++count;
      }
    }
    return new String(randomChars);
  }
}
```

相比之前的检测标准，还有一些点没有修改。

但是答题思路讲到了。