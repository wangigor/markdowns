# 规范与重构

## 重构

> 「重构」这个词大家都不陌生。
>
> - 大部分人都是『听得多看得少』。
> - 真正进行过代码重构的人不多。
> - **把持续重构作为开发的一部分的人，更是少之又少。**

一方面，**重构代码是对工程师能力的要求，比单纯写代码高得多。**

重构需要能洞察出代码存在的坏味道或者设计上的不足，并且能合理、熟练地利用设计思想、原则、模式、编程规范等理论知识解决这些问题。

另一方面，**对为什么要重构、到底重构什么、什么时候重构、如何重构等相关问题理解不深。**

对重构没有系统性、全局性的认识，面对一堆烂代码，没有重构技巧的指导，只能想到哪改到哪，并不能全面地改善代码质量。

### 为什么要重构

> 软件设计大师Martin Fowler是这样定义重构的：『**重构是一种对软件内部结构的改善，目的是在不改变软件的可见行为的情况下，使其更容易理解，修改成本更低**』。
>
> 这个定义中有一个值得强调的点『重构不改变外部的可见行为』。我们可以把重构理解为，在保持功能不变的前提下，利用设计思想、原则、模式、编程规范等理论来优化代码，修改设计上的不足，提高代码质量。

首先，**重构是时刻保证代码质量的一个极其有效的手段，不至于让代码腐化到无可救药的地步**。

项目在演进，代码在不停的堆砌。如果没有人为代码的质量负责，代码总是会往越来越混乱的方向演化。当混乱到一定程度之后，量变引起质变，项目的维护成本已经高过重新开发一套新代码的成本，想要再去重构，已经没人能够做到了。

其次，**优秀的代码和框架不是一开始就能完全设计好的**。

就像优秀的公司和产品也都是迭代出来的。我们无法100%预见未来的需求，也没有足够的精力、时间、资源为遥远的未来买单。所以随着系统的演进，重构代码是不可避免的。

最后，**重构是避免过度设计的有效手段**。

在我们维护代码的过程中，真正遇到问题的时候再对代码进行重构，能有效避免前期投入太多时间做过度的设计，能够有的放矢。

**除此之代，重构对一个工程师本身技术的成长也有重要的意义。**

- 重构实际上是对我们学习的经典设计思想、设计原则、设计模式、编程规范的一种应用。重构是一个很好的能够锻炼我们熟练使用这些理论知识能力的实践场景。

- 平时堆砌业务逻辑，总会觉得没啥成长。而将一个比较烂的代码重构成一个比较好的代码，会很有成就感。

- 重构能力也是衡量一个工程师代码能力的有效手段。

  所谓「初级工程师在维护代码，高级工程师在设计代码，资深工程师在重构代码」，这句话意思就是说：

  初级工程师在已有代码框架下修改bug，修改添加功能代码。

  高级工程师从零开始设计代码结构、搭建代码框架。

  资深工程师为代码质量负责，需要发掘代码存在的问题，重构代码，时刻保持代码质量处于一个可控的状态。

  > 当然，这里的初级、高级、资深只是一个相对的概念，并不是一个确定的职级。

### 到底重构什么

> 根据重构的规模，可以笼统的分为大规模高层次重构「大重构」和小规模低层次重构「小重构」。

**大重构**，指的是对顶层代码设计的重构。

- 重构目标：包括系统、模块、代码结构、类与类之间的关系等。
- 重构手段：分层、模块化、解耦、抽象可复用组件等等。
- 重构工具：设计思想、设计原则和经典设计模式。

涉及改动代码会比较多，影响面比较大，难度也不较大，耗时会比较长，引入bug的风险也就比较大。

**小重构**，指的是对代码细节的重构。

- 重构目标：主要针对类、函数、变量等代码级别的重构。
- 重构手段：规范命名、规范注释、消除超大类或函数、提取重复代码等等。
- 重构工具：编码规范。

修改的地方比较集中，比较简单，可操作性强，耗时比较短，引入bug的封箱相对来说比较小。

### 什么时候重构

> 是代码烂到一定程度之后才去重构吗？不是。
>
> 当代码真的烂到出现「开发效率低，招了很多人，天天加班，出活却不多，线上bug频发，领导发飙，中层束手无策，工程师抱怨不断，查找bug困难」的时候，基本上重构也无法解决问题了。

平时不注重代码质量，堆砌烂代码，是在维护不了了再大刀阔斧的重构、甚至重写。这样是不行的，有的时候项目代码太多，重构很难做的彻底，最后又搞出来一个「四不像」的怪物，那就更麻烦了。

寄希望于在代码烂到一定程度之后，集中重构解决所有问题是不现实的，我们必须探索一条『**可持续、可演进**』的方式：**==持续重构==**。平时没有事情的时候，看看项目中有哪些写的不够好的、可以优化的代码，主动重构一下。或者，在修改、添加某个功能代码的时候，顺手把不符合编码规范、不好的设计重构一下。就像把单元测试、Code Review作为开发的一部分，我们如果能把持续重构也作为开发的一部分，成为一种开发习惯，对项目、对自己都会很有好处。

**重构的能力很重要，但持续重构的意识更重要**。

技术在更新、需求在变化、人员在流动，代码质量总会下降，代码总会存在不完美，重构就会持续在进行。

时刻具有持续重构意识，才能避免开发初期就过度设计，避免代码维护过程中的质量下降。

而那些看到别人代码有点瑕疵就一顿乱骂，或者花尽心思去构思一个完美设计的人，往往都是因为没有树立正确的代码质量观，没有持续重构意识。

### 如何重构

- 对于大重构来说。

  涉及模块、代码比较多，如果代码质量比较差，耦合比较严重，往往牵一发而动全身。

  > 如果计划一天完成，你会发现越改越多、越改越乱。而新的业务开发又与重构相冲突，最后只能半途而废，revert调所有的改动，很失落的又去堆砌烂代码了。
  >
  
  要提前做好完善的重构计划，有条不紊的分阶段来进行。每个阶段完成一小部分代码的重构，然后提交、测试、运行，发现没有问题之后，再继续进行下一阶段的重构，保证代码仓库的代码一直处于可运行、逻辑正确的状态。每个阶段我们都要控制好重构影响到的代码范围，考虑好如何兼容老代码的逻辑，必须的时候还需要写一些兼容过度代码。
  
  只有这样我们才能让每一阶段的重构不至于耗时太长「最好一天就能完成」，不至于与新功能开发相冲突。
  
  大规模高层次的重构一定是有组织、有计划，并且非常谨慎的，需要有经验、熟悉业务的资深同事来主导。
  
- 对于小重构来说。

  影响范围小，改动耗时短。所以只要有时间且愿意，随时都可以去做。

  除了人工去发现低层次的代码问题，还可以借助很多乘数的静态代码分析工具「比如CheckStyle、FindBugs、PMD、sonar等」来自动发现代码中的问题，然后针对性的进行重构优化。

> 对于重构这件事情，资深的工程师、项目 leader 要负起责任来，没事就重构一下代码，时刻保证代码质量处在一个良好的状态。否则，一旦出现“破窗效应”，一个人往里堆了一些烂代码，之后就会有更多的人往里堆更烂的代码。毕竟往项目里堆砌烂代码的成本太低了。不过，保持代码质量最好的方法还是打造一种好的技术氛围，以此来驱动大家主动去关注代码质量，持续重构代码。

## 单元测试

> 如果面对项目中的烂代码，也像重构一下，但又担心重构之后出问题，出力不讨好。特别是如果重构的是别的同事开发的代码，又不是特别熟悉，在没有任何保障的情况下，重构引入bug的风险还是很大的。
>
> 怎么能够保证重构不出错呢？
>
> 需要账务各种设计原则、思想、模式，还需要对所重构代码和业务有足够的了解。除了这些个人能力因素之外，最可靠的执行、最有效的保证重构不出错的手段应该就是**单元测试**了。
>
> 当重构完成之后，如果新的代码仍然能通过单元测试，那就说明代码原有逻辑的正确性未被破坏，原有的外部可见行为未变，符合重构的定义。

### 什么是单元测试

单元测试由研发工程师自己编写，用来测试自己写的代码的正确性。

> 常常将它跟基层测试放到一块对比，单元测试相对于集成测试来说，测试的粒度更小。继承测试的测试对象是整个系统或者某个功能模块，比如测试用户注册、登录功能是否正常，以一种端到端「end to end」的测试。而单元测试的测试对象是类或者函数，用来测试这个类和函数是否都按照预期的逻辑执行。
>
> 这是代码层级的测试。

举个例子。

```java
public class Text {
  private String content;

  public Text(String content) {
    this.content = content;
  }

  /**
   * 将字符串转化成数字，忽略字符串中的首尾空格；
   * 如果字符串中包含除首尾空格之外的非数字字符，则返回null。
   */
  public Integer toNumber() {
    if (content == null || content.isEmpty()) {
      return null;
    }
    //...省略代码实现...
    return null;
  }
}
```

如果我们要测试`Test`类中的`toNumber()`函数的正确定，应该如何编写单元测试呢？

> 写单元测试本身不需要什么高深技术。
>
> 它更多的是考研程序员思维的缜密程度，看能否设计出覆盖各种正常及异常情况的测试用例，来保证代码在任何预期或非预期的情况下都能正确运行。

为了保证测试的全面性，针对`toNumber()`函数，我们需要设计下面几个测试用例。

- 如果字符串只包含数字：”123“，输出对应的整数：123。
- 如果字符串为空或者null，输出null。
- 如果字符串首尾有空格：” 123“/"123 "/" 123 "，输出对应的整数：123。
- 如果字符串包含多个首尾空格：”   123    “，输出对应的整数：123。
- 如果字符串包含非数字字符：”123a4“/"123 4"，输出null。

剩下的就是将其翻译成代码了。

```java

public class Assert {
  public static void assertEquals(Integer expectedValue, Integer actualValue) {
    if (actualValue != expectedValue) {
      String message = String.format(
              "Test failed, expected: %d, actual: %d.", expectedValue, actualValue);
      System.out.println(message);
    } else {
      System.out.println("Test succeeded.");
    }
  }

  public static boolean assertNull(Integer actualValue) {
    boolean isNull = actualValue == null;
    if (isNull) {
      System.out.println("Test succeeded.");
    } else {
      System.out.println("Test failed, the value is not null:" + actualValue);
    }
    return isNull;
  }
}

public class TestCaseRunner {
  public static void main(String[] args) {
    System.out.println("Run testToNumber()");
    new TextTest().testToNumber();

    System.out.println("Run testToNumber_nullorEmpty()");
    new TextTest().testToNumber_nullorEmpty();

    System.out.println("Run testToNumber_containsLeadingAndTrailingSpaces()");
    new TextTest().testToNumber_containsLeadingAndTrailingSpaces();

    System.out.println("Run testToNumber_containsMultiLeadingAndTrailingSpaces()");
    new TextTest().testToNumber_containsMultiLeadingAndTrailingSpaces();

    System.out.println("Run testToNumber_containsInvalidCharaters()");
    new TextTest().testToNumber_containsInvalidCharaters();
  }
}

public class TextTest {
  public void testToNumber() {
    Text text = new Text("123");
    Assert.assertEquals(123, text.toNumber());
  }

  public void testToNumber_nullorEmpty() {
    Text text1 = new Text(null);
    Assert.assertNull(text1.toNumber());

    Text text2 = new Text("");
    Assert.assertNull(text2.toNumber());
  }

  public void testToNumber_containsLeadingAndTrailingSpaces() {
    Text text1 = new Text(" 123");
    Assert.assertEquals(123, text1.toNumber());

    Text text2 = new Text("123 ");
    Assert.assertEquals(123, text2.toNumber());

    Text text3 = new Text(" 123 ");
    Assert.assertEquals(123, text3.toNumber());
  }

  public void testToNumber_containsMultiLeadingAndTrailingSpaces() {
    Text text1 = new Text("  123");
    Assert.assertEquals(123, text1.toNumber());

    Text text2 = new Text("123  ");
    Assert.assertEquals(123, text2.toNumber());

    Text text3 = new Text("  123  ");
    Assert.assertEquals(123, text3.toNumber());
  }

  public void testToNumber_containsInvalidCharaters() {
    Text text1 = new Text("123a4");
    Assert.assertNull(text1.toNumber());

    Text text2 = new Text("123 4");
    Assert.assertNull(text2.toNumber());
  }
}
```

这里没有使用任何测试框架。

### 为什么要写单元测试

> 单元测试除了能有效的为重构保驾护航之外，也是保证代码质量最有效的手段之一。

#### 单元测试能有效地帮你发现代码中的bug

能否写出`bug free`的代码，是判断工程师代码能力的重要标准之一。

> 在离开 Google 之后，尽管我「王争」就职的很多公司，其开发模式都是“快、糙、猛”，对单元测试根本没有要求，但我还是坚持为自己提交的每一份代码，都编写完善的单元测试。**得益于此，我写的代码几乎是 bug free 的。这也节省了我很多 fix 低级 bug 的时间，能够有时间去做其他更有意义的事情，我也因此在工作上赢得了很多人的认可。**可以这么说，坚持写单元测试是保证我的代码质量的一个“杀手锏”，也是帮助我拉开与其他人差距的一个“小秘密”。

#### 写单元测试能帮你发现代码设计上的问题

> 前面提到，代码的可测试性是判断代码质量的一个重要标准。

对于一段代码，如果很难为其编写单元测试，或者单元测试写起来很吃力，需要依靠单元测试框架里很高级的特性才能完成，那往往意味着代码设计的不够合理，比如，没有使用依赖注入、大量使用静态函数、全局变量、代码高度耦合等。

#### 单元测试是对集成测试的有力补充

**程序运行的bug往往出现在一些边界条件、异常情况下。**比如除数未判空、网络超时。而大部分异常情况都比较难在测试环境中模拟。而单元测试可以利用mock的方式，控制mock的代码返回我们需要模拟的异常，来测试代码在这些异常情况的表现。

除此之外，**对于一些复杂系统来说，集成测试无法覆盖全面**。复杂系统往往有很多模块，每个模块都有各种输入、输出、异常情况，组合起来整个系统就有无数测试场景需要模拟，无数的测试用例需要设计，在强大的测试团队也无法穷举完备。

尽管单元测试无法完全替代集成测试，但如果我们能保证每个类、每个函数都能按照我们的预期执行，底层bug少了，那组装起来的整个系统，出问题的概率也就相应减少了。

#### 写单元测试的过程本身就是代码重构的过程

> 前面提到，要把持续重构作为开发的一部分执行，那写单元测试实际上就是落地执行持续重构的一个有效途径。

设计和实现代码的时候，很难把所有问题都想清楚。而编写单元测试就相当于对代码的一次自我code review。

在这个过程中，或许可以发现一些设计上的问题「比如代码设计的不可测试」以及代码编写方便的问题「比如一些边界条件处理不当」等，然后针对性的进行重构。

#### 阅读单元测试能帮助你快速熟悉代码

> 阅读代码最有效的手段，就是先去了解它的业务背景和设计思路，然后再去看代码，这样代码读起来就会轻松很多。

但是，很多程序员都不怎么喜欢写文档和注释，而大部分代码又很难做到『不言自明』。在没有文档和注释的情况下，单元测试就起到了替代性作用。

**单元测试用例实际上就是用户用例，反映了代码的功能和如何使用。**借助单元测试，我们不需要深入的阅读代码，便能知道代码实现了什么功能，有哪些特殊情况需要考虑，有哪些边界条件需要处理。

#### 单元测试是TDD可落地执行的改进方案

> 测试驱动开发「Test-Driven Development 简称TDD」是一个经常被提及但很少被执行的开发模式。
>
> 核心思想就是测试用例先于代码编写。
>
> 不过执行下去挺难得，毕竟如果连单元测试都懒得写，更何况在编写代码之前先写好测试用例了。

单元测试正好是对TDD的一种改进方案，先写代码，紧接着写单元测试，然后根据单元测试返回出来的问题，再回头去重构代码。这个开发流程就很容易被接收，更加容易落地执行，并且又兼顾了TDD的优点。

### 如何编写单元测试

> 写单元测试就是针对代码设计覆盖各种输入、异常、边界条件的测试用例，并将这些测试用例翻译成代码的过程。

在把测试用例翻译成代码的时候，我们可以利用单元测试框架，来简化测试代码的编写。

比如，Junit、TestNG、Spring Test等。这些框架提供了通用的执行流程「比如执行测试用例的TestCaseRunner」和工具类库「比如各种Assert判断函数」，在编写测试代码的时候，只需要关注测试用例本身的编写即可。

还是以之前的`Test.toNumber()`为例，使用Junit单元测试框架重新实现以下。

```java

import org.junit.Assert;
import org.junit.Test;

public class TextTest {
  @Test
  public void testToNumber() {
    Text text = new Text("123");
    Assert.assertEquals(new Integer(123), text.toNumber());
  }

  @Test
  public void testToNumber_nullorEmpty() {
    Text text1 = new Text(null);
    Assert.assertNull(text1.toNumber());

    Text text2 = new Text("");
    Assert.assertNull(text2.toNumber());
  }

  @Test
  public void testToNumber_containsLeadingAndTrailingSpaces() {
    Text text1 = new Text(" 123");
    Assert.assertEquals(new Integer(123), text1.toNumber());

    Text text2 = new Text("123 ");
    Assert.assertEquals(new Integer(123), text2.toNumber());

    Text text3 = new Text(" 123 ");
    Assert.assertEquals(new Integer(123), text3.toNumber());
  }

  @Test
  public void testToNumber_containsMultiLeadingAndTrailingSpaces() {
    Text text1 = new Text("  123");
    Assert.assertEquals(new Integer(123), text1.toNumber());

    Text text2 = new Text("123  ");
    Assert.assertEquals(new Integer(123), text2.toNumber());

    Text text3 = new Text("  123  ");
    Assert.assertEquals(new Integer(123), text3.toNumber());
  }

  @Test
  public void testToNumber_containsInvalidCharaters() {
    Text text1 = new Text("123a4");
    Assert.assertNull(text1.toNumber());

    Text text2 = new Text("123 4");
    Assert.assertNull(text2.toNumber());
  }
}
```

代码简化了很多。

- **写单元测试真的是件很耗时的事情吗？**

  尽管单元测试的代码量可能是被测试代码本身的1~2呗，写的过程很繁琐。但并不是很耗时，因为不需要考虑太多代码设计上的问题，测试代码实现起来比较简单。

  不同测试用例之间的代码差异可能不大，简单cv改改就行。

- **对单元测试的代码质量有什么要求吗？**

  单元测试代码不会在产线上运行，而且每个类的测试代码也比较独立，基本不互相依赖。

  所以相对于被测代码，单元测试代码的质量可以放低一些要求。命名稍微不规范、代码稍微有重复，也都不是什么大问题。

- **单元测试只要覆盖率高就够了吗？**

  单元测试覆盖率是比较容易量化的指标，常常作为单元测试写的好坏的评判标准。

  有很多线程的工具专门用来做覆盖率的统计，比如JaCoCo、Cobertura、Emma、Clover。覆盖率的计算方式有很多种，计较简单的是语句覆盖，稍微高级点的有：条件覆盖、判断覆盖、路径覆盖。

  不管覆盖率的计算方式如何高级，**将覆盖率作为衡量单元测试质量的唯一标准是不合理的。**

  比如：

  ```java
  public double cal(double a, double b) {
    if (b != 0) {
      return a / b;
    }
  }
  ```

  可以很容易做到100%覆盖率，比如`call(2.0,1.0)`。但并不代表测试足够全面了「还需要考虑除数为0的情况」。

  再比如，getter/setter方法，没有必要测试。

  从过往的经验上来讲，一个项目的单元测试覆盖率在 60～70% 即可上线。如果项目对代码质量要求比较高，可以适当提高单元测试覆盖率的要求。

- **写单元测试需要了解代码的实现逻辑吗？**

  单元测试不要依赖被测试函数的具体实现逻辑，只需要关心被测函数实现了什么功能。

  否则，针对实现逻辑编写单元测试，一旦代码重构，在代码外部行为不变的情况下，对代码的实现逻辑进行了修改，那原本的单元测试都会运行失败，也就起不到保驾护航的作用了。

- **如果选择单元测试框架？**

  单元测试本身不需要复杂计数，大部分单元测试框架都能满足。

  团队内部统一就行。

  如果自己写的代码用已经选定的单元测试框架无法测试，多半是代码写的不够好，代码的可测试性不够好。重构代码，让其容易测试，而不是去找另一个更加高级的单元测试框架。

### 单元测试为何难落地

> 虽然很多书籍中都会讲到，单元测试是保证重构不出错的有效手段；也有非常多人已经认识到单元测试的重要性。
>
> 但是有多少项目有完善的、高质量的单元测试呢？据我了解，真的非常非常少，包括 BAT 这样级别公司的项目。如果不相信的话，你可以去看一下国内很多大厂开源的项目，有很多项目完全没有单元测试，还有很多项目的单元测试写得非常不完备，仅仅测试了逻辑是否运行正确而已。所以，100% 落实执行单元测试是件“知易行难”的事。

写单元测试确实是一件考验耐心的活儿。一般情况下，单元测试的代码量要大于被测试代码量，甚至是要多出好几倍。很多人往往会觉得写单元测试比较繁琐，并且没有太多挑战，而不愿意去做。有很多团队和项目在刚开始推行单元测试的时候，还比较认真，执行得比较好。**但当开发任务紧了之后，就开始放低对单元测试的要求，一旦出现破窗效应，慢慢的，大家就都不写了，这种情况很常见。**

还有一种情况就是，由于历史遗留问题，原来的代码都没有写单元测试，代码已经堆砌了十几万行了，不可能再一个一个去补单元测试。这种情况下，**我们首先要保证新写的代码都要有单元测试，其次，每次在改动到某个类时，如果没有单元测试就顺便补上，不过这要求工程师们有足够强的主人翁意识（ownership），毕竟光靠 leader 督促，很多事情是很难执行到位的。**

除此之外，还有人觉得，有了测试团队，写单元测试就是浪费时间，没有必要。程序员这一行业本该是智力密集型的，但现在很多公司把它搞成劳动密集型的，包括一些大厂，在开发过程中，既没有单元测试，也没有 Code Review 流程。即便有，做的也是差强人意。写好代码直接提交，然后丢给黑盒测试狠命去测，测出问题就反馈给开发团队再修改，测不出的问题就留在线上出了问题再修复。

**在这样的开发模式下，团队往往觉得没有必要写单元测试，但如果我们把单元测试写好、做好 Code Review，重视起代码质量，其实可以很大程度上减少黑盒测试的投入。**我在 Google 的时候，很多项目几乎没有测试团队参与，代码的正确性完全靠开发团队来保障，线上 bug 反倒非常少。

现在互联网信息如此的公开透明，网上有很多文章可以参考，对于程序员这个具有很强学习能力的群体来说，学会如何写单元测试并不是一件难事，难的是能够真正感受到它的作用，并且打心底认可、能 100% 落地执行。

## 代码的可测试性

> 写单元测试并不难，也不需要太多技巧，相反，写出可测试的代码反倒是件非常有挑战的事情。

### 编写可测试代码案例实战

`Transaction`是经过抽象简化之后的一个电商系统的交易类，用来记录每笔订单交易的情况。

`execute()`函数负责执行转账操作，将钱从买家的钱包`buyerId`转到卖家的钱包`sellerId`中。

真正的转账操作是通过调用`WalletRpcService`远程调用服务来完成的。

代码中还涉及到一个分布式锁`DistributedLock`单例类，用来避免并发操作，导致用户的钱被重复转出。

```java
public class Transaction {
  private String id;
  private Long buyerId;
  private Long sellerId;
  private Long productId;
  private String orderId;
  private Long createTimestamp;
  private Double amount;
  private STATUS status;
  private String walletTransactionId;
  
  // ...get() methods...
  
  public Transaction(String preAssignedId, Long buyerId, Long sellerId, Long productId, String orderId) {
    if (preAssignedId != null && !preAssignedId.isEmpty()) {
      this.id = preAssignedId;
    } else {
      this.id = IdGenerator.generateTransactionId();
    }
    if (!this.id.startWith("t_")) {
      this.id = "t_" + preAssignedId;
    }
    this.buyerId = buyerId;
    this.sellerId = sellerId;
    this.productId = productId;
    this.orderId = orderId;
    this.status = STATUS.TO_BE_EXECUTD;
    this.createTimestamp = System.currentTimestamp();
  }
  
  public boolean execute() throws InvalidTransactionException {
    if ((buyerId == null || (sellerId == null || amount < 0.0) {
      throw new InvalidTransactionException(...);
    }
    if (status == STATUS.EXECUTED) return true;
    boolean isLocked = false;
    try {
      isLocked = RedisDistributedLock.getSingletonIntance().lockTransction(id);
      if (!isLocked) {
        return false; // 锁定未成功，返回false，job兜底执行
      }
      if (status == STATUS.EXECUTED) return true; // double check
      long executionInvokedTimestamp = System.currentTimestamp();
      if (executionInvokedTimestamp - createdTimestap > 14days) {
        this.status = STATUS.EXPIRED;
        return false;
      }
      WalletRpcService walletRpcService = new WalletRpcService();
      String walletTransactionId = walletRpcService.moveMoney(id, buyerId, sellerId, amount);
      if (walletTransactionId != null) {
        this.walletTransactionId = walletTransactionId;
        this.status = STATUS.EXECUTED;
        return true;
      } else {
        this.status = STATUS.FAILED;
        return false;
      }
    } finally {
      if (isLocked) {
       RedisDistributedLock.getSingletonIntance().unlockTransction(id);
      }
    }
  }
}
```

对比之前`Test`类的代码，这段代码要复杂很多。

- 正常情况下，交易成功。回填`walletTransactionId`、交易状态为`STATUS.EXECUTED`、返回true。
- `buyerId、sellerId`为空，`amount`小于0。抛出`InvalidTransactionException异常`
- 交易已过期「`createdTimestamp`超过14天」。交易状态为`STATUS.EXPIRED`，返回false。
- 交易重复执行「状态为`STATUS.EXECUTED`」,不在重复执行赚钱逻辑，直接返回true。
- 钱包转账RPC远程调用`WalletRpcService`失败。交易状态为`STATUS.FAILED`，返回false。
- 交易重复执行且未完成「获取分布式锁失败」。直接失败，返回false。

测试用例设计完了，但是测试用例落实到具体代码却很难。比如要编写测试用例1的代码实现：

```java
public void testExecute() {
  Long buyerId = 123L;
  Long sellerId = 234L;
  Long productId = 345L;
  Long orderId = 456L;
  Transction transaction = new Transaction(null, buyerId, sellerId, productId, orderId);
  boolean executedResult = transaction.execute();
  assertTrue(executedResult);
}
```

因为`execute()`函数依赖两个外部服务：`RedisDistributedLock`和`WalletRpcService`，会导致以下几个问题。

- 如果要让这个单元测试能够运行，我们需要搭建这两个外部服务，搭建和维护的成本比较高。

  而且对于单元测试来说没有必要。

- 如果我们需要保证将伪造的交易数据发送给远程服务之后，能够返回期望的结构，然而这个服务可能是第三方接口，对于我们来说并不可控。

- 远程调用需要走网络，耗时可能会比较长。对这个单元测试的执行性能也会有影响。

- 网络中断、超时、外部服务不可用，都会影响单元测试的执行结果。

然而**单元测试主要是测试程序员自己编写的代码逻辑的正确性，并非是端到端的集成测试，他不需要测试依赖的外部系统的逻辑正确性。**所以，如果代码中依赖了外部系统或者不可控组件，比如数据库、网络通信、文件系统等，我们就需要将这些被测代码与外部系统解依赖，这种解依赖的方法叫做**mock**。所谓mock就是用一个「假」服务替换真正的外部服务。mock服务完全在我们的控制之下，模拟输出我们想要的数据。

> mock方式有两种：**手动mock**和**利用框架mock**。
>
> 利用框架mock仅仅是为了简化代码编写，每个框架的mock方式不同。
>
> 常用的mock框架有：**Mockito**和**PowerMock**。
>
> **Mockito**是一个优秀的、最常用的单元测试mock框架，它能满足大部分时间的测试要求（public方法）。
>
> **PowerMock**可以去解决一些更难的问题（比如静态方法、私有方法、Final方法等），它是在 EasyMock 以及 Mockito 基础上的扩展，通过提供定制的类加载器以及一些字节码篡改，实现更强大的测试功能。

手动mock是通过继承，重写服务类来完成的。比如`WalletRpcService.moveMoney()`的mock：

```java
public class MockWalletRpcServiceOne extends WalletRpcService {
  public String moveMoney(Long id, Long fromUserId, Long toUserId, Double amount) {
    return "123bac";
  } 
}

public class MockWalletRpcServiceTwo extends WalletRpcService {
  public String moveMoney(Long id, Long fromUserId, Long toUserId, Double amount) {
    return null;
  } 
}
```

新的问题就来了：`execute()`函数内部通过new方式创建的`WalletRpcService`，没办法进行动态替换。

这就说明了`Transaction`的可测试性差，需要通过依赖注入进行重构。

将`WalletRpcService`对象的创建反转给上层逻辑，在外部创建好之后，再注入到`Transaction`对象中。

```java
public class Transaction {
  //...
  // 添加一个成员变量及其set方法
  private WalletRpcService walletRpcService;
  
  public void setWalletRpcService(WalletRpcService walletRpcService) {
    this.walletRpcService = walletRpcService;
  }
  // ...
  public boolean execute() {
    // ...
    // 删除下面这一行代码
    // WalletRpcService walletRpcService = new WalletRpcService();
    // ...
  }
}
```

进行了这一步重构之后，测试代码就可以写成

```java
public void testExecute() {
  Long buyerId = 123L;
  Long sellerId = 234L;
  Long productId = 345L;
  Long orderId = 456L;
  Transction transaction = new Transaction(null, buyerId, sellerId, productId, orderId);
  // 使用mock对象来替代真正的RPC服务
  transaction.setWalletRpcService(new MockWalletRpcServiceOne()):
  boolean executedResult = transaction.execute();
  assertTrue(executedResult);
  assertEquals(STATUS.EXECUTED, transaction.getStatus());
}
```

这是`WalletRpcService`的mock替换问题。再来看`RedisDistributedLock`。

`RedisDistributedLock`是一个单例类。相当于一个全局变量，我们无法继承或重写方法，也无法通过依赖注入的方式替换它。

如果这个服务使我们自己维护的，可以自由修改、重构。那可以将它改为非单例的模式，或者定义一个接口比如`IDistributedLock`，让`RedisDistributedLock`实现这个接口。我们就能通过上面的方式重写这个接口的mock实现了。

但如果这不是我们维护的，无权修改这一部分代码。

我们还可以对上锁逻辑进行重新封装，使代码可测试性更好。

```java
public class TransactionLock {
  public boolean lock(String id) {
    return RedisDistributedLock.getSingletonIntance().lockTransction(id);
  }
  
  public void unlock() {
    RedisDistributedLock.getSingletonIntance().unlockTransction(id);
  }
}

public class Transaction {
  //...
  private TransactionLock lock;
  
  public void setTransactionLock(TransactionLock lock) {
    this.lock = lock;
  }
 
  public boolean execute() {
    //...
    try {
      isLocked = lock.lock(id);
      //...
    } finally {
      if (isLocked) {
        lock.unlock(id);
      }
    }
    //...
  }
}
```

重构之后，测试用例就变成了下面这样。

```java
public void testExecute() {
  Long buyerId = 123L;
  Long sellerId = 234L;
  Long productId = 345L;
  Long orderId = 456L;
  
  TransactionLock mockLock = new TransactionLock() {
    public boolean lock(String id) {
      return true;
    }
  
    public void unlock() {}
  };
  
  Transction transaction = new Transaction(null, buyerId, sellerId, productId, orderId);
  transaction.setWalletRpcService(new MockWalletRpcServiceOne());
  transaction.setTransactionLock(mockLock);
  boolean executedResult = transaction.execute();
  assertTrue(executedResult);
  assertEquals(STATUS.EXECUTED, transaction.getStatus());
}
```

至此，测试用例1就写好了，我们通过代码重构「依赖注入」和mock，让单元测试代码不依赖任何外部不可控接口。那测试用例4、5、6都可以依此完成。

还有一个测试用例3的问题：交易过期「`createTimestamp`超过14天」。

```java
public void testExecute_with_TransactionIsExpired() {
  Long buyerId = 123L;
  Long sellerId = 234L;
  Long productId = 345L;
  Long orderId = 456L;
  Transction transaction = new Transaction(null, buyerId, sellerId, productId, orderId);
  //手动设置createdTimestamp
  transaction.setCreatedTimestamp(System.currentTimestamp() - 14days);
  boolean actualResult = transaction.execute();
  assertFalse(actualResult);
  assertEquals(STATUS.EXPIRED, transaction.getStatus());
}
```

但是，如果`createdTimestamp`没有暴露`setter`方法，而且不暴露是更符合业务场景的选择。因为这个字段理应在构造函数中，随对象创建自动生成，不应该人为修改。所以通过set方式重设createdTimestamp是不可能的。

> 这类问题也比较常见，就是**代码中包含跟「时间」有关的「未决行为」逻辑**。一般的处理方式就是将这种未决行为逻辑重新封装。

针对`Transaction`类，需要将「交易是否过期」的逻辑，封装到`isExired()`函数中。

```java
public class Transaction {

  protected boolean isExpired() {
    long executionInvokedTimestamp = System.currentTimestamp();
    return executionInvokedTimestamp - createdTimestamp > 14days;
  }
  
  public boolean execute() throws InvalidTransactionException {
    //...
      if (isExpired()) {
        this.status = STATUS.EXPIRED;
        return false;
      }
    //...
  }
}
```

测试用例3就变成了下面这样。

```java
public void testExecute_with_TransactionIsExpired() {
  Long buyerId = 123L;
  Long sellerId = 234L;
  Long productId = 345L;
  Long orderId = 456L;
  //匿名内部类
  Transction transaction = new Transaction(null, buyerId, sellerId, productId, orderId) {
    protected boolean isExpired() {
      return true;
    }
  };
  boolean actualResult = transaction.execute();
  assertFalse(actualResult);
  assertEquals(STATUS.EXPIRED, transaction.getStatus());
}
```

这个过期问题的测试用例就解决了。

还有问题吗？

可以有。比如构造函数中交易id的赋值逻辑中，`IdGenerator.generateTransactionId()`不知道是干什么的，或许会存在问题，最好也要测试一下。

为了保证这一部分逻辑的正确性和方便测试，可以把id赋值这部分逻辑单独抽象到一个函数中。

```java
  public Transaction(String preAssignedId, Long buyerId, Long sellerId, Long productId, String orderId) {
    //...
    fillTransactionId(preAssignId);
    //...
  }
  
  protected void fillTransactionId(String preAssignedId) {
    if (preAssignedId != null && !preAssignedId.isEmpty()) {
      this.id = preAssignedId;
    } else {
      this.id = IdGenerator.generateTransactionId();
    }
    if (!this.id.startWith("t_")) {
      this.id = "t_" + preAssignedId;
    }
  }
```

如果这个被测试方法不是`public`的，而是`private/protected`的。怎么测试？

如果你看过guava源码，就会发现一个很好用的注解`@VisibleForTesting`。可以解决这样的问题。

> 实际上，可测试性差的代码，本身代码设计得也不够好，很多地方都没有遵守我们之前讲到的设计原则和思想，比如“基于接口而非实现编程”思想、依赖反转原则等。重构之后的代码，不仅可测试性更好，而且从代码设计的角度来说，也遵从了经典的设计原则和思想。这也印证了我们之前说过的，代码的可测试性可以从侧面上反应代码设计是否合理。除此之外，在平时的开发中，我们也要多思考一下，这样编写代码，是否容易编写单元测试，这也有利于我们设计出好的代码。

### 常见反模式「anti-patterns」

> 经典的、常见的可测试性不好的代码总结。

#### 未决行为

未决行为逻辑就是，代码的输出是随机或者说不确定的，比如跟时间、随机数有关的代码。

可以抽成函数。

#### 全局变量

滥用全局变量也让编写单元测试变得困难。

比方说，`RangeLimiter`是一个[ -5 , 5 ]区间，初始化位置`position`在0，`move()`函数负责移动`position`返回是否移动出规定区间。

```java
public class RangeLimiter {
  private static AtomicInteger position = new AtomicInteger(0);
  public static final int MAX_LIMIT = 5;
  public static final int MIN_LIMIT = -5;

  public boolean move(int delta) {
    int currentPos = position.addAndGet(delta);
    boolean betweenRange = (currentPos <= MAX_LIMIT) && (currentPos >= MIN_LIMIT);
    return betweenRange;
  }
}

public class RangeLimiterTest {
  public void testMove_betweenRange() {
    RangeLimiter rangeLimiter = new RangeLimiter();
    assertTrue(rangeLimiter.move(1));
    assertTrue(rangeLimiter.move(3));
    assertTrue(rangeLimiter.move(-5));
  }

  public void testMove_exceedRange() {
    RangeLimiter rangeLimiter = new RangeLimiter();
    assertFalse(rangeLimiter.move(6));
  }
}
```

`position`是类的静态变量，对于测试方法`testMove_betweenRange`和`testMove_exceedRange`来说，虽然都是`new RangeLimiter()`，但是共用`position`。那**单元测试结果可能会受到测试框架的影响**。

比如单元测试框架顺序执行两个测试用例：用例1执行完之后`position`值是-1，再执行用例2的时候，`position`值是5，返回true。用例2就运行失败了。

那，如果在每个测试用例之前都对`position`进行「清零」操作，可以解决上面的问题，但是无法解决并发问题。

比如单元测试框架是并行执行所有测试用例，即便每次都清零，16、17、18跟23行代码会存在并发问题，影响测试结果。

#### 静态方法

很难mock。

#### 复杂继承

相比组合关系，继承关系的代码结构更加耦合、不灵活、更加不易扩展、不易维护。实际上，继承关系也很难测试。

如果父类需要mock某一个依赖对象才能进行单元测试，那所有的子类、子类的子类……在编写单元测试的时候都要mock这个依赖对象。对于继承层次很深「纵向」、结构复杂「横向」的继承关系，继承越深的子类要mock的对象可能就会越多，这样就会导致，子类单元测试编写的时候，需要mock很多父类依赖对象，而且需要查看父类代码，去了解如何mock这些依赖。

如果我们利用组合而非继承，类之间的结构层次比较扁平，在编写单元测试的时候，只需要mock类所依赖的对象就行。

#### 高耦合代码

如果一个类的职责很重，需要依赖十几个外部对象才能完成工作，代码高度耦合。

那在编写单元测试的时候，可能需要mock十几个依赖对象。

不管是从代码设计的角度来说，还是从编写单元测试的角度来说，都是不合理的。



## 解耦

## 快速改善代码质量的20条编程规范

