# 工厂模式

## 工厂模式

### 简单工厂模式

举个例子。

根据配置文件的后缀「json/xml/yaml/properties」，选择不同的解析器「JsonRuleConfigParser、XmlRuleConfigParser……」将存储在文件中的配置解析成内存对象RuleConfig。

```java
public class RuleConfigSource {
  public RuleConfig load(String ruleConfigFilePath) {
    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);
    IRuleConfigParser parser = null;
    if ("json".equalsIgnoreCase(ruleConfigFileExtension)) {
      parser = new JsonRuleConfigParser();
    } else if ("xml".equalsIgnoreCase(ruleConfigFileExtension)) {
      parser = new XmlRuleConfigParser();
    } else if ("yaml".equalsIgnoreCase(ruleConfigFileExtension)) {
      parser = new YamlRuleConfigParser();
    } else if ("properties".equalsIgnoreCase(ruleConfigFileExtension)) {
      parser = new PropertiesRuleConfigParser();
    } else {
      throw new InvalidRuleConfigException(
             "Rule config file format is not supported: " + ruleConfigFilePath);
    }

    String configText = "";
    //从ruleConfigFilePath文件中读取配置文本到configText中
    RuleConfig ruleConfig = parser.parse(configText);
    return ruleConfig;
  }

  private String getFileExtension(String filePath) {
    //...解析文件名获取扩展名，比如rule.json，返回json
    return "json";
  }
}
```

**为了让代码逻辑更加清晰，可读性更好，需要将功能独立的代码封装成函数。**

按照这个思路，我们把其中涉及`parser`创建的部分逻辑单独成一个`createParser()`函数。

```java
  public RuleConfig load(String ruleConfigFilePath) {
    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);
    IRuleConfigParser parser = createParser(ruleConfigFileExtension);
    if (parser == null) {
      throw new InvalidRuleConfigException(
              "Rule config file format is not supported: " + ruleConfigFilePath);
    }

    String configText = "";
    //从ruleConfigFilePath文件中读取配置文本到configText中
    RuleConfig ruleConfig = parser.parse(configText);
    return ruleConfig;
  }

  private String getFileExtension(String filePath) {
    //...解析文件名获取扩展名，比如rule.json，返回json
    return "json";
  }

  private IRuleConfigParser createParser(String configFormat) {
    IRuleConfigParser parser = null;
    if ("json".equalsIgnoreCase(configFormat)) {
      parser = new JsonRuleConfigParser();
    } else if ("xml".equalsIgnoreCase(configFormat)) {
      parser = new XmlRuleConfigParser();
    } else if ("yaml".equalsIgnoreCase(configFormat)) {
      parser = new YamlRuleConfigParser();
    } else if ("properties".equalsIgnoreCase(configFormat)) {
      parser = new PropertiesRuleConfigParser();
    }
    return parser;
  }
```

为了让类的职责更加单一、代码更加清晰，需要将`createParser()`函数剥离到一个独立中，这个类只负责`IRuleConfigParser`对象的创建。

```java
public class RuleConfigSource {
  public RuleConfig load(String ruleConfigFilePath) {
    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);
    IRuleConfigParser parser = RuleConfigParserFactory.createParser(ruleConfigFileExtension);
    if (parser == null) {
      throw new InvalidRuleConfigException(
              "Rule config file format is not supported: " + ruleConfigFilePath);
    }

    String configText = "";
    //从ruleConfigFilePath文件中读取配置文本到configText中
    RuleConfig ruleConfig = parser.parse(configText);
    return ruleConfig;
  }

  private String getFileExtension(String filePath) {
    //...解析文件名获取扩展名，比如rule.json，返回json
    return "json";
  }
}

public class RuleConfigParserFactory {
  public static IRuleConfigParser createParser(String configFormat) {
    IRuleConfigParser parser = null;
    if ("json".equalsIgnoreCase(configFormat)) {
      parser = new JsonRuleConfigParser();
    } else if ("xml".equalsIgnoreCase(configFormat)) {
      parser = new XmlRuleConfigParser();
    } else if ("yaml".equalsIgnoreCase(configFormat)) {
      parser = new YamlRuleConfigParser();
    } else if ("properties".equalsIgnoreCase(configFormat)) {
      parser = new PropertiesRuleConfigParser();
    }
    return parser;
  }
}
```

`RuleConfigParserFactory`这个类就是简单工厂模式类。

> 大多数工厂类都是以`Factory`单词结尾。
>
> **但这不是必须的**。比如`DateFormat`、`Calender`。
>
> 一般创建对象的方法都是以`create`开头。但也还有其他的，比如`getInstance()`、`newInstance()`、`valueOf()`、`of`等等。

在上面的代码中，每次调用`RuleConfigParserFactory.createParser()`方法时，都会创建一个`parser`对象。实际上，这些`parser`是可以复用的，为了节省内存和对象创建的时间，可以将`parser`事先创建好并保存起来，调用`createParser()`时直接拿来用就好。

这有点类似**单例模式-饿汉式**和**简单工厂模式**的结合。

```java
public class RuleConfigParserFactory {
  private static final Map<String, RuleConfigParser> cachedParsers = new HashMap<>();

  static {
    cachedParsers.put("json", new JsonRuleConfigParser());
    cachedParsers.put("xml", new XmlRuleConfigParser());
    cachedParsers.put("yaml", new YamlRuleConfigParser());
    cachedParsers.put("properties", new PropertiesRuleConfigParser());
  }

  public static IRuleConfigParser createParser(String configFormat) {
    if (configFormat == null || configFormat.isEmpty()) {
      return null;//返回null还是IllegalArgumentException全凭你自己说了算
    }
    IRuleConfigParser parser = cachedParsers.get(configFormat.toLowerCase());
    return parser;
  }
}
```



> 那么问题来了：如果需要添加新的`parser`就势必要带动`RuleConfigParserFactory`的代码，这不是违反了「开闭原则」吗？
>
> - 如果不需要频繁添加新的`parser`，偶尔「长间隔」修改一下`RuleConfigParserFactory`代码，完全可以接受。
> - 为了符合开闭原则，则需要为每一个`if`分支创建一个单独的类。
>   - 如果`if`分支不多，完全没必要这么做。
>   - 而创建逻辑目前只是简单的`new`对象，为了符合开闭原则反而增加了类的个数「每个类里只有一个`new`语句」，牺牲了代码的可读性。
>
> 这么权衡下来，虽然违反开闭原则，但是合理。



### 工厂方法模式

### 抽象工厂模式

## spring DI框架原理

