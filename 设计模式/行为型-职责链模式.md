# 行为型-职责链模式

## 概述

## Tomcat pipeline 源码解析

> 请求到达`connector`之后，经过`CoyoteAdapter`处理请求之后，会一次经过`engine`、`host`、`context`、`wrapper`最后到达`servlet`的调用链「`ApplicationFilterChain`」。
>
> 在`engine`、`host`、`context`、`wrapper`这4层组件之间，tomcat使用`pipeline`进行职责链式调用。

先来看一下这一部分结构。

![image-20240108172646021](https://wangigor-typora-images.oss-cn-chengdu.aliyuncs.com/image-20240108172646021.png)

- `engine`、`host`、`context`、`wrapper`各个组件tomcat都提供了标准实现类`StandardEngine`、`StandardHost`、`StandardContext`、`StandardWrapper`。
- 4个组件都继承了`ContainerBase`类。
- `ContainerBase`类实例化的时候初始化了一个`StandardPipeline`的`pipeline`组件，这就是tomcat中职责链的核心组件

### pipeline和valve

`pipeline`和`valve`是链表结构，`valve`作为链表节点。

`valve`接口结构如下。

```java
public interface Valve {
		
  	//获取下一个节点
    public Valve getNext();

		//设置下一个节点
    public void setNext(Valve valve);

    //执行
    public void invoke(Request request, Response response)
        throws IOException, ServletException;
}
```

`pipeline`接口结构如下

```java
public interface Pipeline extends Contained {

		//获取链尾节点
    public Valve getBasic();

		//设置链尾节点
    public void setBasic(Valve valve);

    //添加链上节点
    public void addValve(Valve valve);

		//获取链表节点
    public Valve[] getValves();

    //删除节点
    public void removeValve(Valve valve);

		//获取第一个链表节点
    public Valve getFirst();
}
```

- `pipeline`的链表是一个单向链表。
- `first`作为头节点，`basic`作为尾节点调用下一层组件`pipeline`。
- 每一个`valve`责任独立。

![截屏 2024-01-09 09.30.11](https://wangigor-typora-images.oss-cn-chengdu.aliyuncs.com/截屏 2024-01-09 09.30.11.jpeg)

- `addValve`源码

  自定义节点添加会走到这里

  ```java
      public void addValve(Valve valve) {
  
          // 从first开始遍历，添加到basic之前。
          if (first == null) {
              first = valve;
              valve.setNext(basic);
          } else {
              Valve current = first;
              while (current != null) {
                  if (current.getNext() == basic) {
                      current.setNext(valve);
                      valve.setNext(basic);
                      break;
                  }
                  current = current.getNext();
              }
          }
  				//触发添加valve事件
          container.fireContainerEvent(Container.ADD_VALVE_EVENT, valve);
      }
  ```

- `setBasic`源码

  ```java
  	public void setBasic(Valve valve) {
  
          // Change components if necessary
          Valve oldBasic = this.basic;
          if (oldBasic == valve) {
              return;
          }
  
          // 如果有已经存在的basic节点，替换。
          Valve current = first;
          while (current != null) {
              if (current.getNext() == oldBasic) {
                  current.setNext(valve);
                  break;
              }
              current = current.getNext();
          }
  				//当前节点设置为basic节点
          this.basic = valve;
  	}
  ```

### 各组件标准basic节点和自定义节点

#### 标准basic节点

每一个层级「`engine`、`host`、`context`、`wrapper`」都设置了自己默认的basic节点，命名是`Stand*Valve`格式。

在各节点实例化的时候，实例化`Stand*Valve`并设置为本节点`pipeline`的`basic`节点。

- `StandardEngine`

  ```java
      public StandardEngine() {
          super();
        	//设置basic为StandardEngineValve
          pipeline.setBasic(new StandardEngineValve());
      }
  ```

  `StandardEngineValve`负责调用`host.pipeline.first`

  ```java
  //StandardEngineValve
  public final void invoke(Request request, Response response)
      throws IOException, ServletException {
  
      // Ask this Host to process this request
      host.getPipeline().getFirst().invoke(request, response);
  }
  ```

- `StandardHost`

  ```java
  public StandardHost() {
  
      super();
      //设置basic为StandardHostValve
      pipeline.setBasic(new StandardHostValve());
  
  }
  ```

  `StandardHostValve`负责调用`context.pipeline.first`

  ```java
  public final void invoke(Request request, Response response)
      throws IOException, ServletException {
  
      //忽略其他异常处理相关代码
    
    	//调用下一层级context
  		context.getPipeline().getFirst().invoke(request, response);
  }
  ```

- `StandardContext`

  ```java
  public StandardContext() {
  
      super();
      //设置basic为StandardContextValve
      pipeline.setBasic(new StandardContextValve());
  
  }
  ```

  `StandardContextValve`负责调用`wrapper.pipeline.first`

  ```java
  public final void invoke(Request request, Response response)
      throws IOException, ServletException {
  
      // Disallow any direct access to resources under WEB-INF or META-INF
      MessageBytes requestPathMB = request.getRequestPathMB();
      if ((requestPathMB.startsWithIgnoreCase("/META-INF/", 0))
              || (requestPathMB.equalsIgnoreCase("/META-INF"))
              || (requestPathMB.startsWithIgnoreCase("/WEB-INF/", 0))
              || (requestPathMB.equalsIgnoreCase("/WEB-INF"))) {
          response.sendError(HttpServletResponse.SC_NOT_FOUND);
          return;
      }
  
      // Select the Wrapper to be used for this Request
      Wrapper wrapper = request.getWrapper();
      if (wrapper == null || wrapper.isUnavailable()) {
          response.sendError(HttpServletResponse.SC_NOT_FOUND);
          return;
      }
  
  		//调用wrapper.pipeline
      wrapper.getPipeline().getFirst().invoke(request, response);
  }
  ```

#### 自定义Valve

```xml
<Engine name="Catalina" defaultHost="localhost">

  <!--For clustering, please take a look at documentation at:
      /docs/cluster-howto.html  (simple how to)
      /docs/config/cluster.html (reference documentation) -->
  <!--
  <Cluster className="org.apache.catalina.ha.tcp.SimpleTcpCluster"/>
  -->

  <!-- Use the LockOutRealm to prevent attempts to guess user passwords
       via a brute-force attack -->
  <Realm className="org.apache.catalina.realm.LockOutRealm">
    <!-- This Realm uses the UserDatabase configured in the global JNDI
         resources under the key "UserDatabase".  Any edits
         that are performed against this UserDatabase are immediately
         available for use by the Realm.  -->
    <Realm className="org.apache.catalina.realm.UserDatabaseRealm"
           resourceName="UserDatabase"/>
  </Realm>

  <Host name="localhost"  appBase="webapps"
        unpackWARs="true" autoDeploy="true">

    <!-- SingleSignOn valve, share authentication between web applications
         Documentation at: /docs/config/valve.html -->
    <!--
    <Valve className="org.apache.catalina.authenticator.SingleSignOn" />
    -->

    <!-- Access log processes all example.
         Documentation at: /docs/config/valve.html
         Note: The pattern used is equivalent to using pattern="common" -->
    <Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs"
           prefix="localhost_access_log" suffix=".txt"
           pattern="%h %l %u %t &quot;%r&quot; %s %b" />

  </Host>
</Engine>
```

这是tomcat提供的默认`server.xml`，每一层级的自定义`valve`节点都是通过这样的配置加进去的。

来看一下官方提供的日志记录`AccessLogValve`

```java
    public void invoke(Request request, Response response) throws IOException,
            ServletException {
				
        //对自身保有的所有日志节点，进行日志记录
        if (cachedElements != null) {
            for (CachedElement element : cachedElements) {
                element.cache(request);
            }
        }
        //调用下一节点
        getNext().invoke(request, response);
    }
```

这就是tomcat中各层级调用时职责链模式的使用。

## Servlet Filter 源码解析

> `ApplicationFilterChain` 是 Tomcat 中用于管理和执行 Servlet 过滤器（Filter）链的一个关键组件。其工作原理主要基于 Servlet 规范中的过滤器链概念，用于在 Servlet 处理请求之前和之后执行一系列过滤器操作。

- **过滤器链管理**：`ApplicationFilterChain` 维护一个包含多个过滤器的列表。这个列表中的过滤器是按照它们在 web 应用程序中声明的顺序排列的。

- **定义和初始化**：`ApplicationFilterChain` 类定义了几个关键的成员变量，包括用于存储过滤器的数组和一个指向当前应调用过滤器的索引。

  ```java
  private ApplicationFilterConfig[] filters = new ApplicationFilterConfig[0];
  private int pos = 0; // maintains the position in the filter chain
  private int n; // the number of filters
  // 其他成员变量 ...
  ```

- **doFilter 方法**：`doFilter` 方法是 `ApplicationFilterChain` 的核心。它按顺序调用每个过滤器，并最终调用 Servlet 或其他资源。

  ```java
  public void doFilter(ServletRequest request, ServletResponse response)
      throws IOException, ServletException {
      
      if (pos < n) {
          ApplicationFilterConfig filterConfig = filters[pos++];
          Filter filter = filterConfig.getFilter();
          filter.doFilter(request, response, this);
      } else {
          // 执行 Servlet 的 service 方法
          servlet.service(request, response);
      }
  }
  ```

  在这个方法中，`pos` 变量跟踪当前应该执行哪个过滤器。如果 `pos` 小于过滤器总数 `n`，则调用下一个过滤器的 `doFilter` 方法，并将 `pos` 加一。如果所有过滤器都已经调用过，则执行 Servlet 的 `service` 方法。

- **过滤器的添加**：在应用启动或运行时，根据 web 应用的配置（如 web.xml 中的配置），Tomcat 会创建并添加相应的过滤器到 `ApplicationFilterChain`。

  ```java
  public void addFilter(ApplicationFilterConfig filterConfig) {
      if (n == filters.length) {
          // 扩展 filters 数组的大小
      }
      filters[n++] = filterConfig;
  }
  ```

  这段代码负责将新的过滤器配置添加到过滤器数组中。如果数组满了，它会先扩展数组的大小。

- **递归调用机制**：当一个过滤器在其 `doFilter` 方法中调用 `chain.doFilter(request, response)` 时，实际上是在调用 `ApplicationFilterChain` 的 `doFilter` 方法，从而实现递归调用的机制。这样，控制权会依次传递给链中的每个过滤器，最终到达 Servlet。

## mybatis Interceptor 源码解析

MyBatis 的 Interceptor（拦截器）机制是基于职责链模式实现的，它允许开发者在 MyBatis 执行 SQL 操作的关键节点上插入自定义的拦截逻辑。在 MyBatis 中，这通常涉及对 Executor、StatementHandler、ParameterHandler 和 ResultSetHandler 这四种类型的接口实现的拦截。

下面是 MyBatis 拦截器的工作原理，结合源码进行解释：

1. **拦截器接口（Interceptor）**：MyBatis 中所有拦截器都必须实现 `Interceptor` 接口，该接口包含三个方法：`intercept`、`plugin` 和 `setProperties`。

   ```java
   public interface Interceptor {
       Object intercept(Invocation invocation) throws Throwable;
       Object plugin(Object target);
       void setProperties(Properties properties);
   }
   ```

   - `intercept` 方法是拦截器的核心，用于定义拦截逻辑。
   - `plugin` 方法用于创建当前拦截器的代理对象，如果当前目标对象是被拦截的对象，则使用动态代理包装它，否则直接返回目标本身。
   - `setProperties` 方法用于设置拦截器的属性。

2. **拦截器链（InterceptorChain）**：MyBatis 维护了一个 `InterceptorChain`，其中包含了所有注册的拦截器。

   ```java
   public class InterceptorChain {
       private final List<Interceptor> interceptors = new ArrayList<>();

       public Object pluginAll(Object target) {
           for (Interceptor interceptor : interceptors) {
               target = interceptor.plugin(target);
           }
           return target;
       }
       // 其他方法...
   }
   ```

   `pluginAll` 方法会遍历所有拦截器，并对给定的目标对象应用插件逻辑。

3. **动态代理**：在 `plugin` 方法中，MyBatis 使用 JDK 动态代理或 CGLIB 来创建目标对象的代理。通过这个代理对象，可以在执行目标方法前后插入自定义逻辑。

   ```java
   public Object plugin(Object target) {
       return Plugin.wrap(target, this);
   }
   ```

   在 `Plugin` 类中，`wrap` 方法会检查目标类型是否需要被当前拦截器所拦截。如果是，它会创建一个代理对象，该代理对象在调用方法时会触发拦截器的 `intercept` 方法。

4. **拦截逻辑的执行**：当代理对象的方法被调用时，首先会执行拦截器链中的 `intercept` 方法，然后才是目标对象的原始方法。

   ```java
   public Object intercept(Invocation invocation) throws Throwable {
       // 自定义的拦截逻辑
       return invocation.proceed();
   }
   ```

在 MyBatis 中，拦截器的使用非常灵活，可以拦截的操作包括数据库操作的执行、参数的设置、结果集的处理等。这使得开发者可以在不改变 MyBatis 核心代码的情况下，扩展或修改 MyBatis 的标准行为。例如，可以实现拦截器来实现查询缓存、性能日志记录或其他跨切面的关注点。

## Netty 责任链源码解析

