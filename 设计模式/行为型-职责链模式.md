# 行为型-职责链模式

## 概述

## Tomcat pipeline 源码解析

> 请求到达`connector`之后，经过`CoyoteAdapter`处理请求之后，会一次经过`engine`、`host`、`context`、`wrapper`最后到达`servlet`的调用链「`ApplicationFilterChain`」。
>
> 在`engine`、`host`、`context`、`wrapper`这4层组件之间，tomcat使用`pipeline`进行职责链式调用。

先来看一下这一部分结构。

![image-20240108172646021](https://wangigor-typora-images.oss-cn-chengdu.aliyuncs.com/image-20240108172646021.png)

- `engine`、`host`、`context`、`wrapper`各个组件tomcat都提供了标准实现类`StandardEngine`、`StandardHost`、`StandardContext`、`StandardWrapper`。
- 4个组件都继承了`ContainerBase`类。
- `ContainerBase`类实例化的时候初始化了一个`StandardPipeline`的`pipeline`组件，这就是tomcat中职责链的核心组件

### pipeline和valve

`pipeline`和`valve`是链表结构，`valve`作为链表节点。

`valve`接口结构如下。

```java
public interface Valve {
		
  	//获取下一个节点
    public Valve getNext();

		//设置下一个节点
    public void setNext(Valve valve);

    //执行
    public void invoke(Request request, Response response)
        throws IOException, ServletException;
}
```

`pipeline`接口结构如下

```java
public interface Pipeline extends Contained {

		//获取链尾节点
    public Valve getBasic();

		//设置链尾节点
    public void setBasic(Valve valve);

    //添加链上节点
    public void addValve(Valve valve);

		//获取链表节点
    public Valve[] getValves();

    //删除节点
    public void removeValve(Valve valve);

		//获取第一个链表节点
    public Valve getFirst();
}
```

- `pipeline`的链表是一个单向链表。
- `first`作为头节点，`basic`作为尾节点调用下一层组件`pipeline`。
- 每一个`valve`责任独立。

![截屏 2024-01-09 09.30.11](https://wangigor-typora-images.oss-cn-chengdu.aliyuncs.com/截屏 2024-01-09 09.30.11.jpeg)

- `addValve`源码

  自定义节点添加会走到这里

  ```java
      public void addValve(Valve valve) {
  
          // 从first开始遍历，添加到basic之前。
          if (first == null) {
              first = valve;
              valve.setNext(basic);
          } else {
              Valve current = first;
              while (current != null) {
                  if (current.getNext() == basic) {
                      current.setNext(valve);
                      valve.setNext(basic);
                      break;
                  }
                  current = current.getNext();
              }
          }
  				//触发添加valve事件
          container.fireContainerEvent(Container.ADD_VALVE_EVENT, valve);
      }
  ```

- `setBasic`源码

  ```java
  	public void setBasic(Valve valve) {
  
          // Change components if necessary
          Valve oldBasic = this.basic;
          if (oldBasic == valve) {
              return;
          }
  
          // 如果有已经存在的basic节点，替换。
          Valve current = first;
          while (current != null) {
              if (current.getNext() == oldBasic) {
                  current.setNext(valve);
                  break;
              }
              current = current.getNext();
          }
  				//当前节点设置为basic节点
          this.basic = valve;
  	}
  ```

### 各组件标准basic节点和自定义节点

#### 标准basic节点

每一个层级「`engine`、`host`、`context`、`wrapper`」都设置了自己默认的basic节点，命名是`Stand*Valve`格式。

在各节点实例化的时候，实例化`Stand*Valve`并设置为本节点`pipeline`的`basic`节点。

- `StandardEngine`

  ```java
      public StandardEngine() {
          super();
        	//设置basic为StandardEngineValve
          pipeline.setBasic(new StandardEngineValve());
      }
  ```

  `StandardEngineValve`负责调用`host.pipeline.first`

  ```java
  //StandardEngineValve
  public final void invoke(Request request, Response response)
      throws IOException, ServletException {
  
      // Ask this Host to process this request
      host.getPipeline().getFirst().invoke(request, response);
  }
  ```

- `StandardHost`

  ```java
  public StandardHost() {
  
      super();
      //设置basic为StandardHostValve
      pipeline.setBasic(new StandardHostValve());
  
  }
  ```

  `StandardHostValve`负责调用`context.pipeline.first`

  ```java
  public final void invoke(Request request, Response response)
      throws IOException, ServletException {
  
      //忽略其他异常处理相关代码
    
    	//调用下一层级context
  		context.getPipeline().getFirst().invoke(request, response);
  }
  ```

- `StandardContext`

  ```java
  public StandardContext() {
  
      super();
      //设置basic为StandardContextValve
      pipeline.setBasic(new StandardContextValve());
  
  }
  ```

  `StandardContextValve`负责调用`wrapper.pipeline.first`

  ```java
  public final void invoke(Request request, Response response)
      throws IOException, ServletException {
  
      // Disallow any direct access to resources under WEB-INF or META-INF
      MessageBytes requestPathMB = request.getRequestPathMB();
      if ((requestPathMB.startsWithIgnoreCase("/META-INF/", 0))
              || (requestPathMB.equalsIgnoreCase("/META-INF"))
              || (requestPathMB.startsWithIgnoreCase("/WEB-INF/", 0))
              || (requestPathMB.equalsIgnoreCase("/WEB-INF"))) {
          response.sendError(HttpServletResponse.SC_NOT_FOUND);
          return;
      }
  
      // Select the Wrapper to be used for this Request
      Wrapper wrapper = request.getWrapper();
      if (wrapper == null || wrapper.isUnavailable()) {
          response.sendError(HttpServletResponse.SC_NOT_FOUND);
          return;
      }
  
  		//调用wrapper.pipeline
      wrapper.getPipeline().getFirst().invoke(request, response);
  }
  ```

#### 自定义Valve

```xml
<Engine name="Catalina" defaultHost="localhost">

  <!--For clustering, please take a look at documentation at:
      /docs/cluster-howto.html  (simple how to)
      /docs/config/cluster.html (reference documentation) -->
  <!--
  <Cluster className="org.apache.catalina.ha.tcp.SimpleTcpCluster"/>
  -->

  <!-- Use the LockOutRealm to prevent attempts to guess user passwords
       via a brute-force attack -->
  <Realm className="org.apache.catalina.realm.LockOutRealm">
    <!-- This Realm uses the UserDatabase configured in the global JNDI
         resources under the key "UserDatabase".  Any edits
         that are performed against this UserDatabase are immediately
         available for use by the Realm.  -->
    <Realm className="org.apache.catalina.realm.UserDatabaseRealm"
           resourceName="UserDatabase"/>
  </Realm>

  <Host name="localhost"  appBase="webapps"
        unpackWARs="true" autoDeploy="true">

    <!-- SingleSignOn valve, share authentication between web applications
         Documentation at: /docs/config/valve.html -->
    <!--
    <Valve className="org.apache.catalina.authenticator.SingleSignOn" />
    -->

    <!-- Access log processes all example.
         Documentation at: /docs/config/valve.html
         Note: The pattern used is equivalent to using pattern="common" -->
    <Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs"
           prefix="localhost_access_log" suffix=".txt"
           pattern="%h %l %u %t &quot;%r&quot; %s %b" />

  </Host>
</Engine>
```

这是tomcat提供的默认`server.xml`，每一层级的自定义`valve`节点都是通过这样的配置加进去的。

来看一下官方提供的日志记录`AccessLogValve`

```java
    public void invoke(Request request, Response response) throws IOException,
            ServletException {
				
        //对自身保有的所有日志节点，进行日志记录
        if (cachedElements != null) {
            for (CachedElement element : cachedElements) {
                element.cache(request);
            }
        }
        //调用下一节点
        getNext().invoke(request, response);
    }
```

这就是tomcat中各层级调用时职责链模式的使用。

## Servlet Filter 源码解析

> `ApplicationFilterChain` 是 Tomcat 中用于管理和执行 Servlet 过滤器（Filter）链的一个关键组件。其工作原理主要基于 Servlet 规范中的过滤器链概念，用于在 Servlet 处理请求之前和之后执行一系列过滤器操作。

- **过滤器链管理**：`ApplicationFilterChain` 维护一个包含多个过滤器的列表。这个列表中的过滤器是按照它们在 web 应用程序中声明的顺序排列的。

- **定义和初始化**：`ApplicationFilterChain` 类定义了几个关键的成员变量，包括用于存储过滤器的数组和一个指向当前应调用过滤器的索引。

  ```java
  private ApplicationFilterConfig[] filters = new ApplicationFilterConfig[0];
  private int pos = 0; // maintains the position in the filter chain
  private int n; // the number of filters
  // 其他成员变量 ...
  ```

- **doFilter 方法**：`doFilter` 方法是 `ApplicationFilterChain` 的核心。它按顺序调用每个过滤器，并最终调用 Servlet 或其他资源。

  ```java
  public void doFilter(ServletRequest request, ServletResponse response)
      throws IOException, ServletException {
      
      if (pos < n) {
          ApplicationFilterConfig filterConfig = filters[pos++];
          Filter filter = filterConfig.getFilter();
          filter.doFilter(request, response, this);
      } else {
          // 执行 Servlet 的 service 方法
          servlet.service(request, response);
      }
  }
  ```

  在这个方法中，`pos` 变量跟踪当前应该执行哪个过滤器。如果 `pos` 小于过滤器总数 `n`，则调用下一个过滤器的 `doFilter` 方法，并将 `pos` 加一。如果所有过滤器都已经调用过，则执行 Servlet 的 `service` 方法。

- **过滤器的添加**：在应用启动或运行时，根据 web 应用的配置（如 web.xml 中的配置），Tomcat 会创建并添加相应的过滤器到 `ApplicationFilterChain`。

  ```java
  public void addFilter(ApplicationFilterConfig filterConfig) {
      if (n == filters.length) {
          // 扩展 filters 数组的大小
      }
      filters[n++] = filterConfig;
  }
  ```

  这段代码负责将新的过滤器配置添加到过滤器数组中。如果数组满了，它会先扩展数组的大小。

- **递归调用机制**：当一个过滤器在其 `doFilter` 方法中调用 `chain.doFilter(request, response)` 时，实际上是在调用 `ApplicationFilterChain` 的 `doFilter` 方法，从而实现递归调用的机制。这样，控制权会依次传递给链中的每个过滤器，最终到达 Servlet。

## mybatis Interceptor 源码解析



## Netty 责任链源码解析

