# 行为型-职责链模式

## 概述

## Tomcat pipeline 源码解析

> 请求到达`connector`之后，经过`CoyoteAdapter`处理请求之后，会一次经过`engine`、`host`、`context`、`wrapper`最后到达`servlet`的调用链「`ApplicationFilterChain`」。
>
> 在`engine`、`host`、`context`、`wrapper`这4层组件之间，tomcat使用`pipeline`进行职责链式调用。

先来看一下这一部分结构。

![image-20240108172646021](https://wangigor-typora-images.oss-cn-chengdu.aliyuncs.com/image-20240108172646021.png)

- `engine`、`host`、`context`、`wrapper`各个组件tomcat都提供了标准实现类`StandardEngine`、`StandardHost`、`StandardContext`、`StandardWrapper`。
- 4个组件都继承了`ContainerBase`类。
- `ContainerBase`类实例化的时候初始化了一个`StandardPipeline`的`pipeline`组件，这就是tomcat中职责链的核心组件

### pipeline和valve

`pipeline`和`valve`是链表结构，`valve`作为链表节点。

`valve`接口结构如下。

```java
public interface Valve {
		
  	//获取下一个节点
    public Valve getNext();

		//设置下一个节点
    public void setNext(Valve valve);

    //执行
    public void invoke(Request request, Response response)
        throws IOException, ServletException;
}
```

`pipeline`接口结构如下

```java
public interface Pipeline extends Contained {

		//获取链尾节点
    public Valve getBasic();

		//设置链尾节点
    public void setBasic(Valve valve);

    //添加链上节点
    public void addValve(Valve valve);

		//获取链表节点
    public Valve[] getValves();

    //删除节点
    public void removeValve(Valve valve);

		//获取第一个链表节点
    public Valve getFirst();
}
```

- `pipeline`的链表是一个单向链表。
- `first`作为头节点，`basic`作为尾节点调用下一层组件`pipeline`。
- 每一个`valve`责任独立。

![截屏 2024-01-09 09.30.11](https://wangigor-typora-images.oss-cn-chengdu.aliyuncs.com/截屏 2024-01-09 09.30.11.jpeg)

- `addValve`源码

  自定义节点添加会走到这里

  ```java
      public void addValve(Valve valve) {
  
          // 从first开始遍历，添加到basic之前。
          if (first == null) {
              first = valve;
              valve.setNext(basic);
          } else {
              Valve current = first;
              while (current != null) {
                  if (current.getNext() == basic) {
                      current.setNext(valve);
                      valve.setNext(basic);
                      break;
                  }
                  current = current.getNext();
              }
          }
  				//触发添加valve事件
          container.fireContainerEvent(Container.ADD_VALVE_EVENT, valve);
      }
  ```

- `setBasic`源码

  ```java
  	public void setBasic(Valve valve) {
  
          // Change components if necessary
          Valve oldBasic = this.basic;
          if (oldBasic == valve) {
              return;
          }
  
          // 如果有已经存在的basic节点，替换。
          Valve current = first;
          while (current != null) {
              if (current.getNext() == oldBasic) {
                  current.setNext(valve);
                  break;
              }
              current = current.getNext();
          }
  				//当前节点设置为basic节点
          this.basic = valve;
  	}
  ```

### 各组件标准basic节点和自定义节点

#### 标准basic节点

每一个层级「`engine`、`host`、`context`、`wrapper`」都设置了自己默认的basic节点，命名是`Stand*Valve`格式。

在各节点实例化的时候，实例化`Stand*Valve`并设置为本节点`pipeline`的`basic`节点。

- `StandardEngine`

  ```java
      public StandardEngine() {
          super();
        	//设置basic为StandardEngineValve
          pipeline.setBasic(new StandardEngineValve());
      }
  ```

  `StandardEngineValve`负责调用`host.pipeline.first`

  ```java
  //StandardEngineValve
  public final void invoke(Request request, Response response)
      throws IOException, ServletException {
  
      // Ask this Host to process this request
      host.getPipeline().getFirst().invoke(request, response);
  }
  ```

- `StandardHost`

  ```java
  public StandardHost() {
  
      super();
      //设置basic为StandardHostValve
      pipeline.setBasic(new StandardHostValve());
  
  }
  ```

  `StandardHostValve`负责调用`context.pipeline.first`

  ```java
  public final void invoke(Request request, Response response)
      throws IOException, ServletException {
  
      //忽略其他异常处理相关代码
    
    	//调用下一层级context
  		context.getPipeline().getFirst().invoke(request, response);
  }
  ```

- `StandardContext`

  ```java
  public StandardContext() {
  
      super();
      //设置basic为StandardContextValve
      pipeline.setBasic(new StandardContextValve());
  
  }
  ```

  `StandardContextValve`负责调用`wrapper.pipeline.first`

  ```java
  public final void invoke(Request request, Response response)
      throws IOException, ServletException {
  
      // Disallow any direct access to resources under WEB-INF or META-INF
      MessageBytes requestPathMB = request.getRequestPathMB();
      if ((requestPathMB.startsWithIgnoreCase("/META-INF/", 0))
              || (requestPathMB.equalsIgnoreCase("/META-INF"))
              || (requestPathMB.startsWithIgnoreCase("/WEB-INF/", 0))
              || (requestPathMB.equalsIgnoreCase("/WEB-INF"))) {
          response.sendError(HttpServletResponse.SC_NOT_FOUND);
          return;
      }
  
      // Select the Wrapper to be used for this Request
      Wrapper wrapper = request.getWrapper();
      if (wrapper == null || wrapper.isUnavailable()) {
          response.sendError(HttpServletResponse.SC_NOT_FOUND);
          return;
      }
  
  		//调用wrapper.pipeline
      wrapper.getPipeline().getFirst().invoke(request, response);
  }
  ```

#### 自定义Valve

```xml
<Engine name="Catalina" defaultHost="localhost">

  <!--For clustering, please take a look at documentation at:
      /docs/cluster-howto.html  (simple how to)
      /docs/config/cluster.html (reference documentation) -->
  <!--
  <Cluster className="org.apache.catalina.ha.tcp.SimpleTcpCluster"/>
  -->

  <!-- Use the LockOutRealm to prevent attempts to guess user passwords
       via a brute-force attack -->
  <Realm className="org.apache.catalina.realm.LockOutRealm">
    <!-- This Realm uses the UserDatabase configured in the global JNDI
         resources under the key "UserDatabase".  Any edits
         that are performed against this UserDatabase are immediately
         available for use by the Realm.  -->
    <Realm className="org.apache.catalina.realm.UserDatabaseRealm"
           resourceName="UserDatabase"/>
  </Realm>

  <Host name="localhost"  appBase="webapps"
        unpackWARs="true" autoDeploy="true">

    <!-- SingleSignOn valve, share authentication between web applications
         Documentation at: /docs/config/valve.html -->
    <!--
    <Valve className="org.apache.catalina.authenticator.SingleSignOn" />
    -->

    <!-- Access log processes all example.
         Documentation at: /docs/config/valve.html
         Note: The pattern used is equivalent to using pattern="common" -->
    <Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs"
           prefix="localhost_access_log" suffix=".txt"
           pattern="%h %l %u %t &quot;%r&quot; %s %b" />

  </Host>
</Engine>
```

这是tomcat提供的默认`server.xml`，每一层级的自定义`valve`节点都是通过这样的配置加进去的。

来看一下官方提供的日志记录`AccessLogValve`

```java
    public void invoke(Request request, Response response) throws IOException,
            ServletException {
				
        //对自身保有的所有日志节点，进行日志记录
        if (cachedElements != null) {
            for (CachedElement element : cachedElements) {
                element.cache(request);
            }
        }
        //调用下一节点
        getNext().invoke(request, response);
    }
```

这就是tomcat中各层级调用时职责链模式的使用。



## Servlet Filter 源码解析

## Spring Interceptor 源码解析

## Netty 责任链源码解析

