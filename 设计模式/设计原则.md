# 设计原则

> 包括**SOLID**、**KISS**、**YAGNI**、**DRY**、**LOD**原则等。

这些设计原则，从字面上理解不难。感觉一看就懂。但能够真的用到项目中，「看懂」和「会用」是两回事。而「用好」更是难上加难。

**要理解透。不要过于教条、不要生搬硬套。**

## SOLID原则

> SOLID原则并非1个原则，而是由5个设计原则组成：
>
> - 「S」单一职责原则。
> - 「O」开闭原则。
> - 「L」里氏替换原则。
> - 「I」接口隔离原则。
> - 「D」依赖反转原则。

### 单一职责原则

> 单一职责原则英文是Single Responsibility Principle（SRP）：A class or module should have a single responsibility「一个类或者模块只负责完成一个职责（功能）」。

这个原则描述的对象包含两个：类「class」和 模块「module」。

这两个概念，跟我们平时用到的还不一样，这俩概念是抽象概念。

- 把模块看做比类更加抽象的概念，类也可以看做模块。
- 把模块看做比类更加粗粒度的代码块，模块中包含多个类，多个类组成一个模块。

不论怎么理解，单一职责原则在用到这样的概念「比如微服务拆分」的时候，道理是相通的。

下面只从「类」设计的角度，讲解这个设计原则。

> 单一职责原则：一个类只负责完成一个职责或功能。
>
> 不要设计大而全的类，要设计粒度小、功能单一的类；
>
> 如果一个类包含了两个或者两个以上业务不相干的功能，那么它职责不够单一，应该进行拆分。

#### 如何判断职责是否足够单一

> 如果，一个类里既包含订单操作，又包含用户的操作。而订单和用户是两个独立的『业务领域模型』。这就违反了单一职责原则。我们需要将这个类拆分成两个粒度更细、功能更单一的类：订单类和用户类。

但大部分情况下，类里是不是包含了两个不相关的工鞥呢，并不是那么容易判断的。在真实软件开发中，对于一个类是否职责单一，很难拿捏。来看下面的例子。

```java
public class UserInfo {
  private long userId;
  private String username;
  private String email;
  private String telephone;
  private long createTime;
  private long lastLoginTime;
  private String avatarUrl;
  private String provinceOfAddress; // 省
  private String cityOfAddress; // 市
  private String regionOfAddress; // 区 
  private String detailedAddress; // 详细地址
  // ...省略其他属性和方法...
}
```

用UserInfo类来记录用户信息，这个UserInfo的设计是否满足单一职责原则呢？不一定。一种观点认为UserInfo类包含的都是用户相关的信息，所有的属性和方法都隶属于用户这样的业务模型，满足单一职责原则；另一种观点认为，地址信息在UserInfo类中占的比重比较高，可以继续拆分出独立的UserAddress类。这样才能职责更加单一。

其实这两种说法都不对，因为脱离了具体的应用场景。

- 如果是类似社交产品中，用户地址信息跟其他信息一样只是单纯用来展示「像身份证上面的地址信息一样」，那现在的UserInfo设计是合理的。
- 如果是类似电商平台中，用户的地址信息更偏向于物流目的地。那我们最好将地址信息从UserInfo中拆分出来，独立成用户物流信息『收货地址』。

再延伸一下，如果用户不止有一个账号登录，这里的账号意思是有多种身份认证方式，也就有多种身份认证相关信息比如「username、email、telephone」。也就得抽出独立的身份认证信息类。

可以看出，**在不同应用场景、不同阶段需求背景下，对同一个类的职责是否单一的认定，可能都不一样。**在目前场景和需求下，一个类的设计可能已经满足单一职责原则了，但在未来可能就不满足，需要继续拆分成粒度更细的类。**从不容的业务层面去评价一个类的设计是否职责单一，也会有不同的认识**。比如UserInfo从用户业务层面来看，包含的所有信息都属于用户，满足职责单一；如果从更细的业务层面「用户展示信息」「地址信息」「认证登录信息」等业务层面来看，UserInfo也确实应该拆分。

> 评价一个类的职责是否单一，并没有一个非常明确、可以量化的标准。可以说这是件非常主观、仁者见仁智者见智的事情。实际上真正的软件开发中，我们也没必要过于未雨绸缪，过度设计。

就先写一个粗粒度的类，满足当前的也无需求。随着业务的发展，如果粗粒度的类越来越庞大，代码越来越多，就拆分成几个更细粒度的类。这就是**持续重构**。

原则本身比较含糊不清、模棱两可。下面这几条判断原则，可以比较主观地思考类是否职责单一，更有指导意义、更具有可执行性。

- 类中的代码行数、函数或者属性过多。会影响代码的可读性和可维护性，需要考虑对类进行拆分。
- 类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想，需要对类进行拆分。
- 私有方法过多，需要考虑能否将私有方法独立到新的类中，设置为public方法，供更多地类使用，从而提高代码的复用性。
- 比较难给类起一个合适的名字，很难用一个业务名词概括，或者只能用一些笼统的Manager、Context之类的词语来命名，这就说明类的职责定义可能不够清晰。
- 类中大量的方法都是集中操作类中的某几个属性，比如UserInfo中，如果一半的方法都是在操作address信息，那就要考虑把这几个属性和对应的方法拆分出来。

依然有很多具有模糊描述性的标准比如「过多、很难……」，这些标准很难定量。

实际上，从另一个角度来看，当一个类的代码读起来让你头大，实现某个功能不知道该用那个函数，想用哪个函数翻半天都找不到，只用到一个小功能需要引入整个类「而这个类有很多不相关的其他函数」的时候，这就说明就是是现在了。做的项目多了，代码写多了，在开发中慢慢品味就能培养出这种『专业第六感』。

#### 类的职责是否设计的越单一越好

不是。

比如`Serialization`类实现了一个简单协议的序列化和反序列化功能。

```java
/**
 * Protocol format: identifier-string;{gson string}
 * For example: UEUEUE;{"a":"A","b":"B"}
 */
public class Serialization {
  private static final String IDENTIFIER_STRING = "UEUEUE;";
  private Gson gson;
  
  public Serialization() {
    this.gson = new Gson();
  }
  
  public String serialize(Map<String, String> object) {
    StringBuilder textBuilder = new StringBuilder();
    textBuilder.append(IDENTIFIER_STRING);
    textBuilder.append(gson.toJson(object));
    return textBuilder.toString();
  }
  
  public Map<String, String> deserialize(String text) {
    if (!text.startsWith(IDENTIFIER_STRING)) {
        return Collections.emptyMap();
    }
    String gsonStr = text.substring(IDENTIFIER_STRING.length());
    return gson.fromJson(gsonStr, Map.class);
  }
}
```

如果我们想让类的职责更加单一，我们可以对`Serialization`进行拆分，拆分成一个只负责序列化工作的`Serializer`类和另一个只负责反序列化工作的`Deserializer`类。

```java
public class Serializer {
  private static final String IDENTIFIER_STRING = "UEUEUE;";
  private Gson gson;
  
  public Serializer() {
    this.gson = new Gson();
  }
  
  public String serialize(Map<String, String> object) {
    StringBuilder textBuilder = new StringBuilder();
    textBuilder.append(IDENTIFIER_STRING);
    textBuilder.append(gson.toJson(object));
    return textBuilder.toString();
  }
}

public class Deserializer {
  private static final String IDENTIFIER_STRING = "UEUEUE;";
  private Gson gson;
  
  public Deserializer() {
    this.gson = new Gson();
  }
  
  public Map<String, String> deserialize(String text) {
    if (!text.startsWith(IDENTIFIER_STRING)) {
        return Collections.emptyMap();
    }
    String gsonStr = text.substring(IDENTIFIER_STRING.length());
    return gson.fromJson(gsonStr, Map.class);
  }
}
```

尽管经过拆分之后，`Serializer`类和`Deserializer`类的职责更加单一了，但却带来了新的问题。

比如协议格式需要修改，数据标识要从`UEUEUE`改为`DFDFDF`;或者序列化方式从JSON要改为XML，那么两个类需要做到同时修改，代码的内聚性显然没有原有的`Serialization`高，且导致代码的可维护性变差了。

> 实际上，**不管是应用设计原则还是设计模式，最终目的还是提高的可读性、可扩展性、复用性、可维护性等。**我们在考虑应用某一个设计原则是否合理的时候，也可以以此为最终的考量标准。



### 开闭原则

> 开闭原则是SOLID中最难理解、最难掌握，同时也最有用的一条原则。
>
> 开闭原则的英文是Open Closed Principle（OCP）: software entities(modules,classes,functions,etc.) should be open for extension,but closed for modification.「软件实体（模块、类、方法等）应该对扩展开放、对修改关闭。」。
>
> 也就是添加一个新的功能的时候，应该在已有代码基础上扩展代码「新增模块、类、方法」，而不是修改已有代码「修改模块、类、方法」。

举个例子，下面是一段API接口监控告警代码。

```java
public class Alert {
  private AlertRule rule;
  private Notification notification;

  public Alert(AlertRule rule, Notification notification) {
    this.rule = rule;
    this.notification = notification;
  }

  public void check(String api, long requestCount, long errorCount, long durationOfSeconds) {
    long tps = requestCount / durationOfSeconds;
    if (tps > rule.getMatchedRule(api).getMaxTps()) {
      notification.notify(NotificationEmergencyLevel.URGENCY, "...");
    }
    if (errorCount > rule.getMatchedRule(api).getMaxErrorCount()) {
      notification.notify(NotificationEmergencyLevel.SEVERE, "...");
    }
  }
}
```

- `AlertRule`存储告警规则，比如「tps超过多少进行告警」「失败次数超过多少进行告警」
- `Notification`是告警的通知类，支持邮件、短信、微信等多种通知渠道。
- `NotificationEmergencyLevel`是通知的紧急程度，比如SEVERE「严重」、URGENCY「紧急」、NORMAL「普通」、TRIVIAL「无关紧要」不同的紧急程度可能不同的发送渠道。
- 业务逻辑集中在`check()`中，上游统计一段时间内错误请求次数和调用次数，然后判断进行告警。

如果我们需要一个新功能「当每秒钟接口超时请求个数，超过某个阈值触发告警通知」。按照这样的需求沿用原有代码的情况下：

- 修改`check()`入参，添加新的统计数据timeoutCount
- 在`check()`函数中添加新的告警逻辑
- 修改可用于超时次数的告警规则`AlertRole`

```java
public class Alert {
  // ...省略AlertRule/Notification属性和构造函数...
  
  // 改动一：添加参数timeoutCount
  public void check(String api, long requestCount, long errorCount, long timeoutCount, long durationOfSeconds) {
    long tps = requestCount / durationOfSeconds;
    if (tps > rule.getMatchedRule(api).getMaxTps()) {
      notification.notify(NotificationEmergencyLevel.URGENCY, "...");
    }
    if (errorCount > rule.getMatchedRule(api).getMaxErrorCount()) {
      notification.notify(NotificationEmergencyLevel.SEVERE, "...");
    }
    // 改动二：添加接口超时处理逻辑
    long timeoutTps = timeoutCount / durationOfSeconds;
    if (timeoutTps > rule.getMatchedRule(api).getMaxTimeoutTps()) {
      notification.notify(NotificationEmergencyLevel.URGENCY, "...");
    }
  }
}
```

还存在两处额外的修改。

- 上游调用接口修改。
- 单元测试修改。

上面的代码更改是基于「修改」的方式来实现新功能的。基于「扩展」的方式，该怎么实现呢？

首先要对`Alert`代码进行重构：

- 将系统状态的统计参数封装在一个`ApiStatInfo`类中。
- 把一个一个的if判断，改成一组`handler`集合「把产生的`ApiStatInfo`传入不同的`handler`中进行告警操作」。因为handler有公共部分「告警属性`Notification`、告警规则`AlertRule`」
- `Alert`初始化的时候，要装入所有的`handler`
- 入口修改，由`check(ApiStatInfo apiStatInfo)`进入，轮询调用`handler`。

```java
public class Alert {
  private List<AlertHandler> alertHandlers = new ArrayList<>();
  
  public void addAlertHandler(AlertHandler alertHandler) {
    this.alertHandlers.add(alertHandler);
  }

  public void check(ApiStatInfo apiStatInfo) {
    for (AlertHandler handler : alertHandlers) {
      handler.check(apiStatInfo);
    }
  }
}

public class ApiStatInfo {//省略constructor/getter/setter方法
  private String api;
  private long requestCount;
  private long errorCount;
  private long durationOfSeconds;
}

public abstract class AlertHandler {
  protected AlertRule rule;
  protected Notification notification;
  public AlertHandler(AlertRule rule, Notification notification) {
    this.rule = rule;
    this.notification = notification;
  }
  public abstract void check(ApiStatInfo apiStatInfo);
}

public class TpsAlertHandler extends AlertHandler {
  public TpsAlertHandler(AlertRule rule, Notification notification) {
    super(rule, notification);
  }

  @Override
  public void check(ApiStatInfo apiStatInfo) {
    long tps = apiStatInfo.getRequestCount()/ apiStatInfo.getDurationOfSeconds();
    if (tps > rule.getMatchedRule(apiStatInfo.getApi()).getMaxTps()) {
      notification.notify(NotificationEmergencyLevel.URGENCY, "...");
    }
  }
}

public class ErrorAlertHandler extends AlertHandler {
  public ErrorAlertHandler(AlertRule rule, Notification notification){
    super(rule, notification);
  }

  @Override
  public void check(ApiStatInfo apiStatInfo) {
    if (apiStatInfo.getErrorCount() > rule.getMatchedRule(apiStatInfo.getApi()).getMaxErrorCount()) {
      notification.notify(NotificationEmergencyLevel.SEVERE, "...");
    }
  }
}
```

比如这样的告警组件要添加到应用容器中。大概是这个样子。

```java
public class ApplicationContext {
  private AlertRule alertRule;
  private Notification notification;
  private Alert alert;
  
  public void initializeBeans() {
    alertRule = new AlertRule(/*.省略参数.*/); //省略一些初始化代码
    notification = new Notification(/*.省略参数.*/); //省略一些初始化代码
    alert = new Alert();
    alert.addAlertHandler(new TpsAlertHandler(alertRule, notification));
    alert.addAlertHandler(new ErrorAlertHandler(alertRule, notification));
  }
  public Alert getAlert() { return alert; }

  // 饿汉式单例
  private static final ApplicationContext instance = new ApplicationContext();
  private ApplicationContext() {
    initializeBeans();
  }
  public static ApplicationContext getInstance() {
    return instance;
  }
}

public class Demo {
  public static void main(String[] args) {
    ApiStatInfo apiStatInfo = new ApiStatInfo();
    // ...省略设置apiStatInfo数据值的代码
    ApplicationContext.getInstance().getAlert().check(apiStatInfo);
  }
}
```

现在基于重构后的代码，添加上面的功能。

- 在`ApiStatInfo`中添加新的属性`timeoutCount`。
- 添加新的`TimeoutAlertHanler`类。
- 在`ApplicationContext.initializeBeans`类中，向`alert对象`注册`TimeoutAlertHandler对象`
- 在`AlertRule`类中，添加`timeoutCount`的告警阈值
- 上有统计增加对`timeoutCount`的统计，放入`ApiStatInfo`中。

```java
public class Alert { // 代码未改动... }
public class ApiStatInfo {//省略constructor/getter/setter方法
  private String api;
  private long requestCount;
  private long errorCount;
  private long durationOfSeconds;
  private long timeoutCount; // 改动一：添加新字段
}
public abstract class AlertHandler { //代码未改动... }
public class TpsAlertHandler extends AlertHandler {//代码未改动...}
public class ErrorAlertHandler extends AlertHandler {//代码未改动...}
// 改动二：添加新的handler
public class TimeoutAlertHandler extends AlertHandler {//省略代码...}

public class ApplicationContext {
  private AlertRule alertRule;
  private Notification notification;
  private Alert alert;
  
  public void initializeBeans() {
    alertRule = new AlertRule(/*.省略参数.*/); //省略一些初始化代码
    notification = new Notification(/*.省略参数.*/); //省略一些初始化代码
    alert = new Alert();
    alert.addAlertHandler(new TpsAlertHandler(alertRule, notification));
    alert.addAlertHandler(new ErrorAlertHandler(alertRule, notification));
    // 改动三：注册handler
    alert.addAlertHandler(new TimeoutAlertHandler(alertRule, notification));
  }
  //...省略其他未改动代码...
}

public class Demo {
  public static void main(String[] args) {
    ApiStatInfo apiStatInfo = new ApiStatInfo();
    // ...省略apiStatInfo的set字段代码
    apiStatInfo.setTimeoutCount(289); // 改动四：设置tiemoutCount值
    ApplicationContext.getInstance().getAlert().check(apiStatInfo);
}
```

原有的单元测试不用修改。check方法调用方式不变。

这样的代码是不是就更加灵活和易扩展呢？如果想添加新的告警逻辑，只需要专注在创建新的handler类和数据如何统计上即可。

#### 修改代码就意味着违背开闭原则吗？

> `ApiStatInfo`类中添加新的属性`timeoutCount`不算修改吗？
>
> `ApplicationContext.initializeBeans()`为`alert`添加新的`handler`和`timeoutCount`的统计不算修改吗？

这两个问题，一个一个看。

##### ApiStatInfo类添加新的timeoutCount参数

这个问题就是「给类中添加新的属性和方法，算修改还是扩展？」

回顾开闭原则的定义：软件实体「模块、类、方法等」应该对扩展开放、对修改关闭。开闭原则可以应用在不同粒度的代码中，可以使模块、也可以是类、还可以是方法「属性」。同一段代码改动，在粗粒度下，被认定为『修改』；在细粒度下，又可以被认定是扩展。

比如这个修改，在类层面是修改。但没有修改已有属性和方法，在方法「属性」层面又可以被认定是扩展。

所以，没有必要纠结于某个代码改动是修改还是扩展，更没必要纠结是否违反开闭原则。这条原则设计的初衷是：**只要他没有破坏原有代码的正常运行，没有破坏原有的单元测试，我们就认为是一个合理的代码改动。**

##### ApplicationContext.initializeBeans()为alert添加新的handler和timeoutCount的统计

这两处修改是在方法内部进行的，从类或者方法角度，都是地地道道的修改。

但是这样的修改时在所难免可以被接收的。

**在重构了Alert之后，我们的核心逻辑集中在Alert及其handler中，当我们添加新的告警逻辑是，Alert类完全不需要修改，只是扩展handler。那在「Alert告警模块」中，模块本身是在添加新的功能，符合开闭原则。**

而且，添加一个新功能，不可能任何模块、类、方法的代码都不修改。类需要创建、组装、初始化，才能构建成可运行的程序，这部分代码的修改在所难免。我们要做的是**尽量让修改操作更集中、更少、更上层，尽量让最核心、最复杂的那部分逻辑代码满足开闭原则。**

#### 如何做到「对扩展开放、对修改关闭」

**靠理论知识和实战经验，慢慢学习和积累。**

**开闭原则实际就是代码的扩展性问题，是判断一段代码是否易扩展的「金线」**。如果某段代码在应对未来需求变化的时候，能够做到“对扩展开放、对修改关闭”，那就说明这段代码的扩展性比较好。所以，问如何才能做到“对扩展开放、对修改关闭”，也就粗略地等同于在问，如何才能写出扩展性好的代码。

为了尽量写出扩展性好的代码，我们要**时刻具备扩展意识、抽象意识、封装意识**。

写代码时，要多花一点时间往前思考，这段代码未来可能有哪些需求变更点，要不要事先留好扩展点，以便应对未来需求变更的时候，不需要改动代码整体结构的情况下、做最小代码修改的情况下，新的功能能够插入到扩展点上。这就是对「扩展开放对修改关闭」。

**在识别出代码可变部分和不可变部分之后，我们要将可变部分封装起来，隔离变化，提供抽象化的不可变接口，给上层使用**。这样当具体的变化发生时，我们只需要基于相同的抽象接口，扩展一个新的实现，替换掉老的实现即可，上游调用系统代码基本不变。

下面一些更加具体些的方法论。

> 实际上，整个设计模式大部分都是围绕扩展性问题展开的。很多设计原则、设计思想、设计模式，都是以提高代码扩展性为最终目的。特别是23中经典设计模式，大部分都是因为要解决代码的扩展性问题而总结出来的。

最常用的提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程，以及大部分的经典设计模式『比如装饰、策略、模板、职责链、状态等』。

实际上，多态、依赖注入、基于接口而非实现编程，以及前面提到的抽象意识，说的都是同一种设计思路，只是从不同的角度、不同的层面来阐述而已。这也体现了「很多设计原则、思想、模式都是相通的」这一思想。

> 举个例子，比如系统中通过kafka来发布异步消息。对于这样一个功能的开发，我们要学会将其抽象成一组跟具体消息队列无关的异步消息接口。因为消息队列的产品有很多，当我们未来要替换消息队列时就可以做到容易的扩展。比如kafka替换成RocketMQ，要能方便拔掉老的消息队列实现，插入新的消息队列实现。
>
> ```java
> 
> // 这一部分体现了抽象意识
> public interface MessageQueue { //... }
> public class KafkaMessageQueue implements MessageQueue { //... }
> public class RocketMQMessageQueue implements MessageQueue {//...}
> 
> public interface MessageFromatter { //... }
> public class JsonMessageFromatter implements MessageFromatter {//...}
> public class ProtoBufMessageFromatter implements MessageFromatter {//...}
> 
> public class Demo {
>   private MessageQueue msgQueue; // 基于接口而非实现编程
>   public Demo(MessageQueue msgQueue) { // 依赖注入
>     this.msgQueue = msgQueue;
>   }
>   
>   // msgFormatter：多态、依赖注入
>   public void sendNotification(Notification notification, MessageFormatter msgFormatter) {
>     //...    
>   }
> }
> ```

#### 如何在项目中灵活应用开闭原则

问题就在于「如何识别所有可能的扩展点」。

- 业务导向。比如金融系统、电商系统、物流系统，要识别出尽可能多的扩展点，就**要对业务有足够的了解，能够知道当下一级未来可能要支持的业务需求。**
- 跟业务无关、通用、偏底层的系统导向，比如框架、组件、类库，需要了解「他们会被如何使用、今后打算添加哪些功能、使用者未来会有哪些更多的功能需求」等问题。

「**唯一不变的只有变化本身**」，即使我们有足够的了解，也不可能识别出所有的扩展点。即使能够识别出所有扩展点，为了这些地方都预留扩展点，这样的成本是不可接受的。**我们没有必要为一些遥远、不一定发生的需求提前买单，做过度设计。**

合理的做法是，对于一些比较确定的、短期内可能会扩展，或者需求改动对代码结构影响比较大的情况，或者实现成本不高的扩展点，事先做好扩展型设计。对于一些未来不确定是否需要支持的需求，或者实现起来比较复杂的扩展点，等到有需求驱动的时候，通过重构代码的方式支持扩展的需求。

在某些情况下，**开闭原则也要付出一些代价，因为代码的扩展性可能会跟可读性相冲突。**

> 比如Alert告警的例子。重构后的代码，可读性降低。因为多个handler肯定比不上所有都写在一起，通过if语句进行逻辑控制的可读性强。

> 但随着告警规则越来越多「if语句越来越多」这一份代码也会变得很多、很复杂、代码行数很多，也会导致可读性变差。那重构之后的实现思路又是更加合理的选择了。

没有一个放之四海皆准的参考标准，全凭实际应用场景决定。

### 里氏替换原则

> 它听上去似乎跟「多态」类似。但是侧重点不同。
>
> 里氏替换原则的英文是Liskov Substitution Principle「LSP」: If S is a subType of T,then objects of type T may be replaced with objects of type S，without breading the program.Robert Martin 之后重新描述了这个原则：Functions that use pointers of references to base classes must be able to use objects of derived classes without knowing it.
>
> 「**子类对象（objects of subtype/derived class）能够替换程序中父类对象（objects of base /parent class）出现的任何地方，并且保证原来程序的逻辑性为不变及正确性不被破坏。**」

如下代码。

```java
public class Transporter {
  private HttpClient httpClient;
  
  public Transporter(HttpClient httpClient) {
    this.httpClient = httpClient;
  }

  public Response sendRequest(Request request) {
    // ...use httpClient to send request
  }
}

public class SecurityTransporter extends Transporter {
  private String appId;
  private String appToken;

  public SecurityTransporter(HttpClient httpClient, String appId, String appToken) {
    super(httpClient);
    this.appId = appId;
    this.appToken = appToken;
  }

  @Override
  public Response sendRequest(Request request) {
    if (StringUtils.isNotBlank(appId) && StringUtils.isNotBlank(appToken)) {
      request.addPayload("app-id", appId);
      request.addPayload("app-token", appToken);
    }
    return super.sendRequest(request);
  }
}

public class Demo {    
  public void demoFunction(Transporter transporter) {    
    Reuqest request = new Request();
    //...省略设置request中数据值的代码...
    Response response = transporter.sendRequest(request);
    //...省略其他逻辑...
  }
}

// 里式替换原则
Demo demo = new Demo();
demo.demofunction(new SecurityTransporter(/*省略参数*/););
```

父类`Transporter`使用`org.apache.http`库中的`HttpClient`类来传输网络数据。

子类`SecurityTransporter`继承父类`Transporter`，增加了额外的功能，支持传输`appId`和`appToken`认证信息。

> 在上面的代码中，子类`SecurityTransporter`的设计完全符合里氏替换原则，可以替换父类出现的任何位置，并且原有代码的逻辑性为不变且正确性没有被破坏。
>
> 刚刚的代码不就是简单的利用了面向对象的多态特性吗？多态和里氏替换原则说的不是一回事吗？
>
> 不是的。多态是里氏替换原则的基础，里氏替换原则是对多态的约束原则。

上面的代码还缺少对`appId`和`appToken`的参数校验，如果在传输之前，没有`appId`或者`appToken`没有设置，就直接抛出`NoAuthorizationRuntimeException`未授权异常。再来看看下面的改造后代码。

```java
// 改造前：
public class SecurityTransporter extends Transporter {
  //...省略其他代码..
  @Override
  public Response sendRequest(Request request) {
    if (StringUtils.isNotBlank(appId) && StringUtils.isNotBlank(appToken)) {
      request.addPayload("app-id", appId);
      request.addPayload("app-token", appToken);
    }
    return super.sendRequest(request);
  }
}

// 改造后：
public class SecurityTransporter extends Transporter {
  //...省略其他代码..
  @Override
  public Response sendRequest(Request request) {
    if (StringUtils.isBlank(appId) || StringUtils.isBlank(appToken)) {
      throw new NoAuthorizationRuntimeException(...);
    }
    request.addPayload("app-id", appId);
    request.addPayload("app-token", appToken);
    return super.sendRequest(request);
  }
}
```

代码改造之后，如果传递给`demo.demofunction`的是父类`Transporter`对象，不会抛出异常；如果是`SecurityTransporter`对象，可能会因为`appId`或者`appToken`没有设置抛出运行时异常。

尽管对于上游调用的`Demo`类可以不显式的捕获异常「调用代码不用修改」，但整个程序的逻辑行为有了变化。从设计思路上来讲，SecurityTransporter的设计不符合里氏替换原则。

> 里氏替换原则是一种设计原则，是用来指导继承关系中子类该如何设计的，子类的设计要保证替换父类的时候，不改变原有程序的逻辑以及不破坏原有程序的正确性。

#### 哪些代码明显违背了LSP

> 里氏替换原则还有一个更能落地、更有指导意义的描述，那就是「Design By Contract 按照协议来设计」。

子类设计的时候，要遵守父类的行为约定「协议」。父类定义了函数的行为约定，子类可以可以改变函数的内部实现逻辑，但不能改变函数原有的行为约定「函数声明要实现的功能；对输入输出异常的约定；甚至包含主时钟罗列的任何特殊说明」。

- **子类违背父类声明要实现的功能**

  父类提供`sortOrdersByAmount()`订单排序函数，是按照金额从小到大排序。
  而子类重写了这个函数之后，是按照日期来给订单排序，就违背了里氏替换原则。

- **子类违背父类对输入、输出、异常的约定**

  父类函数约定，运行时出错返回null；获取数据为空的时候返回空集合「empty Collection」。

  子类重写函数之后，运行时出错抛出异常「exception」，使上游数据获取不到null，子类的设计违背了历史替换原则。

  ***

  父类函数约定，输入数据可以是任意整数。

  但子类实现时，只允许输入数据是正整数，也就是说子类对输入数据的校验比父类更加严格，就违背了里氏替换原则。

  ***

  父类约定函数之后抛出`ArgumentNullException`异常。

  子类设计时应该只允许抛出`ArgumentNullException`异常，任何其他异常的抛出，都会导致子类违背里氏替换原则。

- **子类违背父类注释中罗列的任何特殊说明**

  父类定义`withdraw()`提现函数的注释是这么写的：「用于的提现金额不得超过账户余额……」。

  而子类重写之后，针对VIP账号实现了透支提现的功能，这个子类的设计就违背了里氏替换原则。

还有一个窍门，就是用父类的单元测试去验证子类的代码，如果某些测试未通过，说明子类的实现没有完全遵守父类的约定，就可能违背了历史替换原则。

### 接口隔离原则

> 接口隔离原则的英文翻译是Interface Segregation Principle「ISP」：Clients shoud not be forced to depend upon interfaces that they do not use。客户端不应该被强迫依赖他不需要的接口。

接口这个词可以用在很多场合中。生活中可以用它来指公共协议。在软件开发中，我们既可以把它看成一组抽象的约定；也可以具体指系统与系统之间的API接口；也可以特指面向对象编程语言中的接口。

- 一组API接口集合
- 单个API接口或函数
- OOP中的接口概念

接下来，分别按照这三种理解方式，详细看看这个原则的解读和应用。

#### 把『接口』理解为一组API接口集合

> 比如用户微服务提供了一组跟用户相关的API给其他系统使用，比如登录、注册、查询用户信息等。

```java
public interface UserService {
  boolean register(String cellphone, String password);
  boolean login(String cellphone, String password);
  UserInfo getUserInfoById(long id);
  UserInfo getUserInfoByCellphone(String cellphone);
}

public class UserServiceImpl implements UserService {
  //...
}
```

后来，后台管理系统要实现删除用户功能，系统用户提供一个删除用户的接口。

> 很简单，只要在`UserService`中增加`deleteUserByCellphone()`或者`deleteUserById()`不就行了吗？

可以解决问题，但也隐藏了一些安全隐患。

因为删除用户是一个非常慎重的操作，我们只希望通过管理系统来执行，所以这个接口仅限于给后台管理系统使用。如果我们把它放在`UserService`中，那所有使用到`UserService`的系统，都新增了这个接口。不加限制的被其他业务系统调用，就有可能导致误删用户。

当然，最好的解决方案是从架构设计的层面，通过接口鉴权的方式来限制接口的使用。不过，如果暂时没有鉴权框架支持，我们还可以从代码设计的层面，尽量避免接口被误用。把删除接口单独放在另一个`RestrictedUserService`中，只打包提供给后台管理系统用。

```java
public interface UserService {
  boolean register(String cellphone, String password);
  boolean login(String cellphone, String password);
  UserInfo getUserInfoById(long id);
  UserInfo getUserInfoByCellphone(String cellphone);
}

public interface RestrictedUserService {
  boolean deleteUserByCellphone(String cellphone);
  boolean deleteUserById(long id);
}

public class UserServiceImpl implements UserService, RestrictedUserService {
  // ...省略实现代码...
}
```

**在设计微服务或者类库接口的时候，如果部分接口只被部分调用者使用，那我们就需要将这部分接口隔离出来，单独给对应的调用者使用，而不是强迫其他调用者也依赖这部分不会被用到的接口。**

#### 把「接口」理解为单个API接口或函数

如果我们再换一种理解方式，把接口理解为单个接口或函数。那接口隔离原则就可以理解为：**函数的设计要功能单一，不要将多个不同的功能逻辑放在同一个函数中实现。**

```java
public class Statistics {
  private Long max;
  private Long min;
  private Long average;
  private Long sum;
  private Long percentile99;
  private Long percentile999;
  //...省略constructor/getter/setter等方法...
}

public Statistics count(Collection<Long> dataSet) {
  Statistics statistics = new Statistics();
  //...省略计算逻辑...
  return statistics;
}
```

`count()`函数的功能不够单一，包括很多不同的统计功能。按照接口隔离原则，我们应该把`count()`拆分成几个更小粒度的函数，每个函数负责一个独立的统计功能。

```java
public Long max(Collection<Long> dataSet) { //... }
public Long min(Collection<Long> dataSet) { //... } 
public Long average(Colletion<Long> dataSet) { //... }
// ...省略其他统计函数...
```

> 从某种意义上讲`count()`函数也不能算是职责不够单一，毕竟他做的时候只跟统计有关。在之前单一职责原则的时候，也提到过类似的问题。实际上，判断功能是否单一，除了很强的主观性，还需要结合具体的场景。

如果项目中，对**每一个**需继续求，`Statistics`定义的统计信息都有涉及，那`count()`的设计时合理的。

如果每个统计需求只涉及`Statistics`罗列的统计信息的一部分，`count()`函数每次都会把所有的统计指标都计算一遍，就会做很多无用功，势必影响代码的性能，特别是在需要统计的数据量很大的时候。这个时候`count()`的设计就不合理了。

> 从这个角度讲，接口隔离原则跟单一职责原则有点类似，不过稍微有点区别：
>
> 单一职责原则针对的是模块、类、接口的设计。而接口隔离原则相对于单一职责原则，一方面侧重于接口的设计，另一方面思考角度不同。它提供的是一种判断接口是否职责单一的标准：通过调用者如何使用接口间接判断。如果调用者只使用部分接口，那接口的设计就不够职责单一。

#### 把「接口」理解为OOP中的接口概念

假设我们的项目中用到三个外部系统：Redis、MySQL、Kafka。每个系统都有对应一系类配置信息。为了在内存中存储这些配置信息，供项目中的其他模块使用/查看，我们分别设计实现了三个`Configuration`类: `RedisConfig`、`MysqlConfig`、`KafkaConfig`.

```java
public class RedisConfig {
    private ConfigSource configSource; //配置中心（比如zookeeper）
    private String address;
    private int timeout;
    private int maxTotal;
    //省略其他配置: maxWaitMillis,maxIdle,minIdle...

    public RedisConfig(ConfigSource configSource) {
        this.configSource = configSource;
    }

    public String getAddress() {
        return this.address;
    }
    //...省略其他get()、init()方法...

    public void update() {
      //从configSource加载配置到address/timeout/maxTotal...
    }
}

public class KafkaConfig { //...省略... }
public class MysqlConfig { //...省略... }
```

现在有一个新功能需求：支持Redis和Kafka配置信息的热更新「在配置中心更改了配置信息，我们系统不用重启系统的情况下，能够将最新的配置信息加载到内存中。」。注意Mysql的配置信息不进行热更新 。

> 为了实现这样的功能。我们设计实现了一个`ScheduleUpdater`类，以固定时间频率`periodInSeconds`来调用`RedisConfig`、`KafkaConfig`的`update()`方法更新配置信息。

```java

public interface Updater {
  void update();
}

public class RedisConfig implemets Updater {
  //...省略其他属性和方法...
  @Override
  public void update() { //... }
}

public class KafkaConfig implements Updater {
  //...省略其他属性和方法...
  @Override
  public void update() { //... }
}

public class MysqlConfig { //...省略其他属性和方法... }

public class ScheduledUpdater {
    private final ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();;
    private long initialDelayInSeconds;
    private long periodInSeconds;
    private Updater updater;

    public ScheduleUpdater(Updater updater, long initialDelayInSeconds, long periodInSeconds) {
        this.updater = updater;
        this.initialDelayInSeconds = initialDelayInSeconds;
        this.periodInSeconds = periodInSeconds;
    }

    public void run() {
        executor.scheduleAtFixedRate(new Runnable() {
            @Override
            public void run() {
                updater.update();
            }
        }, this.initialDelayInSeconds, this.periodInSeconds, TimeUnit.SECONDS);
    }
}

public class Application {
  ConfigSource configSource = new ZookeeperConfigSource(/*省略参数*/);
  public static final RedisConfig redisConfig = new RedisConfig(configSource);
  public static final KafkaConfig kafkaConfig = new KakfaConfig(configSource);
  public static final MySqlConfig mysqlConfig = new MysqlConfig(configSource);

  public static void main(String[] args) {
    ScheduledUpdater redisConfigUpdater = new ScheduledUpdater(redisConfig, 300, 300);
    redisConfigUpdater.run();
    
    ScheduledUpdater kafkaConfigUpdater = new ScheduledUpdater(kafkaConfig, 60, 60);
    kafkaConfigUpdater.run();
  }
}
```

那又有了一个新的监控功能需求。通过命令行查看Zookeeper中配置的信息比较麻烦，所以希望能有一种更加方便的配置信息查看方式。

> 我们可以在项目中开发一个内嵌的`SimpleHttpServer`，输出项目的配置信息到一个固定的HTTP地址，比如`http://127.0.0.1:2389/config`。我们只需要在浏览器中输入这个地址，就可以显示出系统的配置信息。不过出于某种原因，我们只想暴露Mysql和Redis的配置信息，不像暴露Kafka的配置信息。
>
> 为了实现这样的功能，我们还需要对上面的代码进行改造。

```java

public interface Updater {
  void update();
}

public interface Viewer {
  String outputInPlainText();
  Map<String, String> output();
}

public class RedisConfig implemets Updater, Viewer {
  //...省略其他属性和方法...
  @Override
  public void update() { //... }
  @Override
  public String outputInPlainText() { //... }
  @Override
  public Map<String, String> output() { //...}
}

public class KafkaConfig implements Updater {
  //...省略其他属性和方法...
  @Override
  public void update() { //... }
}

public class MysqlConfig implements Viewer {
  //...省略其他属性和方法...
  @Override
  public String outputInPlainText() { //... }
  @Override
  public Map<String, String> output() { //...}
}

public class SimpleHttpServer {
  private String host;
  private int port;
  private Map<String, List<Viewer>> viewers = new HashMap<>();
  
  public SimpleHttpServer(String host, int port) {//...}
  
  public void addViewers(String urlDirectory, Viewer viewer) {
    if (!viewers.containsKey(urlDirectory)) {
      viewers.put(urlDirectory, new ArrayList<Viewer>());
    }
    this.viewers.get(urlDirectory).add(viewer);
  }
  
  public void run() { //... }
}

public class Application {
    ConfigSource configSource = new ZookeeperConfigSource();
    public static final RedisConfig redisConfig = new RedisConfig(configSource);
    public static final KafkaConfig kafkaConfig = new KakfaConfig(configSource);
    public static final MySqlConfig mysqlConfig = new MySqlConfig(configSource);
    
    public static void main(String[] args) {
        ScheduledUpdater redisConfigUpdater =
            new ScheduledUpdater(redisConfig, 300, 300);
        redisConfigUpdater.run();
        
        ScheduledUpdater kafkaConfigUpdater =
            new ScheduledUpdater(kafkaConfig, 60, 60);
        redisConfigUpdater.run();
        
        SimpleHttpServer simpleHttpServer = new SimpleHttpServer(“127.0.0.1”, 2389);
        simpleHttpServer.addViewer("/config", redisConfig);
        simpleHttpServer.addViewer("/config", mysqlConfig);
        simpleHttpServer.run();
    }
}
```

至此，热更新和监控的需求我们都实现了。

我们设计了两个功能非常单一的接口：`Updater`和`Viewer`。`ScheduledUpdater`只依赖`Updater`这个接口，`SimpleHttpServer`只依赖`Viewer`接口。

> 这是符合接口隔离原则的。
>
> 如果想要通过一个大而全的Config接口，让RedisConfig、KafkaConfig、MysqlConfig都实现这个接口，并且也传递给ScheduledUpdater和SipleHttpServer，就会使下面这样。

```java
public interface Config {
  void update();
  String outputInPlainText();
  Map<String, String> output();
}

public class RedisConfig implements Config {
  //...需要实现Config的三个接口update/outputIn.../output
}

public class KafkaConfig implements Config {
  //...需要实现Config的三个接口update/outputIn.../output
}

public class MysqlConfig implements Config {
  //...需要实现Config的三个接口update/outputIn.../output
}

public class ScheduledUpdater {
  //...省略其他属性和方法..
  private Config config;

  public ScheduleUpdater(Config config, long initialDelayInSeconds, long periodInSeconds) {
      this.config = config;
      //...
  }
  //...
}

public class SimpleHttpServer {
  private String host;
  private int port;
  private Map<String, List<Config>> viewers = new HashMap<>();
 
  public SimpleHttpServer(String host, int port) {//...}
  
  public void addViewer(String urlDirectory, Config config) {
    if (!viewers.containsKey(urlDirectory)) {
      viewers.put(urlDirectory, new ArrayList<Config>());
    }
    viewers.get(urlDirectory).add(config);
  }
  
  public void run() { //... }
}
```

也能工作。但是。

- **第一种设计思路更加灵活、易扩展、易复用。**

  因为 Updater、Viewer 职责更加单一，单一就意味了通用、复用性好。比如，我们现在又有一个新的需求，开发一个 Metrics 性能统计模块，并且希望将 Metrics 也通过 SimpleHttpServer 显示在网页上，以方便查看。这个时候，尽管 Metrics 跟 RedisConfig 等没有任何关系，但我们仍然可以让 Metrics 类实现非常通用的 Viewer 接口，复用 SimpleHttpServer 的代码实现。具体的代码如下所示：

  ```java
  public class ApiMetrics implements Viewer {//...}
  public class DbMetrics implements Viewer {//...}
  
  public class Application {
      ConfigSource configSource = new ZookeeperConfigSource();
      public static final RedisConfig redisConfig = new RedisConfig(configSource);
      public static final KafkaConfig kafkaConfig = new KakfaConfig(configSource);
      public static final MySqlConfig mySqlConfig = new MySqlConfig(configSource);
      public static final ApiMetrics apiMetrics = new ApiMetrics();
      public static final DbMetrics dbMetrics = new DbMetrics();
      
      public static void main(String[] args) {
          SimpleHttpServer simpleHttpServer = new SimpleHttpServer(“127.0.0.1”, 2389);
          simpleHttpServer.addViewer("/config", redisConfig);
          simpleHttpServer.addViewer("/config", mySqlConfig);
          simpleHttpServer.addViewer("/metrics", apiMetrics);
          simpleHttpServer.addViewer("/metrics", dbMetrics);
          simpleHttpServer.run();
      }
  }
  ```

- **第二种设计思路在代码实现上冗余。**

  因为 Config 接口中包含两类不相关的接口，一类是 update()，一类是 output() 和 outputInPlainText()。理论上，KafkaConfig 只需要实现 update() 接口，并不需要实现 output() 相关的接口。同理，MysqlConfig 只需要实现 output() 相关接口，并需要实现 update() 接口。但第二种设计思路要求 RedisConfig、KafkaConfig、MySqlConfig 必须同时实现 Config 的所有接口函数（update、output、outputInPlainText）。除此之外，如果我们要往 Config 中继续添加一个新的接口，那所有的实现类都要改动。相反，如果我们的接口粒度比较小，那涉及改动的类就比较少。

### 依赖反转原则

> 依赖反转原则英文翻译是Dependency Inversion Principle（DIP）: High-level modules shouldn't depend on low-level modules.Both modules should depend on abstractions. In addition , abstractions shouldn't depend on details.Details depend on abstractions.高层模块不要依赖低层模块。高层模块和底层模块应该依赖抽象。此外，抽象不要依赖具体实现细节，具体实现细节依赖抽象。

有些概念可能会混淆，比如控制反转、依赖注入、spring的IOC。分别来看。

#### 控制反转IOC

控制反转是Inversion Of Control，暂时别跟spring的IOC联系在一起。先通过一个例子来看一下什么是控制反转。

```java
public class UserServiceTest {
  public static boolean doTest() {
    // ... 
  }
  
  public static void main(String[] args) {//这部分逻辑可以放到框架中
    if (doTest()) {
      System.out.println("Test succeed.");
    } else {
      System.out.println("Test failed.");
    }
  }
}
```

在这段代码中，流程是通过程序员来控制的「当需要测试执行测试时，手动运行这个测试函数的main方法」。

把他抽象成一个框架「类的自动化测试」来实现同样的功能。

```java
public abstract class TestCase {
  public void run() {
    if (doTest()) {
      System.out.println("Test succeed.");
    } else {
      System.out.println("Test failed.");
    }
  }
  
  public abstract boolean doTest();
}

public class JunitApplication {
  private static final List<TestCase> testCases = new ArrayList<>();
  
  public static void register(TestCase testCase) {
    testCases.add(testCase);
  }
  
  public static final void main(String[] args) {
    for (TestCase case: testCases) {
      case.run();
    }
  }
```

我们预留了扩展点，就是「需要测试的类」继承`TestCase`，实现`doTest`方法，并把它注册到`JunitApplication`里就行。

```java
public class UserServiceTest extends TestCase {
  @Override
  public boolean doTest() {
    // ... 
  }
}

// 注册操作还可以通过配置的方式来实现，不需要程序员显示调用register()
JunitApplication.register(new UserServiceTest();
```

这就是经典的控制反转的例子「不是每一个类都有一个自己的测试方法，而是把每一个类都注册到测试框架中」。

框架提供了一个可扩展的代码骨架，用来组装对象、管理整个执行流程。程序员利用框架进行开发的时候，只需要往预留的扩展点上添加自己的业务相关代码，就可以利用框架来驱动整个程序流程的执行。

> 除了刚刚例子中的模板设计模式之外，还有很多实现方式。控制反转不是具体的实现技巧，而是一个笼统的设计思想，一般用来指导框架层面的设计。

#### 依赖注入DI

> 依赖注入是一个具体的编程技巧。
>
> 听起来挺高大上的，但是一毛钱都不值。

一句话概括：**不通过new的方式在类的内部创建依赖类的对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递给类使用。**

举个例子。`Notification`负责消息通知发送。底层依赖`MessageSender`类的具体发送组件。

```java
// 非依赖注入实现方式
public class Notification {
  private MessageSender messageSender;
  
  public Notification() {
    this.messageSender = new MessageSender(); //此处有点像hardcode
  }
  
  public void sendMessage(String cellphone, String message) {
    //...省略校验逻辑等...
    this.messageSender.send(cellphone, message);
  }
}

public class MessageSender {
  public void send(String cellphone, String message) {
    //....
  }
}
// 使用Notification
Notification notification = new Notification();

// 依赖注入的实现方式
public class Notification {
  private MessageSender messageSender;
  
  // 通过构造函数将messageSender传递进来
  public Notification(MessageSender messageSender) {
    this.messageSender = messageSender;
  }
  
  public void sendMessage(String cellphone, String message) {
    //...省略校验逻辑等...
    this.messageSender.send(cellphone, message);
  }
}
//使用Notification
MessageSender messageSender = new MessageSender();
Notification notification = new Notification(messageSender);
```

通过依赖注入的方式将依赖的类对象传递进来，这样提高了代码的扩展性。

还可以通过更灵活的替换依赖类的方式，比如前面「开闭原则」的时候提到，把`MessageSender`定义成接口，基于接口而非实现编程。

```java
public class Notification {
  private MessageSender messageSender;
  
  public Notification(MessageSender messageSender) {
    this.messageSender = messageSender;
  }
  
  public void sendMessage(String cellphone, String message) {
    this.messageSender.send(cellphone, message);
  }
}

public interface MessageSender {
  void send(String cellphone, String message);
}

// 短信发送类
public class SmsSender implements MessageSender {
  @Override
  public void send(String cellphone, String message) {
    //....
  }
}

// 站内信发送类
public class InboxSender implements MessageSender {
  @Override
  public void send(String cellphone, String message) {
    //....
  }
}

//使用Notification
MessageSender messageSender = new SmsSender();
Notification notification = new Notification(messageSender);
```

这就是依赖注入。

它是非常简单，但非常有用。

它是编写可测试性代码最有效的手段。

#### 依赖注入框架「DI Framework」

通过上面的例子，`Notification`不需要采用硬编码的方式在类内部通过`new MessageSender`的方式调用`MessageSender`对象。但是这个创建对象、组装「注入」对象的工作仅仅是移动到了调用方代码。

```java
public class Demo {
  public static final void main(String args[]) {
    MessageSender sender = new SmsSender(); //创建对象
    Notification notification = new Notification(sender);//依赖注入
    notification.sendMessage("13918942177", "短信验证码：2346");
  }
}
```

还是需要程序员自己实现。

> 在实际的软件开发中，一个项目可能会涉及几十、上百、甚至几百个类，类对象的创建和依赖注入就会变得非常复杂。如果这部分工作都是靠程序员自己写代码实现，容易出错且开发成本高。
>
> 而对象创建和依赖注入的工作，本身跟具体的业务无关，完全可以抽象成框架来完成实现。

这个抽取成的框架，就是依赖注入框架。我们只需要通过依赖注入框架提供的接入点，简单配置一下所有需要创建的类对象，类与类之间的依赖关系，就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等本来需要程序员来做的事情。

> 现成的依赖注入框架除了spring之外，还有`Google Guice`、`Pico Container`、`Butterfly Container`等等。

spring生成自己是控制反转容器。这种说法没错。只是控制反转容器是一种比较宽泛的描述，依赖注入框架的表述更加具体、更有针对性。

因为我们前面讲到实现控制反转的方式有很多，除了依赖注入，还有末班模式等，而spring的控制反转主要是通过依赖注入实现的。



***

区分了这些之后，再来看依赖反转原则。

所谓高层模块和底层模块的划分，简单来说在调用链上，调用者属于高层，被调用者属于底层。

在平时的业务代码开发中，高层模块依赖低层模块是没有任何问题的。实际上，这条原则主要还是用来指导框架层面的设计，跟前面讲到的依赖反转类似。

`Tomcat`是运行`Java Web`应用程序的容器。我们编写的`Web`应用程序代码只需要部署在`Tomcat`容器下，就可以被`Tomcat`容器调用执行。按照之前的划分原则，`Tomcat`就属于高层模块，`Web`应用程序就属于底层模块。

`Tomcat`和应用程序代码之间没有直接的依赖关系，两者都依赖同一个抽象「`Servlet`规范」。`Servlet`规范不依赖具体的`Tomcat`容器和应用程序的具体实现，而`tomcat`和应用程序都依赖`Servlet`规范。



## KISS原则

> KISS原则英文描述有好几个版本。
>
> - Keep It Simple and Stupid
> - Keep It Short and Simple
> - Keep It Simple and Straightforward
>
> 表达的意思都差不多，就是：**尽量保持简单**。

> KISS原则算是一个万金油类型的设计原则。可以应用到很多场景中，不仅仅是软件开发，还经常用来指导更加广泛的系统及产品设计，比如，冰箱、建筑、手机等等的设计。

KISS原则就是保持代码可读性和可维护性的重要手段。

因为代码足够简单，也就意味着很容易被读懂，bug也就比较难隐藏。即便出现bug，修复起来也比较简单。

那具体怎么做呢？

### 代码行数越少就越「简单」吗？

比如下面三段代码实现了同样的功能：检查输入的字符串`ipAddress`是否是合法的IP地址。

> 一个合法的IP地址由四个数组组成，并且通过「.」来进行分割。每组数字的取值范围的0~255。第一组数据比较特殊，不允许为0。

```java
// 第一种实现方式: 使用正则表达式
public boolean isValidIpAddressV1(String ipAddress) {
  if (StringUtils.isBlank(ipAddress)) return false;
  String regex = "^(1\\d{2}|2[0-4]\\d|25[0-5]|[1-9]\\d|[1-9])\\."
          + "(1\\d{2}|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)\\."
          + "(1\\d{2}|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)\\."
          + "(1\\d{2}|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)$";
  return ipAddress.matches(regex);
}
```

```java
// 第二种实现方式: 使用现成的工具类
public boolean isValidIpAddressV2(String ipAddress) {
  if (StringUtils.isBlank(ipAddress)) return false;
  String[] ipUnits = StringUtils.split(ipAddress, '.');
  if (ipUnits.length != 4) {
    return false;
  }
  for (int i = 0; i < 4; ++i) {
    int ipUnitIntValue;
    try {
      ipUnitIntValue = Integer.parseInt(ipUnits[i]);
    } catch (NumberFormatException e) {
      return false;
    }
    if (ipUnitIntValue < 0 || ipUnitIntValue > 255) {
      return false;
    }
    if (i == 0 && ipUnitIntValue == 0) {
      return false;
    }
  }
  return true;
}
```

```java
// 第三种实现方式: 不使用任何工具类
public boolean isValidIpAddressV3(String ipAddress) {
  char[] ipChars = ipAddress.toCharArray();
  int length = ipChars.length;
  int ipUnitIntValue = -1;
  boolean isFirstUnit = true;
  int unitsCount = 0;
  for (int i = 0; i < length; ++i) {
    char c = ipChars[i];
    if (c == '.') {
      if (ipUnitIntValue < 0 || ipUnitIntValue > 255) return false;
      if (isFirstUnit && ipUnitIntValue == 0) return false;
      if (isFirstUnit) isFirstUnit = false;
      ipUnitIntValue = -1;
      unitsCount++;
      continue;
    }
    if (c < '0' || c > '9') {
      return false;
    }
    if (ipUnitIntValue == -1) ipUnitIntValue = 0;
    ipUnitIntValue = ipUnitIntValue * 10 + (c - '0');
  }
  if (ipUnitIntValue < 0 || ipUnitIntValue > 255) return false;
  if (unitsCount != 3) return false;
  return true;
}
```

- 第一种实现方式是利用正则表达式，只用三行代码就把问题解决了。

  却不符合KISS原则。

  - 正则表达式本身比较复杂，写出完全没有bug的正则表达式本身就比较有挑战。
  - 并不是每一个程序员都精通正则表达式。对于不怎么懂正则表达式的同事来说，看懂并维护这段正则表达式是比较困难的。
  - 这种实现方式导致代码的可读性和可维护性变差。

- 第二种方式使用了一些类库，`StringUtils`类、`Integer`类系统的线程的工具函数。

  最简单，更加符合KISS原则。

  - 实现逻辑清晰。容易理解。
  - 通用工具类的功能一般比较全面和通用，性能方面可能稍受影响。

  - 这些工具类是非常通用的工具类，大家也都比较熟悉，容易看懂和维护。

- 第三种方式不使用任何工具函数，而是通过逐一处理IP地址中的每一位字符来判断是否合法。

  除非`isValidIpAddress()`函数是影响系统性能的瓶颈代码，否则就是过度优化。

  - 针对底层字符进行处理，执行效率高。
  - 这样优化的投入产出比不高，增加了代码实现的难度。
  - 也就牺牲了代码的可读性。
  - 性能上的提升不会突破数量级，不明显。

### 代码逻辑复杂就违背KISS原则吗？

> 并不是代码行数越少就越简单，还要考虑逻辑复杂度、实现难度、代码的可读性等等。

先看一段逻辑复杂的代码

```java
// KMP algorithm: a, b分别是主串和模式串；n, m分别是主串和模式串的长度。
public static int kmp(char[] a, int n, char[] b, int m) {
  int[] next = getNexts(b, m);
  int j = 0;
  for (int i = 0; i < n; ++i) {
    while (j > 0 && a[i] != b[j]) { // 一直找到a[i]和b[j]
      j = next[j - 1] + 1;
    }
    if (a[i] == b[j]) {
      ++j;
    }
    if (j == m) { // 找到匹配模式串的了
      return i - m + 1;
    }
  }
  return -1;
}

// b表示模式串，m表示模式串的长度
private static int[] getNexts(char[] b, int m) {
  int[] next = new int[m];
  next[0] = -1;
  int k = -1;
  for (int i = 1; i < m; ++i) {
    while (k != -1 && b[k + 1] != b[i]) {
      k = next[k];
    }
    if (b[k + 1] == b[i]) {
      ++k;
    }
    next[i] = k;
  }
  return next;
}
```

这是「KMP字符串匹配算法」的代码实现。

逻辑复杂、实现难度大、可读性差。这三条通通都占了。但是并不违反KISS原则。

> KMP算法以快速高效著称。
>
> 当我们需要处理长文本字符串匹配问题（几百MB大小文本内容匹配），或者字符串匹配是产品的核心功能（比如vim、word等文本编辑器），又或者字符串匹配算法是系统性能瓶颈的时候，我们就应该尽可能选择高效的KMP算法。
>
> 而KMP算法本身就具有逻辑复杂、实现难度大、可读性差的特点。
>
> 本身就复杂的问题，用复杂的问题解决，并不违背KISS原则。

平时的项目开发中设计的字符串匹配问题，大部分都是针对小文本。

这种情况直接使用类库提供的字符串匹配算法「java `String`的就是暴力匹配法」。如果非要使用KMP算法、BM算法来实现简单字符串匹配，就违背了KISS原则。

### 如何写出KISS原则的代码

- 尽量不要使用同事可能不懂的技术。

  比如上面提到的正则表达式，还有一些编程语言中的过于高级的语法等。

- 不要重复造轮子，要善于使用已经有的工具类库。

  自己实现的类库，出bug的概率更高，维护成本也就更高。

- 不要过度优化。

  不要过度使用一些奇技淫巧。

  比如位运算代替算术运算、复杂的条件语句代替if-else、使用一些过于低层的函数来优化代码。这样就牺牲了代码的可读性。

其实这是一个非常主观的评判原则。可能你觉得很简单的代码，其他同事看起来就很困难。所以有一个非常有效的间接方法，就是**code review的时候，同事对你的代码有很多疑问，那就说明你的代码不够KISS。就需要优化。**

## YAGNI原则

> YAGNI原则的英文全称是： You Ain't Gonna Need It「你不会需要它」。

当用在软件开发中的时候，他的意思就是：

- 不要去设计当前用不到的功能
- 不要去编写当前用不到的代码
- 不要做过度设计。

比如，现在系统暂时只用Redis存储配置信息，以后可能会用到Zookeeper。根据YAGNI原则，在未使用到Zookeeper之前，没有必要编写写部分代码。

当然不是说不要考虑代码的扩展性，我们还是要预留好扩展点，等到需要的时候，再去实现Zookeeper存储配置信息的这部分代码就好。

再比如，不要在项目中提前引入不需要依赖的开发包。不要因为省事就把之前项目中用到的jar包全部引入，这也是违反YAGNI原则的。

> YANGI原则跟KISS原则关注的点不同。
>
> - KISS在于尽量保持简单『如何实现』
> - YANGI在于当前不需要做的就不要做『要不要做』

## DRY原则

> DRY原则的英文描述是Don't Repeat Yourself.
>
> **不要写重复的代码。**
>
> 定义非常简单，主要有三种典型的代码重复情况：实现逻辑重复、功能语义重复、代码执行重复。

### 实现逻辑重复

先来看看下面这段代码是否违反了实现逻辑重复。

```java
public class UserAuthenticator {
  public void authenticate(String username, String password) {
    if (!isValidUsername(username)) {
      // ...throw InvalidUsernameException...
    }
    if (!isValidPassword(password)) {
      // ...throw InvalidPasswordException...
    }
    //...省略其他代码...
  }

  private boolean isValidUsername(String username) {
    // check not null, not empty
    if (StringUtils.isBlank(username)) {
      return false;
    }
    // check length: 4~64
    int length = username.length();
    if (length < 4 || length > 64) {
      return false;
    }
    // contains only lowcase characters
    if (!StringUtils.isAllLowerCase(username)) {
      return false;
    }
    // contains only a~z,0~9,dot
    for (int i = 0; i < length; ++i) {
      char c = username.charAt(i);
      if (!(c >= 'a' && c <= 'z') || (c >= '0' && c <= '9') || c == '.') {
        return false;
      }
    }
    return true;
  }

  private boolean isValidPassword(String password) {
    // check not null, not empty
    if (StringUtils.isBlank(password)) {
      return false;
    }
    // check length: 4~64
    int length = password.length();
    if (length < 4 || length > 64) {
      return false;
    }
    // contains only lowcase characters
    if (!StringUtils.isAllLowerCase(password)) {
      return false;
    }
    // contains only a~z,0~9,dot
    for (int i = 0; i < length; ++i) {
      char c = password.charAt(i);
      if (!(c >= 'a' && c <= 'z') || (c >= '0' && c <= '9') || c == '.') {
        return false;
      }
    }
    return true;
  }
}
```

代码中，有两处非常明显的「重复代码片段」：`isValidUserName()`和`isValidPassword()`。

看起来违反了DRY原则，那我们把他合并成一个通用的`isValidUserNameOrPassword()`函数。

```java
public class UserAuthenticatorV2 {

  public void authenticate(String userName, String password) {
    if (!isValidUsernameOrPassword(userName)) {
      // ...throw InvalidUsernameException...
    }

    if (!isValidUsernameOrPassword(password)) {
      // ...throw InvalidPasswordException...
    }
  }

  private boolean isValidUsernameOrPassword(String usernameOrPassword) {
    //省略实现逻辑
    //跟原来的isValidUsername()或isValidPassword()的实现逻辑一样...
    return true;
  }
}
```

重构之后，代码行数减少了，没有重复代码了。

但是没有更好。相反的，违反了「单一职责原则」和「接口隔离原则」。

`isValidUserName()`和`isValidPassword()`两段代码逻辑，从代码实现逻辑上看起来是重复的，但是**语义不重复**：从功能上来看，这两个函数干的事情是完全独立的两件事情「校验用户名」「校验密码」。按照重构后的解法合并之后，会存在潜在问题，在未来某一天，如果修改了密码的校验逻辑，这时两个函数的实现逻辑就会完全不同，就又得拆分成两个代码。

**所以上面的代码，尽管代码的实现逻辑是想通的，但语义不同，我们判断它不违反DRY原则。**

对于包含重复代码的问题，我们可以抽象成更细粒度的函数来解决，比如『校验只包含a\~z、0\~9、dot』的逻辑可以封装成一个新的校验函数函数。

### 功能语义重复重复

下面有两个函数，出现在同一个项目中：`isValidIp()`和`checkIfIpValid()`。函数命名不同，实现逻辑不同，但功能一样，都是用来判断IP地址是否合法的。

```java
public boolean isValidIp(String ipAddress) {
  if (StringUtils.isBlank(ipAddress)) return false;
  String regex = "^(1\\d{2}|2[0-4]\\d|25[0-5]|[1-9]\\d|[1-9])\\."
          + "(1\\d{2}|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)\\."
          + "(1\\d{2}|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)\\."
          + "(1\\d{2}|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)$";
  return ipAddress.matches(regex);
}

public boolean checkIfIpValid(String ipAddress) {
  if (StringUtils.isBlank(ipAddress)) return false;
  String[] ipUnits = StringUtils.split(ipAddress, '.');
  if (ipUnits.length != 4) {
    return false;
  }
  for (int i = 0; i < 4; ++i) {
    int ipUnitIntValue;
    try {
      ipUnitIntValue = Integer.parseInt(ipUnits[i]);
    } catch (NumberFormatException e) {
      return false;
    }
    if (ipUnitIntValue < 0 || ipUnitIntValue > 255) {
      return false;
    }
    if (i == 0 && ipUnitIntValue == 0) {
      return false;
    }
  }
  return true;
}
```

这典型违反了DRY原则。我们应该在项目中，统一一种判断IP地址是否合法的实现逻辑和实现代码。

假设我们不统一实现，假设哪一天IP规则改变了，那多个判断逻辑需要同时修改。否则就会出bug。

### 代码执行重复

举个例子。

```java
public class UserService {
  private UserRepo userRepo;//通过依赖注入或者IOC框架注入

  public User login(String email, String password) {
    boolean existed = userRepo.checkIfUserExisted(email, password);
    if (!existed) {
      // ... throw AuthenticationFailureException...
    }
    User user = userRepo.getUserByEmail(email);
    return user;
  }
}

public class UserRepo {
  public boolean checkIfUserExisted(String email, String password) {
    if (!EmailValidation.validate(email)) {
      // ... throw InvalidEmailException...
    }

    if (!PasswordValidation.validate(password)) {
      // ... throw InvalidPasswordException...
    }

    //...query db to check if email&password exists...
  }

  public User getUserByEmail(String email) {
    if (!EmailValidation.validate(email)) {
      // ... throw InvalidEmailException...
    }
    //...query db to get user by email...
  }
}
```

`email`的校验逻辑`EmailValidation.validate(email)`被执行了两次。

- `checkIfUserExisted()`的时候。
- `getUserByEmail()`的时候。

为了解决这个，把校验逻辑统一放到UserService中就行。

还有一个隐蔽的执行重复。就是`login()`不需要调用`checkIfUserExisted()`,只需要通过email调用`getUserByEmail()`从数据库中取出来对比密码就行。

> 第二处修改尤为重要，因为重复的是两次IO操作。

重构代码如下。

```java
public class UserService {
  private UserRepo userRepo;//通过依赖注入或者IOC框架注入

  public User login(String email, String password) {
    if (!EmailValidation.validate(email)) {
      // ... throw InvalidEmailException...
    }
    if (!PasswordValidation.validate(password)) {
      // ... throw InvalidPasswordException...
    }
    User user = userRepo.getUserByEmail(email);
    if (user == null || !password.equals(user.getPassword()) {
      // ... throw AuthenticationFailureException...
    }
    return user;
  }
}

public class UserRepo {
  public boolean checkIfUserExisted(String email, String password) {
    //...query db to check if email&password exists
  }

  public User getUserByEmail(String email) {
    //...query db to get user by email...
  }
}
```



### 代码重复性

> 什么是代码重复性？
>
> 首先来区分三个概念：代码复用性、代码复用、DRY原则。
>
> - 代码复用表示一种行为：在开发新功能的时候，尽量复用已经存在的代码。
> - 代码复用性表示一段代码可被复用的特性或能力：写代码的时候，要让代码尽量可复用。
> - DRY原则是一条原则：不要写重复代码。
>
> 三者有点类似，但是不同。

- **「不重复」不代表「可复用」**

  在一个项目代码中，可能不存在任何重复的代码，但也并不表示里面有可复用的代码，不重复和可复用完全是两个概念。所以，从这个角度来说，DRY 原则跟代码的可复用性讲的是两回事。

- **「复用」和「可复用性」关注的角度不同**

  代码“可复用性”是从代码开发者的角度来讲的，“复用”是从代码使用者的角度来讲的。比如，A 同事编写了一个 UrlUtils 类，代码的“可复用性”很好。B 同事在开发新功能的时候，直接“复用”A 同事编写的 UrlUtils 类。

尽管这三个概念从理解上有所区别，实际上要达到的目的都是为了减少代码量，提高代码的可读性、可维护性。

复用这个概念不仅可以直到细粒度的模块、类、函数的设计开发，实际上，一些框架、类库、组件等的产生也都是为了达到复用的目的。

#### 怎么提高代码复用性

- **减少代码耦合**

  对于高度耦合的代码，当我们希望复用其中一个功能，想把这个功能的代码抽取出来成一个独立的模块、类或者函数的时候，往往会牵一发而动全身。移动一点代码，就会牵连到很多其他相关的代码。所以，高度耦合的代码会影响代码的复用性，我们要尽量减少代码耦合。

- **满足单一职责原则**

  如果职责不够单一，模块、类设计的大而全，那依赖他的代码或者他依赖的代码就会比较多，增加了代码的耦合，就会影响代码的复用性，越细粒度的代码，代码的通用性会越好，越容易被复用。

- **模块化**

  不单单指一组类构成的模块，还可以理解为单个类、函数。我们要善于将功能独立的代码，封装成模块。独立的模块就像一块一块的积木，更容易复用，可以直接拿来搭建更加复杂的系统。

- **业务与非业务逻辑分离**

  越是跟业务无关的代码越容易复用，越是针对特定业务的代码越难复用。所以为了复用跟业务无关的代码，我们将业务和非业务逻辑代码分离，抽取成一些通用框架、类库、组件等。

- **通用代码下沉**

  从分层的角度来看，越底层的代码越通用、会被越多的模块调用，越应该设计的足够可复用。一般情况下，在代码分层之后，为了避免交叉调用导致调用关系混乱，我们只允许上层代码调用下层代码及同层代码，杜绝下层代码调用上层代码。所以，通用的代码尽量下沉到更下层。

- **继承、多态、抽象、封装**

  利用继承，可以将公共的代码抽取到父类，子类复用父类的属性和方法。

  利用多态，可以动态的替换一段代码的部分逻辑，让这段代码可复用。

  抽象和封装，从更加广义的层面、而非狭义的面向对象特性的层面来理解，越抽象、越不依赖具体的实现，越容易复用。代码封装成模块，隐层可变的细节、暴露不变的接口，就越容易复用。

- **应用模板等设计模式**

  一些设计模式，是对某些抽象问题解决方案的归纳，能够提高代码的复用性。

  比如，模板模式利用了多态实现，可以灵活地替换其中的部分代码，整个流程模板代码可复用。

> 除此之外，还有一些跟编程语言相关的特性，也能提高代码的复用性，比如泛型编程等。
>
> 除了这些具体方法之外，复用意识非常重要。在写代码的时候，要多思考，这个部分代码是否可以抽取出来，作为一个独立的模块、类或者函数供多处使用。在设计每个模块、类、函数的时候，要像设计一个外部API那样，去思考它的复用性。

但也不要过度设计，否则就违背了YAGNI原则。

这里有一个著名的原则，叫做`Rule of Three`。初次编写代码，可以不用考虑复用性。第二次遇到复用场景的时候，在进行重构使其复用。

## 迪米特法则

