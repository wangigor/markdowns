# 设计原则

> 包括**SOLID**、**KISS**、**YAGNI**、**DRY**、**LOD**原则等。

这些设计原则，从字面上理解不难。感觉一看就懂。但能够真的用到项目中，「看懂」和「会用」是两回事。而「用好」更是难上加难。

**要理解透。不要过于教条、不要生搬硬套。**

## SOLID原则

> SOLID原则并非1个原则，而是由5个设计原则组成：
>
> - 「S」单一职责原则。
> - 「O」开闭原则。
> - 「L」里氏替换原则。
> - 「I」接口隔离原则。
> - 「D」依赖反转原则。

### 单一职责原则

> 单一职责原则英文是Single Responsibility Principle（SRP）：A class or module should have a single responsibility「一个类或者模块只负责完成一个职责（功能）」。

这个原则描述的对象包含两个：类「class」和 模块「module」。

这两个概念，跟我们平时用到的还不一样，这俩概念是抽象概念。

- 把模块看做比类更加抽象的概念，类也可以看做模块。
- 把模块看做比类更加粗粒度的代码块，模块中包含多个类，多个类组成一个模块。

不论怎么理解，单一职责原则在用到这样的概念「比如微服务拆分」的时候，道理是相通的。

下面只从「类」设计的角度，讲解这个设计原则。

> 单一职责原则：一个类只负责完成一个职责或功能。
>
> 不要设计大而全的类，要设计粒度小、功能单一的类；
>
> 如果一个类包含了两个或者两个以上业务不相干的功能，那么它职责不够单一，应该进行拆分。

#### 如何判断职责是否足够单一

> 如果，一个类里既包含订单操作，又包含用户的操作。而订单和用户是两个独立的『业务领域模型』。这就违反了单一职责原则。我们需要将这个类拆分成两个粒度更细、功能更单一的类：订单类和用户类。

但大部分情况下，类里是不是包含了两个不相关的工鞥呢，并不是那么容易判断的。在真实软件开发中，对于一个类是否职责单一，很难拿捏。来看下面的例子。

```java
public class UserInfo {
  private long userId;
  private String username;
  private String email;
  private String telephone;
  private long createTime;
  private long lastLoginTime;
  private String avatarUrl;
  private String provinceOfAddress; // 省
  private String cityOfAddress; // 市
  private String regionOfAddress; // 区 
  private String detailedAddress; // 详细地址
  // ...省略其他属性和方法...
}
```

用UserInfo类来记录用户信息，这个UserInfo的设计是否满足单一职责原则呢？不一定。一种观点认为UserInfo类包含的都是用户相关的信息，所有的属性和方法都隶属于用户这样的业务模型，满足单一职责原则；另一种观点认为，地址信息在UserInfo类中占的比重比较高，可以继续拆分出独立的UserAddress类。这样才能职责更加单一。

其实这两种说法都不对，因为脱离了具体的应用场景。

- 如果是类似社交产品中，用户地址信息跟其他信息一样只是单纯用来展示「像身份证上面的地址信息一样」，那现在的UserInfo设计是合理的。
- 如果是类似电商平台中，用户的地址信息更偏向于物流目的地。那我们最好将地址信息从UserInfo中拆分出来，独立成用户物流信息『收货地址』。

再延伸一下，如果用户不止有一个账号登录，这里的账号意思是有多种身份认证方式，也就有多种身份认证相关信息比如「username、email、telephone」。也就得抽出独立的身份认证信息类。

可以看出，**在不同应用场景、不同阶段需求背景下，对同一个类的职责是否单一的认定，可能都不一样。**在目前场景和需求下，一个类的设计可能已经满足单一职责原则了，但在未来可能就不满足，需要继续拆分成粒度更细的类。**从不容的业务层面去评价一个类的设计是否职责单一，也会有不同的认识**。比如UserInfo从用户业务层面来看，包含的所有信息都属于用户，满足职责单一；如果从更细的业务层面「用户展示信息」「地址信息」「认证登录信息」等业务层面来看，UserInfo也确实应该拆分。

> 评价一个类的职责是否单一，并没有一个非常明确、可以量化的标准。可以说这是件非常主观、仁者见仁智者见智的事情。实际上真正的软件开发中，我们也没必要过于未雨绸缪，过度设计。

就先写一个粗粒度的类，满足当前的也无需求。随着业务的发展，如果粗粒度的类越来越庞大，代码越来越多，就拆分成几个更细粒度的类。这就是**持续重构**。

原则本身比较含糊不清、模棱两可。下面这几条判断原则，可以比较主观地思考类是否职责单一，更有指导意义、更具有可执行性。

- 类中的代码行数、函数或者属性过多。会影响代码的可读性和可维护性，需要考虑对类进行拆分。
- 类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想，需要对类进行拆分。
- 私有方法过多，需要考虑能否将私有方法独立到新的类中，设置为public方法，供更多地类使用，从而提高代码的复用性。
- 比较难给类起一个合适的名字，很难用一个业务名词概括，或者只能用一些笼统的Manager、Context之类的词语来命名，这就说明类的职责定义可能不够清晰。
- 类中大量的方法都是集中操作类中的某几个属性，比如UserInfo中，如果一半的方法都是在操作address信息，那就要考虑把这几个属性和对应的方法拆分出来。

依然有很多具有模糊描述性的标准比如「过多、很难……」，这些标准很难定量。

实际上，从另一个角度来看，当一个类的代码读起来让你头大，实现某个功能不知道该用那个函数，想用哪个函数翻半天都找不到，只用到一个小功能需要引入整个类「而这个类有很多不相关的其他函数」的时候，这就说明就是是现在了。做的项目多了，代码写多了，在开发中慢慢品味就能培养出这种『专业第六感』。

#### 类的职责是否设计的越单一越好

不是。

比如`Serialization`类实现了一个简单协议的序列化和反序列化功能。

```java
/**
 * Protocol format: identifier-string;{gson string}
 * For example: UEUEUE;{"a":"A","b":"B"}
 */
public class Serialization {
  private static final String IDENTIFIER_STRING = "UEUEUE;";
  private Gson gson;
  
  public Serialization() {
    this.gson = new Gson();
  }
  
  public String serialize(Map<String, String> object) {
    StringBuilder textBuilder = new StringBuilder();
    textBuilder.append(IDENTIFIER_STRING);
    textBuilder.append(gson.toJson(object));
    return textBuilder.toString();
  }
  
  public Map<String, String> deserialize(String text) {
    if (!text.startsWith(IDENTIFIER_STRING)) {
        return Collections.emptyMap();
    }
    String gsonStr = text.substring(IDENTIFIER_STRING.length());
    return gson.fromJson(gsonStr, Map.class);
  }
}
```

如果我们想让类的职责更加单一，我们可以对`Serialization`进行拆分，拆分成一个只负责序列化工作的`Serializer`类和另一个只负责反序列化工作的`Deserializer`类。

```java
public class Serializer {
  private static final String IDENTIFIER_STRING = "UEUEUE;";
  private Gson gson;
  
  public Serializer() {
    this.gson = new Gson();
  }
  
  public String serialize(Map<String, String> object) {
    StringBuilder textBuilder = new StringBuilder();
    textBuilder.append(IDENTIFIER_STRING);
    textBuilder.append(gson.toJson(object));
    return textBuilder.toString();
  }
}

public class Deserializer {
  private static final String IDENTIFIER_STRING = "UEUEUE;";
  private Gson gson;
  
  public Deserializer() {
    this.gson = new Gson();
  }
  
  public Map<String, String> deserialize(String text) {
    if (!text.startsWith(IDENTIFIER_STRING)) {
        return Collections.emptyMap();
    }
    String gsonStr = text.substring(IDENTIFIER_STRING.length());
    return gson.fromJson(gsonStr, Map.class);
  }
}
```

尽管经过拆分之后，`Serializer`类和`Deserializer`类的职责更加单一了，但却带来了新的问题。

比如协议格式需要修改，数据标识要从`UEUEUE`改为`DFDFDF`;或者序列化方式从JSON要改为XML，那么两个类需要做到同时修改，代码的内聚性显然没有原有的`Serialization`高，且导致代码的可维护性变差了。

> 实际上，**不管是应用设计原则还是设计模式，最终目的还是提高的可读性、可扩展性、复用性、可维护性等。**我们在考虑应用某一个设计原则是否合理的时候，也可以以此为最终的考量标准。



### 开闭原则

> 开闭原则是SOLID中最难理解、最难掌握，同时也最有用的一条原则。
>
> 开闭原则的英文是Open Closed Principle（OCP）: software entities(modules,classes,functions,etc.) should be open for extension,but closed for modification.「软件实体（模块、类、方法等）应该对扩展开放、对修改关闭。」。
>
> 也就是添加一个新的功能的时候，应该在已有代码基础上扩展代码「新增模块、类、方法」，而不是修改已有代码「修改模块、类、方法」。

举个例子，下面是一段API接口监控告警代码。

```java
public class Alert {
  private AlertRule rule;
  private Notification notification;

  public Alert(AlertRule rule, Notification notification) {
    this.rule = rule;
    this.notification = notification;
  }

  public void check(String api, long requestCount, long errorCount, long durationOfSeconds) {
    long tps = requestCount / durationOfSeconds;
    if (tps > rule.getMatchedRule(api).getMaxTps()) {
      notification.notify(NotificationEmergencyLevel.URGENCY, "...");
    }
    if (errorCount > rule.getMatchedRule(api).getMaxErrorCount()) {
      notification.notify(NotificationEmergencyLevel.SEVERE, "...");
    }
  }
}
```

- `AlertRule`存储告警规则，比如「tps超过多少进行告警」「失败次数超过多少进行告警」
- `Notification`是告警的通知类，支持邮件、短信、微信等多种通知渠道。
- `NotificationEmergencyLevel`是通知的紧急程度，比如SEVERE「严重」、URGENCY「紧急」、NORMAL「普通」、TRIVIAL「无关紧要」不同的紧急程度可能不同的发送渠道。
- 业务逻辑集中在`check()`中，上游统计一段时间内错误请求次数和调用次数，然后判断进行告警。

如果我们需要一个新功能「当每秒钟接口超时请求个数，超过某个阈值触发告警通知」。按照这样的需求沿用原有代码的情况下：

- 修改`check()`入参，添加新的统计数据timeoutCount
- 在`check()`函数中添加新的告警逻辑
- 修改可用于超时次数的告警规则`AlertRole`

```java
public class Alert {
  // ...省略AlertRule/Notification属性和构造函数...
  
  // 改动一：添加参数timeoutCount
  public void check(String api, long requestCount, long errorCount, long timeoutCount, long durationOfSeconds) {
    long tps = requestCount / durationOfSeconds;
    if (tps > rule.getMatchedRule(api).getMaxTps()) {
      notification.notify(NotificationEmergencyLevel.URGENCY, "...");
    }
    if (errorCount > rule.getMatchedRule(api).getMaxErrorCount()) {
      notification.notify(NotificationEmergencyLevel.SEVERE, "...");
    }
    // 改动二：添加接口超时处理逻辑
    long timeoutTps = timeoutCount / durationOfSeconds;
    if (timeoutTps > rule.getMatchedRule(api).getMaxTimeoutTps()) {
      notification.notify(NotificationEmergencyLevel.URGENCY, "...");
    }
  }
}
```

还存在两处额外的修改。

- 上游调用接口修改。
- 单元测试修改。

上面的代码更改是基于「修改」的方式来实现新功能的。基于「扩展」的方式，该怎么实现呢？

首先要对`Alert`代码进行重构：

- 将系统状态的统计参数封装在一个`ApiStatInfo`类中。
- 把一个一个的if判断，改成一组`handler`集合「把产生的`ApiStatInfo`传入不同的`handler`中进行告警操作」。因为handler有公共部分「告警属性`Notification`、告警规则`AlertRule`」
- `Alert`初始化的时候，要装入所有的`handler`
- 入口修改，由`check(ApiStatInfo apiStatInfo)`进入，轮询调用`handler`。

```java
public class Alert {
  private List<AlertHandler> alertHandlers = new ArrayList<>();
  
  public void addAlertHandler(AlertHandler alertHandler) {
    this.alertHandlers.add(alertHandler);
  }

  public void check(ApiStatInfo apiStatInfo) {
    for (AlertHandler handler : alertHandlers) {
      handler.check(apiStatInfo);
    }
  }
}

public class ApiStatInfo {//省略constructor/getter/setter方法
  private String api;
  private long requestCount;
  private long errorCount;
  private long durationOfSeconds;
}

public abstract class AlertHandler {
  protected AlertRule rule;
  protected Notification notification;
  public AlertHandler(AlertRule rule, Notification notification) {
    this.rule = rule;
    this.notification = notification;
  }
  public abstract void check(ApiStatInfo apiStatInfo);
}

public class TpsAlertHandler extends AlertHandler {
  public TpsAlertHandler(AlertRule rule, Notification notification) {
    super(rule, notification);
  }

  @Override
  public void check(ApiStatInfo apiStatInfo) {
    long tps = apiStatInfo.getRequestCount()/ apiStatInfo.getDurationOfSeconds();
    if (tps > rule.getMatchedRule(apiStatInfo.getApi()).getMaxTps()) {
      notification.notify(NotificationEmergencyLevel.URGENCY, "...");
    }
  }
}

public class ErrorAlertHandler extends AlertHandler {
  public ErrorAlertHandler(AlertRule rule, Notification notification){
    super(rule, notification);
  }

  @Override
  public void check(ApiStatInfo apiStatInfo) {
    if (apiStatInfo.getErrorCount() > rule.getMatchedRule(apiStatInfo.getApi()).getMaxErrorCount()) {
      notification.notify(NotificationEmergencyLevel.SEVERE, "...");
    }
  }
}
```

比如这样的告警组件要添加到应用容器中。大概是这个样子。

```java
public class ApplicationContext {
  private AlertRule alertRule;
  private Notification notification;
  private Alert alert;
  
  public void initializeBeans() {
    alertRule = new AlertRule(/*.省略参数.*/); //省略一些初始化代码
    notification = new Notification(/*.省略参数.*/); //省略一些初始化代码
    alert = new Alert();
    alert.addAlertHandler(new TpsAlertHandler(alertRule, notification));
    alert.addAlertHandler(new ErrorAlertHandler(alertRule, notification));
  }
  public Alert getAlert() { return alert; }

  // 饿汉式单例
  private static final ApplicationContext instance = new ApplicationContext();
  private ApplicationContext() {
    initializeBeans();
  }
  public static ApplicationContext getInstance() {
    return instance;
  }
}

public class Demo {
  public static void main(String[] args) {
    ApiStatInfo apiStatInfo = new ApiStatInfo();
    // ...省略设置apiStatInfo数据值的代码
    ApplicationContext.getInstance().getAlert().check(apiStatInfo);
  }
}
```

现在基于重构后的代码，添加上面的功能。

- 在`ApiStatInfo`中添加新的属性`timeoutCount`。
- 添加新的`TimeoutAlertHanler`类。
- 在`ApplicationContext.initializeBeans`类中，向`alert对象`注册`TimeoutAlertHandler对象`
- 在`AlertRule`类中，添加`timeoutCount`的告警阈值
- 上有统计增加对`timeoutCount`的统计，放入`ApiStatInfo`中。

```java
public class Alert { // 代码未改动... }
public class ApiStatInfo {//省略constructor/getter/setter方法
  private String api;
  private long requestCount;
  private long errorCount;
  private long durationOfSeconds;
  private long timeoutCount; // 改动一：添加新字段
}
public abstract class AlertHandler { //代码未改动... }
public class TpsAlertHandler extends AlertHandler {//代码未改动...}
public class ErrorAlertHandler extends AlertHandler {//代码未改动...}
// 改动二：添加新的handler
public class TimeoutAlertHandler extends AlertHandler {//省略代码...}

public class ApplicationContext {
  private AlertRule alertRule;
  private Notification notification;
  private Alert alert;
  
  public void initializeBeans() {
    alertRule = new AlertRule(/*.省略参数.*/); //省略一些初始化代码
    notification = new Notification(/*.省略参数.*/); //省略一些初始化代码
    alert = new Alert();
    alert.addAlertHandler(new TpsAlertHandler(alertRule, notification));
    alert.addAlertHandler(new ErrorAlertHandler(alertRule, notification));
    // 改动三：注册handler
    alert.addAlertHandler(new TimeoutAlertHandler(alertRule, notification));
  }
  //...省略其他未改动代码...
}

public class Demo {
  public static void main(String[] args) {
    ApiStatInfo apiStatInfo = new ApiStatInfo();
    // ...省略apiStatInfo的set字段代码
    apiStatInfo.setTimeoutCount(289); // 改动四：设置tiemoutCount值
    ApplicationContext.getInstance().getAlert().check(apiStatInfo);
}
```

原有的单元测试不用修改。check方法调用方式不变。

这样的代码是不是就更加灵活和易扩展呢？如果想添加新的告警逻辑，只需要专注在创建新的handler类和数据如何统计上即可。

#### 修改代码就意味着违背开闭原则吗？

> `ApiStatInfo`类中添加新的属性`timeoutCount`不算修改吗？
>
> `ApplicationContext.initializeBeans()`为`alert`添加新的`handler`和`timeoutCount`的统计不算修改吗？

这两个问题，一个一个看。

##### ApiStatInfo类添加新的timeoutCount参数

这个问题就是「给类中添加新的属性和方法，算修改还是扩展？」

回顾开闭原则的定义：软件实体「模块、类、方法等」应该对扩展开放、对修改关闭。开闭原则可以应用在不同粒度的代码中，可以使模块、也可以是类、还可以是方法「属性」。同一段代码改动，在粗粒度下，被认定为『修改』；在细粒度下，又可以被认定是扩展。

比如这个修改，在类层面是修改。但没有修改已有属性和方法，在方法「属性」层面又可以被认定是扩展。

所以，没有必要纠结于某个代码改动是修改还是扩展，更没必要纠结是否违反开闭原则。这条原则设计的初衷是：**只要他没有破坏原有代码的正常运行，没有破坏原有的单元测试，我们就认为是一个合理的代码改动。**

##### ApplicationContext.initializeBeans()为alert添加新的handler和timeoutCount的统计

这两处修改是在方法内部进行的，从类或者方法角度，都是地地道道的修改。

但是这样的修改时在所难免可以被接收的。

**在重构了Alert之后，我们的核心逻辑集中在Alert及其handler中，当我们添加新的告警逻辑是，Alert类完全不需要修改，只是扩展handler。那在「Alert告警模块」中，模块本身是在添加新的功能，符合开闭原则。**

而且，添加一个新功能，不可能任何模块、类、方法的代码都不修改。类需要创建、组装、初始化，才能构建成可运行的程序，这部分代码的修改在所难免。我们要做的是**尽量让修改操作更集中、更少、更上层，尽量让最核心、最复杂的那部分逻辑代码满足开闭原则。**

#### 如何做到「对扩展开放、对修改关闭」

**靠理论知识和实战经验，慢慢学习和积累。**

**开闭原则实际就是代码的扩展性问题，是判断一段代码是否易扩展的「金线」**。如果某段代码在应对未来需求变化的时候，能够做到“对扩展开放、对修改关闭”，那就说明这段代码的扩展性比较好。所以，问如何才能做到“对扩展开放、对修改关闭”，也就粗略地等同于在问，如何才能写出扩展性好的代码。

为了尽量写出扩展性好的代码，我们要**时刻具备扩展意识、抽象意识、封装意识**。

写代码时，要多花一点时间往前思考，这段代码未来可能有哪些需求变更点，要不要事先留好扩展点，以便应对未来需求变更的时候，不需要改动代码整体结构的情况下、做最小代码修改的情况下，新的功能能够插入到扩展点上。这就是对「扩展开放对修改关闭」。

**在识别出代码可变部分和不可变部分之后，我们要将可变部分封装起来，隔离变化，提供抽象化的不可变接口，给上层使用**。这样当具体的变化发生时，我们只需要基于相同的抽象接口，扩展一个新的实现，替换掉老的实现即可，上游调用系统代码基本不变。

下面一些更加具体些的方法论。

> 实际上，整个设计模式大部分都是围绕扩展性问题展开的。很多设计原则、设计思想、设计模式，都是以提高代码扩展性为最终目的。特别是23中经典设计模式，大部分都是因为要解决代码的扩展性问题而总结出来的。

最常用的提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程，以及大部分的经典设计模式『比如装饰、策略、模板、职责链、状态等』。

实际上，多态、依赖注入、基于接口而非实现编程，以及前面提到的抽象意识，说的都是同一种设计思路，只是从不同的角度、不同的层面来阐述而已。这也体现了「很多设计原则、思想、模式都是相通的」这一思想。

> 举个例子，比如系统中通过kafka来发布异步消息。对于这样一个功能的开发，我们要学会将其抽象成一组跟具体消息队列无关的异步消息接口。因为消息队列的产品有很多，当我们未来要替换消息队列时就可以做到容易的扩展。比如kafka替换成RocketMQ，要能方便拔掉老的消息队列实现，插入新的消息队列实现。
>
> ```java
> 
> // 这一部分体现了抽象意识
> public interface MessageQueue { //... }
> public class KafkaMessageQueue implements MessageQueue { //... }
> public class RocketMQMessageQueue implements MessageQueue {//...}
> 
> public interface MessageFromatter { //... }
> public class JsonMessageFromatter implements MessageFromatter {//...}
> public class ProtoBufMessageFromatter implements MessageFromatter {//...}
> 
> public class Demo {
>   private MessageQueue msgQueue; // 基于接口而非实现编程
>   public Demo(MessageQueue msgQueue) { // 依赖注入
>     this.msgQueue = msgQueue;
>   }
>   
>   // msgFormatter：多态、依赖注入
>   public void sendNotification(Notification notification, MessageFormatter msgFormatter) {
>     //...    
>   }
> }
> ```

#### 如何在项目中灵活应用开闭原则

问题就在于「如何识别所有可能的扩展点」。

- 业务导向。比如金融系统、电商系统、物流系统，要识别出尽可能多的扩展点，就**要对业务有足够的了解，能够知道当下一级未来可能要支持的业务需求。**
- 跟业务无关、通用、偏底层的系统导向，比如框架、组件、类库，需要了解「他们会被如何使用、今后打算添加哪些功能、使用者未来会有哪些更多的功能需求」等问题。

「**唯一不变的只有变化本身**」，即使我们有足够的了解，也不可能识别出所有的扩展点。即使能够识别出所有扩展点，为了这些地方都预留扩展点，这样的成本是不可接受的。**我们没有必要为一些遥远、不一定发生的需求提前买单，做过度设计。**

合理的做法是，对于一些比较确定的、短期内可能会扩展，或者需求改动对代码结构影响比较大的情况，或者实现成本不高的扩展点，事先做好扩展型设计。对于一些未来不确定是否需要支持的需求，或者实现起来比较复杂的扩展点，等到有需求驱动的时候，通过重构代码的方式支持扩展的需求。

在某些情况下，**开闭原则也要付出一些代价，因为代码的扩展性可能会跟可读性相冲突。**

> 比如Alert告警的例子。重构后的代码，可读性降低。因为多个handler肯定比不上所有都写在一起，通过if语句进行逻辑控制的可读性强。

> 但随着告警规则越来越多「if语句越来越多」这一份代码也会变得很多、很复杂、代码行数很多，也会导致可读性变差。那重构之后的实现思路又是更加合理的选择了。

没有一个放之四海皆准的参考标准，全凭实际应用场景决定。