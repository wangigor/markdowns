# 设计原则

> 包括**SOLID**、**KISS**、**YAGNI**、**DRY**、**LOD**原则等。

这些设计原则，从字面上理解不难。感觉一看就懂。但能够真的用到项目中，「看懂」和「会用」是两回事。而「用好」更是难上加难。

**要理解透。不要过于教条、不要生搬硬套。**

## SOLID原则

> SOLID原则并非1个原则，而是由5个设计原则组成：
>
> - 「S」单一职责原则。
> - 「O」开闭原则。
> - 「L」里氏替换原则。
> - 「I」接口隔离原则。
> - 「D」依赖反转原则。

### 单一职责原则

> 单一职责原则英文是Single Responsibility Principle（SRP）：A class or module should have a single responsibility「一个类或者模块只负责完成一个职责（功能）」。

这个原则描述的对象包含两个：类「class」和 模块「module」。

这两个概念，跟我们平时用到的还不一样，这俩概念是抽象概念。

- 把模块看做比类更加抽象的概念，类也可以看做模块。
- 把模块看做比类更加粗粒度的代码块，模块中包含多个类，多个类组成一个模块。

不论怎么理解，单一职责原则在用到这样的概念「比如微服务拆分」的时候，道理是相通的。

下面只从「类」设计的角度，讲解这个设计原则。

> 单一职责原则：一个类只负责完成一个职责或功能。
>
> 不要设计大而全的类，要设计粒度小、功能单一的类；
>
> 如果一个类包含了两个或者两个以上业务不相干的功能，那么它职责不够单一，应该进行拆分。

#### 如何判断职责是否足够单一

> 如果，一个类里既包含订单操作，又包含用户的操作。而订单和用户是两个独立的『业务领域模型』。这就违反了单一职责原则。我们需要将这个类拆分成两个粒度更细、功能更单一的类：订单类和用户类。

但大部分情况下，类里是不是包含了两个不相关的工鞥呢，并不是那么容易判断的。在真实软件开发中，对于一个类是否职责单一，很难拿捏。来看下面的例子。

```java
public class UserInfo {
  private long userId;
  private String username;
  private String email;
  private String telephone;
  private long createTime;
  private long lastLoginTime;
  private String avatarUrl;
  private String provinceOfAddress; // 省
  private String cityOfAddress; // 市
  private String regionOfAddress; // 区 
  private String detailedAddress; // 详细地址
  // ...省略其他属性和方法...
}
```

用UserInfo类来记录用户信息，这个UserInfo的设计是否满足单一职责原则呢？不一定。一种观点认为UserInfo类包含的都是用户相关的信息，所有的属性和方法都隶属于用户这样的业务模型，满足单一职责原则；另一种观点认为，地址信息在UserInfo类中占的比重比较高，可以继续拆分出独立的UserAddress类。这样才能职责更加单一。

其实这两种说法都不对，因为脱离了具体的应用场景。

- 如果是类似社交产品中，用户地址信息跟其他信息一样只是单纯用来展示「像身份证上面的地址信息一样」，那现在的UserInfo设计是合理的。
- 如果是类似电商平台中，用户的地址信息更偏向于物流目的地。那我们最好将地址信息从UserInfo中拆分出来，独立成用户物流信息『收货地址』。

再延伸一下，如果用户不止有一个账号登录，这里的账号意思是有多种身份认证方式，也就有多种身份认证相关信息比如「username、email、telephone」。也就得抽出独立的身份认证信息类。

可以看出，**在不同应用场景、不同阶段需求背景下，对同一个类的职责是否单一的认定，可能都不一样。**在目前场景和需求下，一个类的设计可能已经满足单一职责原则了，但在未来可能就不满足，需要继续拆分成粒度更细的类。**从不容的业务层面去评价一个类的设计是否职责单一，也会有不同的认识**。比如UserInfo从用户业务层面来看，包含的所有信息都属于用户，满足职责单一；如果从更细的业务层面「用户展示信息」「地址信息」「认证登录信息」等业务层面来看，UserInfo也确实应该拆分。

> 评价一个类的职责是否单一，并没有一个非常明确、可以量化的标准。可以说这是件非常主观、仁者见仁智者见智的事情。实际上真正的软件开发中，我们也没必要过于未雨绸缪，过度设计。

就先写一个粗粒度的类，满足当前的也无需求。随着业务的发展，如果粗粒度的类越来越庞大，代码越来越多，就拆分成几个更细粒度的类。这就是**持续重构**。

原则本身比较含糊不清、模棱两可。下面这几条判断原则，可以比较主观地思考类是否职责单一，更有指导意义、更具有可执行性。

- 类中的代码行数、函数或者属性过多。会影响代码的可读性和可维护性，需要考虑对类进行拆分。
- 类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想，需要对类进行拆分。
- 私有方法过多，需要考虑能否将私有方法独立到新的类中，设置为public方法，供更多地类使用，从而提高代码的复用性。
- 比较难给类起一个合适的名字，很难用一个业务名词概括，或者只能用一些笼统的Manager、Context之类的词语来命名，这就说明类的职责定义可能不够清晰。
- 类中大量的方法都是集中操作类中的某几个属性，比如UserInfo中，如果一半的方法都是在操作address信息，那就要考虑把这几个属性和对应的方法拆分出来。

依然有很多具有模糊描述性的标准比如「过多、很难……」，这些标准很难定量。

实际上，从另一个角度来看，当一个类的代码读起来让你头大，实现某个功能不知道该用那个函数，想用哪个函数翻半天都找不到，只用到一个小功能需要引入整个类「而这个类有很多不相关的其他函数」的时候，这就说明就是是现在了。做的项目多了，代码写多了，在开发中慢慢品味就能培养出这种『专业第六感』。

#### 类的职责是否设计的越单一越好

不是。

比如`Serialization`类实现了一个简单协议的序列化和反序列化功能。

```java
/**
 * Protocol format: identifier-string;{gson string}
 * For example: UEUEUE;{"a":"A","b":"B"}
 */
public class Serialization {
  private static final String IDENTIFIER_STRING = "UEUEUE;";
  private Gson gson;
  
  public Serialization() {
    this.gson = new Gson();
  }
  
  public String serialize(Map<String, String> object) {
    StringBuilder textBuilder = new StringBuilder();
    textBuilder.append(IDENTIFIER_STRING);
    textBuilder.append(gson.toJson(object));
    return textBuilder.toString();
  }
  
  public Map<String, String> deserialize(String text) {
    if (!text.startsWith(IDENTIFIER_STRING)) {
        return Collections.emptyMap();
    }
    String gsonStr = text.substring(IDENTIFIER_STRING.length());
    return gson.fromJson(gsonStr, Map.class);
  }
}
```

如果我们想让类的职责更加单一，我们可以对`Serialization`进行拆分，拆分成一个只负责序列化工作的`Serializer`类和另一个只负责反序列化工作的`Deserializer`类。

```java
public class Serializer {
  private static final String IDENTIFIER_STRING = "UEUEUE;";
  private Gson gson;
  
  public Serializer() {
    this.gson = new Gson();
  }
  
  public String serialize(Map<String, String> object) {
    StringBuilder textBuilder = new StringBuilder();
    textBuilder.append(IDENTIFIER_STRING);
    textBuilder.append(gson.toJson(object));
    return textBuilder.toString();
  }
}

public class Deserializer {
  private static final String IDENTIFIER_STRING = "UEUEUE;";
  private Gson gson;
  
  public Deserializer() {
    this.gson = new Gson();
  }
  
  public Map<String, String> deserialize(String text) {
    if (!text.startsWith(IDENTIFIER_STRING)) {
        return Collections.emptyMap();
    }
    String gsonStr = text.substring(IDENTIFIER_STRING.length());
    return gson.fromJson(gsonStr, Map.class);
  }
}
```

尽管经过拆分之后，`Serializer`类和`Deserializer`类的职责更加单一了，但却带来了新的问题。

比如协议格式需要修改，数据标识要从`UEUEUE`改为`DFDFDF`;或者序列化方式从JSON要改为XML，那么两个类需要做到同时修改，代码的内聚性显然没有原有的`Serialization`高，且导致代码的可维护性变差了。

> 实际上，**不管是应用设计原则还是设计模式，最终目的还是提高的可读性、可扩展性、复用性、可维护性等。**我们在考虑应用某一个设计原则是否合理的时候，也可以以此为最终的考量标准。