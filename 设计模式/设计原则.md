# 设计原则

> 包括**SOLID**、**KISS**、**YAGNI**、**DRY**、**LOD**原则等。

这些设计原则，从字面上理解不难。感觉一看就懂。但能够真的用到项目中，「看懂」和「会用」是两回事。而「用好」更是难上加难。

**要理解透。不要过于教条、不要生搬硬套。**

## SOLID原则

> SOLID原则并非1个原则，而是由5个设计原则组成：
>
> - 「S」单一职责原则。
> - 「O」开闭原则。
> - 「L」里氏替换原则。
> - 「I」接口隔离原则。
> - 「D」依赖反转原则。

### 单一职责原则

> 单一职责原则英文是Single Responsibility Principle（SRP）：A class or module should have a single responsibility「一个类或者模块只负责完成一个职责（功能）」。

这个原则描述的对象包含两个：类「class」和 模块「module」。

这两个概念，跟我们平时用到的还不一样，这俩概念是抽象概念。

- 把模块看做比类更加抽象的概念，类也可以看做模块。
- 把模块看做比类更加粗粒度的代码块，模块中包含多个类，多个类组成一个模块。

不论怎么理解，单一职责原则在用到这样的概念「比如微服务拆分」的时候，道理是相通的。

下面只从「类」设计的角度，讲解这个设计原则。

> 单一职责原则：一个类只负责完成一个职责或功能。
>
> 不要设计大而全的类，要设计粒度小、功能单一的类；
>
> 如果一个类包含了两个或者两个以上业务不相干的功能，那么它职责不够单一，应该进行拆分。

#### 如何判断职责是否足够单一

> 如果，一个类里既包含订单操作，又包含用户的操作。而订单和用户是两个独立的『业务领域模型』。这就违反了单一职责原则。我们需要将这个类拆分成两个粒度更细、功能更单一的类：订单类和用户类。

但大部分情况下，类里是不是包含了两个不相关的工鞥呢，并不是那么容易判断的。在真实软件开发中，对于一个类是否职责单一，很难拿捏。来看下面的例子。

```java
public class UserInfo {
  private long userId;
  private String username;
  private String email;
  private String telephone;
  private long createTime;
  private long lastLoginTime;
  private String avatarUrl;
  private String provinceOfAddress; // 省
  private String cityOfAddress; // 市
  private String regionOfAddress; // 区 
  private String detailedAddress; // 详细地址
  // ...省略其他属性和方法...
}
```

用UserInfo类来记录用户信息，这个UserInfo的设计是否满足单一职责原则呢？不一定。一种观点认为UserInfo类包含的都是用户相关的信息，所有的属性和方法都隶属于用户这样的业务模型，满足单一职责原则；另一种观点认为，地址信息在UserInfo类中占的比重比较高，可以继续拆分出独立的UserAddress类。这样才能职责更加单一。

其实这两种说法都不对，因为脱离了具体的应用场景。

- 如果是类似社交产品中，用户地址信息跟其他信息一样只是单纯用来展示「像身份证上面的地址信息一样」，那现在的UserInfo设计是合理的。
- 如果是类似电商平台中，用户的地址信息更偏向于物流目的地。那我们最好将地址信息从UserInfo中拆分出来，独立成用户物流信息『收货地址』。

再延伸一下，如果用户不止有一个账号登录，这里的账号意思是有多种身份认证方式，也就有多种身份认证相关信息比如「username、email、telephone」。也就得抽出独立的身份认证信息类。

可以看出，**在不同应用场景、不同阶段需求背景下，对同一个类的职责是否单一的认定，可能都不一样。**在目前场景和需求下，一个类的设计可能已经满足单一职责原则了，但在未来可能就不满足，需要继续拆分成粒度更细的类。**从不容的业务层面去评价一个类的设计是否职责单一，也会有不同的认识**。比如UserInfo从用户业务层面来看，包含的所有信息都属于用户，满足职责单一；如果从更细的业务层面「用户展示信息」「地址信息」「认证登录信息」等业务层面来看，UserInfo也确实应该拆分。

> 评价一个类的职责是否单一，并没有一个非常明确、可以量化的标准。可以说这是件非常主观、仁者见仁智者见智的事情。实际上真正的软件开发中，我们也没必要过于未雨绸缪，过度设计。

就先写一个粗粒度的类，满足当前的也无需求。随着业务的发展，如果粗粒度的类越来越庞大，代码越来越多，就拆分成几个更细粒度的类。这就是**持续重构**。

原则本身比较含糊不清、模棱两可。下面这几条判断原则，可以比较主观地思考类是否职责单一，更有指导意义、更具有可执行性。

- 类中的代码行数、函数或者属性过多。会影响代码的可读性和可维护性，需要考虑对类进行拆分。
- 类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想，需要对类进行拆分。
- 私有方法过多，需要考虑能否将私有方法独立到新的类中，设置为public方法，供更多地类使用，从而提高代码的复用性。
- 比较难给类起一个合适的名字，很难用一个业务名词概括，或者只能用一些笼统的Manager、Context之类的词语来命名，这就说明类的职责定义可能不够清晰。
- 类中大量的方法都是集中操作类中的某几个属性，比如UserInfo中，如果一半的方法都是在操作address信息，那就要考虑把这几个属性和对应的方法拆分出来。

依然有很多具有模糊描述性的标准比如「过多、很难……」，这些标准很难定量。

实际上，从另一个角度来看，当一个类的代码读起来让你头大，实现某个功能不知道该用那个函数，想用哪个函数翻半天都找不到，只用到一个小功能需要引入整个类「而这个类有很多不相关的其他函数」的时候，这就说明就是是现在了。做的项目多了，代码写多了，在开发中慢慢品味就能培养出这种『专业第六感』。

#### 类的职责是否设计的越单一越好

不是。

比如`Serialization`类实现了一个简单协议的序列化和反序列化功能。

```java
/**
 * Protocol format: identifier-string;{gson string}
 * For example: UEUEUE;{"a":"A","b":"B"}
 */
public class Serialization {
  private static final String IDENTIFIER_STRING = "UEUEUE;";
  private Gson gson;
  
  public Serialization() {
    this.gson = new Gson();
  }
  
  public String serialize(Map<String, String> object) {
    StringBuilder textBuilder = new StringBuilder();
    textBuilder.append(IDENTIFIER_STRING);
    textBuilder.append(gson.toJson(object));
    return textBuilder.toString();
  }
  
  public Map<String, String> deserialize(String text) {
    if (!text.startsWith(IDENTIFIER_STRING)) {
        return Collections.emptyMap();
    }
    String gsonStr = text.substring(IDENTIFIER_STRING.length());
    return gson.fromJson(gsonStr, Map.class);
  }
}
```

如果我们想让类的职责更加单一，我们可以对`Serialization`进行拆分，拆分成一个只负责序列化工作的`Serializer`类和另一个只负责反序列化工作的`Deserializer`类。

```java
public class Serializer {
  private static final String IDENTIFIER_STRING = "UEUEUE;";
  private Gson gson;
  
  public Serializer() {
    this.gson = new Gson();
  }
  
  public String serialize(Map<String, String> object) {
    StringBuilder textBuilder = new StringBuilder();
    textBuilder.append(IDENTIFIER_STRING);
    textBuilder.append(gson.toJson(object));
    return textBuilder.toString();
  }
}

public class Deserializer {
  private static final String IDENTIFIER_STRING = "UEUEUE;";
  private Gson gson;
  
  public Deserializer() {
    this.gson = new Gson();
  }
  
  public Map<String, String> deserialize(String text) {
    if (!text.startsWith(IDENTIFIER_STRING)) {
        return Collections.emptyMap();
    }
    String gsonStr = text.substring(IDENTIFIER_STRING.length());
    return gson.fromJson(gsonStr, Map.class);
  }
}
```

尽管经过拆分之后，`Serializer`类和`Deserializer`类的职责更加单一了，但却带来了新的问题。

比如协议格式需要修改，数据标识要从`UEUEUE`改为`DFDFDF`;或者序列化方式从JSON要改为XML，那么两个类需要做到同时修改，代码的内聚性显然没有原有的`Serialization`高，且导致代码的可维护性变差了。

> 实际上，**不管是应用设计原则还是设计模式，最终目的还是提高的可读性、可扩展性、复用性、可维护性等。**我们在考虑应用某一个设计原则是否合理的时候，也可以以此为最终的考量标准。



### 开闭原则

> 开闭原则是SOLID中最难理解、最难掌握，同时也最有用的一条原则。
>
> 开闭原则的英文是Open Closed Principle（OCP）: software entities(modules,classes,functions,etc.) should be open for extension,but closed for modification.「软件实体（模块、类、方法等）应该对扩展开放、对修改关闭。」。
>
> 也就是添加一个新的功能的时候，应该在已有代码基础上扩展代码「新增模块、类、方法」，而不是修改已有代码「修改模块、类、方法」。

举个例子，下面是一段API接口监控告警代码。

```java
public class Alert {
  private AlertRule rule;
  private Notification notification;

  public Alert(AlertRule rule, Notification notification) {
    this.rule = rule;
    this.notification = notification;
  }

  public void check(String api, long requestCount, long errorCount, long durationOfSeconds) {
    long tps = requestCount / durationOfSeconds;
    if (tps > rule.getMatchedRule(api).getMaxTps()) {
      notification.notify(NotificationEmergencyLevel.URGENCY, "...");
    }
    if (errorCount > rule.getMatchedRule(api).getMaxErrorCount()) {
      notification.notify(NotificationEmergencyLevel.SEVERE, "...");
    }
  }
}
```

- `AlertRule`存储告警规则，比如「tps超过多少进行告警」「失败次数超过多少进行告警」
- `Notification`是告警的通知类，支持邮件、短信、微信等多种通知渠道。
- `NotificationEmergencyLevel`是通知的紧急程度，比如SEVERE「严重」、URGENCY「紧急」、NORMAL「普通」、TRIVIAL「无关紧要」不同的紧急程度可能不同的发送渠道。
- 业务逻辑集中在`check()`中，上游统计一段时间内错误请求次数和调用次数，然后判断进行告警。

如果我们需要一个新功能「当每秒钟接口超时请求个数，超过某个阈值触发告警通知」。按照这样的需求沿用原有代码的情况下：

- 修改`check()`入参，添加新的统计数据timeoutCount
- 在`check()`函数中添加新的告警逻辑
- 修改可用于超时次数的告警规则`AlertRole`

```java
public class Alert {
  // ...省略AlertRule/Notification属性和构造函数...
  
  // 改动一：添加参数timeoutCount
  public void check(String api, long requestCount, long errorCount, long timeoutCount, long durationOfSeconds) {
    long tps = requestCount / durationOfSeconds;
    if (tps > rule.getMatchedRule(api).getMaxTps()) {
      notification.notify(NotificationEmergencyLevel.URGENCY, "...");
    }
    if (errorCount > rule.getMatchedRule(api).getMaxErrorCount()) {
      notification.notify(NotificationEmergencyLevel.SEVERE, "...");
    }
    // 改动二：添加接口超时处理逻辑
    long timeoutTps = timeoutCount / durationOfSeconds;
    if (timeoutTps > rule.getMatchedRule(api).getMaxTimeoutTps()) {
      notification.notify(NotificationEmergencyLevel.URGENCY, "...");
    }
  }
}
```

还存在两处额外的修改。

- 上游调用接口修改。
- 单元测试修改。

上面的代码更改是基于「修改」的方式来实现新功能的。基于「扩展」的方式，该怎么实现呢？

首先要对`Alert`代码进行重构：

- 将系统状态的统计参数封装在一个`ApiStatInfo`类中。
- 把一个一个的if判断，改成一组`handler`集合「把产生的`ApiStatInfo`传入不同的`handler`中进行告警操作」。因为handler有公共部分「告警属性`Notification`、告警规则`AlertRule`」
- `Alert`初始化的时候，要装入所有的`handler`
- 入口修改，由`check(ApiStatInfo apiStatInfo)`进入，轮询调用`handler`。

```java
public class Alert {
  private List<AlertHandler> alertHandlers = new ArrayList<>();
  
  public void addAlertHandler(AlertHandler alertHandler) {
    this.alertHandlers.add(alertHandler);
  }

  public void check(ApiStatInfo apiStatInfo) {
    for (AlertHandler handler : alertHandlers) {
      handler.check(apiStatInfo);
    }
  }
}

public class ApiStatInfo {//省略constructor/getter/setter方法
  private String api;
  private long requestCount;
  private long errorCount;
  private long durationOfSeconds;
}

public abstract class AlertHandler {
  protected AlertRule rule;
  protected Notification notification;
  public AlertHandler(AlertRule rule, Notification notification) {
    this.rule = rule;
    this.notification = notification;
  }
  public abstract void check(ApiStatInfo apiStatInfo);
}

public class TpsAlertHandler extends AlertHandler {
  public TpsAlertHandler(AlertRule rule, Notification notification) {
    super(rule, notification);
  }

  @Override
  public void check(ApiStatInfo apiStatInfo) {
    long tps = apiStatInfo.getRequestCount()/ apiStatInfo.getDurationOfSeconds();
    if (tps > rule.getMatchedRule(apiStatInfo.getApi()).getMaxTps()) {
      notification.notify(NotificationEmergencyLevel.URGENCY, "...");
    }
  }
}

public class ErrorAlertHandler extends AlertHandler {
  public ErrorAlertHandler(AlertRule rule, Notification notification){
    super(rule, notification);
  }

  @Override
  public void check(ApiStatInfo apiStatInfo) {
    if (apiStatInfo.getErrorCount() > rule.getMatchedRule(apiStatInfo.getApi()).getMaxErrorCount()) {
      notification.notify(NotificationEmergencyLevel.SEVERE, "...");
    }
  }
}
```

比如这样的告警组件要添加到应用容器中。大概是这个样子。

```java
public class ApplicationContext {
  private AlertRule alertRule;
  private Notification notification;
  private Alert alert;
  
  public void initializeBeans() {
    alertRule = new AlertRule(/*.省略参数.*/); //省略一些初始化代码
    notification = new Notification(/*.省略参数.*/); //省略一些初始化代码
    alert = new Alert();
    alert.addAlertHandler(new TpsAlertHandler(alertRule, notification));
    alert.addAlertHandler(new ErrorAlertHandler(alertRule, notification));
  }
  public Alert getAlert() { return alert; }

  // 饿汉式单例
  private static final ApplicationContext instance = new ApplicationContext();
  private ApplicationContext() {
    initializeBeans();
  }
  public static ApplicationContext getInstance() {
    return instance;
  }
}

public class Demo {
  public static void main(String[] args) {
    ApiStatInfo apiStatInfo = new ApiStatInfo();
    // ...省略设置apiStatInfo数据值的代码
    ApplicationContext.getInstance().getAlert().check(apiStatInfo);
  }
}
```

现在基于重构后的代码，添加上面的功能。

- 在`ApiStatInfo`中添加新的属性`timeoutCount`。
- 添加新的`TimeoutAlertHanler`类。
- 在`ApplicationContext.initializeBeans`类中，向`alert对象`注册`TimeoutAlertHandler对象`
- 在`AlertRule`类中，添加`timeoutCount`的告警阈值
- 上有统计增加对`timeoutCount`的统计，放入`ApiStatInfo`中。

```java
public class Alert { // 代码未改动... }
public class ApiStatInfo {//省略constructor/getter/setter方法
  private String api;
  private long requestCount;
  private long errorCount;
  private long durationOfSeconds;
  private long timeoutCount; // 改动一：添加新字段
}
public abstract class AlertHandler { //代码未改动... }
public class TpsAlertHandler extends AlertHandler {//代码未改动...}
public class ErrorAlertHandler extends AlertHandler {//代码未改动...}
// 改动二：添加新的handler
public class TimeoutAlertHandler extends AlertHandler {//省略代码...}

public class ApplicationContext {
  private AlertRule alertRule;
  private Notification notification;
  private Alert alert;
  
  public void initializeBeans() {
    alertRule = new AlertRule(/*.省略参数.*/); //省略一些初始化代码
    notification = new Notification(/*.省略参数.*/); //省略一些初始化代码
    alert = new Alert();
    alert.addAlertHandler(new TpsAlertHandler(alertRule, notification));
    alert.addAlertHandler(new ErrorAlertHandler(alertRule, notification));
    // 改动三：注册handler
    alert.addAlertHandler(new TimeoutAlertHandler(alertRule, notification));
  }
  //...省略其他未改动代码...
}

public class Demo {
  public static void main(String[] args) {
    ApiStatInfo apiStatInfo = new ApiStatInfo();
    // ...省略apiStatInfo的set字段代码
    apiStatInfo.setTimeoutCount(289); // 改动四：设置tiemoutCount值
    ApplicationContext.getInstance().getAlert().check(apiStatInfo);
}
```

原有的单元测试不用修改。check方法调用方式不变。

这样的代码是不是就更加灵活和易扩展呢？如果想添加新的告警逻辑，只需要专注在创建新的handler类和数据如何统计上即可。

#### 修改代码就意味着违背开闭原则吗？

> `ApiStatInfo`类中添加新的属性`timeoutCount`不算修改吗？
>
> `ApplicationContext.initializeBeans()`为`alert`添加新的`handler`和`timeoutCount`的统计不算修改吗？

这两个问题，一个一个看。

##### ApiStatInfo类添加新的timeoutCount参数

这个问题就是「给类中添加新的属性和方法，算修改还是扩展？」

回顾开闭原则的定义：软件实体「模块、类、方法等」应该对扩展开放、对修改关闭。开闭原则可以应用在不同粒度的代码中，可以使模块、也可以是类、还可以是方法「属性」。同一段代码改动，在粗粒度下，被认定为『修改』；在细粒度下，又可以被认定是扩展。

比如这个修改，在类层面是修改。但没有修改已有属性和方法，在方法「属性」层面又可以被认定是扩展。

所以，没有必要纠结于某个代码改动是修改还是扩展，更没必要纠结是否违反开闭原则。这条原则设计的初衷是：**只要他没有破坏原有代码的正常运行，没有破坏原有的单元测试，我们就认为是一个合理的代码改动。**

##### ApplicationContext.initializeBeans()为alert添加新的handler和timeoutCount的统计

这两处修改是在方法内部进行的，从类或者方法角度，都是地地道道的修改。

但是这样的修改时在所难免可以被接收的。

**在重构了Alert之后，我们的核心逻辑集中在Alert及其handler中，当我们添加新的告警逻辑是，Alert类完全不需要修改，只是扩展handler。那在「Alert告警模块」中，模块本身是在添加新的功能，符合开闭原则。**

而且，添加一个新功能，不可能任何模块、类、方法的代码都不修改。类需要创建、组装、初始化，才能构建成可运行的程序，这部分代码的修改在所难免。我们要做的是**尽量让修改操作更集中、更少、更上层，尽量让最核心、最复杂的那部分逻辑代码满足开闭原则。**

#### 如何做到「对扩展开放、对修改关闭」

**靠理论知识和实战经验，慢慢学习和积累。**

**开闭原则实际就是代码的扩展性问题，是判断一段代码是否易扩展的「金线」**。如果某段代码在应对未来需求变化的时候，能够做到“对扩展开放、对修改关闭”，那就说明这段代码的扩展性比较好。所以，问如何才能做到“对扩展开放、对修改关闭”，也就粗略地等同于在问，如何才能写出扩展性好的代码。

为了尽量写出扩展性好的代码，我们要**时刻具备扩展意识、抽象意识、封装意识**。

写代码时，要多花一点时间往前思考，这段代码未来可能有哪些需求变更点，要不要事先留好扩展点，以便应对未来需求变更的时候，不需要改动代码整体结构的情况下、做最小代码修改的情况下，新的功能能够插入到扩展点上。这就是对「扩展开放对修改关闭」。

**在识别出代码可变部分和不可变部分之后，我们要将可变部分封装起来，隔离变化，提供抽象化的不可变接口，给上层使用**。这样当具体的变化发生时，我们只需要基于相同的抽象接口，扩展一个新的实现，替换掉老的实现即可，上游调用系统代码基本不变。

下面一些更加具体些的方法论。

> 实际上，整个设计模式大部分都是围绕扩展性问题展开的。很多设计原则、设计思想、设计模式，都是以提高代码扩展性为最终目的。特别是23中经典设计模式，大部分都是因为要解决代码的扩展性问题而总结出来的。

最常用的提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程，以及大部分的经典设计模式『比如装饰、策略、模板、职责链、状态等』。

实际上，多态、依赖注入、基于接口而非实现编程，以及前面提到的抽象意识，说的都是同一种设计思路，只是从不同的角度、不同的层面来阐述而已。这也体现了「很多设计原则、思想、模式都是相通的」这一思想。

> 举个例子，比如系统中通过kafka来发布异步消息。对于这样一个功能的开发，我们要学会将其抽象成一组跟具体消息队列无关的异步消息接口。因为消息队列的产品有很多，当我们未来要替换消息队列时就可以做到容易的扩展。比如kafka替换成RocketMQ，要能方便拔掉老的消息队列实现，插入新的消息队列实现。
>
> ```java
> 
> // 这一部分体现了抽象意识
> public interface MessageQueue { //... }
> public class KafkaMessageQueue implements MessageQueue { //... }
> public class RocketMQMessageQueue implements MessageQueue {//...}
> 
> public interface MessageFromatter { //... }
> public class JsonMessageFromatter implements MessageFromatter {//...}
> public class ProtoBufMessageFromatter implements MessageFromatter {//...}
> 
> public class Demo {
>   private MessageQueue msgQueue; // 基于接口而非实现编程
>   public Demo(MessageQueue msgQueue) { // 依赖注入
>     this.msgQueue = msgQueue;
>   }
>   
>   // msgFormatter：多态、依赖注入
>   public void sendNotification(Notification notification, MessageFormatter msgFormatter) {
>     //...    
>   }
> }
> ```

#### 如何在项目中灵活应用开闭原则

问题就在于「如何识别所有可能的扩展点」。

- 业务导向。比如金融系统、电商系统、物流系统，要识别出尽可能多的扩展点，就**要对业务有足够的了解，能够知道当下一级未来可能要支持的业务需求。**
- 跟业务无关、通用、偏底层的系统导向，比如框架、组件、类库，需要了解「他们会被如何使用、今后打算添加哪些功能、使用者未来会有哪些更多的功能需求」等问题。

「**唯一不变的只有变化本身**」，即使我们有足够的了解，也不可能识别出所有的扩展点。即使能够识别出所有扩展点，为了这些地方都预留扩展点，这样的成本是不可接受的。**我们没有必要为一些遥远、不一定发生的需求提前买单，做过度设计。**

合理的做法是，对于一些比较确定的、短期内可能会扩展，或者需求改动对代码结构影响比较大的情况，或者实现成本不高的扩展点，事先做好扩展型设计。对于一些未来不确定是否需要支持的需求，或者实现起来比较复杂的扩展点，等到有需求驱动的时候，通过重构代码的方式支持扩展的需求。

在某些情况下，**开闭原则也要付出一些代价，因为代码的扩展性可能会跟可读性相冲突。**

> 比如Alert告警的例子。重构后的代码，可读性降低。因为多个handler肯定比不上所有都写在一起，通过if语句进行逻辑控制的可读性强。

> 但随着告警规则越来越多「if语句越来越多」这一份代码也会变得很多、很复杂、代码行数很多，也会导致可读性变差。那重构之后的实现思路又是更加合理的选择了。

没有一个放之四海皆准的参考标准，全凭实际应用场景决定。

### 里氏替换原则

> 它听上去似乎跟「多态」类似。但是侧重点不同。
>
> 里氏替换原则的英文是Liskov Substitution Principle「LSP」: If S is a subType of T,then objects of type T may be replaced with objects of type S，without breading the program.Robert Martin 之后重新描述了这个原则：Functions that use pointers of references to base classes must be able to use objects of derived classes without knowing it.
>
> 「**子类对象（objects of subtype/derived class）能够替换程序中父类对象（objects of base /parent class）出现的任何地方，并且保证原来程序的逻辑性为不变及正确性不被破坏。**」

如下代码。

```java
public class Transporter {
  private HttpClient httpClient;
  
  public Transporter(HttpClient httpClient) {
    this.httpClient = httpClient;
  }

  public Response sendRequest(Request request) {
    // ...use httpClient to send request
  }
}

public class SecurityTransporter extends Transporter {
  private String appId;
  private String appToken;

  public SecurityTransporter(HttpClient httpClient, String appId, String appToken) {
    super(httpClient);
    this.appId = appId;
    this.appToken = appToken;
  }

  @Override
  public Response sendRequest(Request request) {
    if (StringUtils.isNotBlank(appId) && StringUtils.isNotBlank(appToken)) {
      request.addPayload("app-id", appId);
      request.addPayload("app-token", appToken);
    }
    return super.sendRequest(request);
  }
}

public class Demo {    
  public void demoFunction(Transporter transporter) {    
    Reuqest request = new Request();
    //...省略设置request中数据值的代码...
    Response response = transporter.sendRequest(request);
    //...省略其他逻辑...
  }
}

// 里式替换原则
Demo demo = new Demo();
demo.demofunction(new SecurityTransporter(/*省略参数*/););
```

父类`Transporter`使用`org.apache.http`库中的`HttpClient`类来传输网络数据。

子类`SecurityTransporter`继承父类`Transporter`，增加了额外的功能，支持传输`appId`和`appToken`认证信息。

> 在上面的代码中，子类`SecurityTransporter`的设计完全符合里氏替换原则，可以替换父类出现的任何位置，并且原有代码的逻辑性为不变且正确性没有被破坏。
>
> 刚刚的代码不就是简单的利用了面向对象的多态特性吗？多态和里氏替换原则说的不是一回事吗？
>
> 不是的。多态是里氏替换原则的基础，里氏替换原则是对多态的约束原则。

上面的代码还缺少对`appId`和`appToken`的参数校验，如果在传输之前，没有`appId`或者`appToken`没有设置，就直接抛出`NoAuthorizationRuntimeException`未授权异常。再来看看下面的改造后代码。

```java
// 改造前：
public class SecurityTransporter extends Transporter {
  //...省略其他代码..
  @Override
  public Response sendRequest(Request request) {
    if (StringUtils.isNotBlank(appId) && StringUtils.isNotBlank(appToken)) {
      request.addPayload("app-id", appId);
      request.addPayload("app-token", appToken);
    }
    return super.sendRequest(request);
  }
}

// 改造后：
public class SecurityTransporter extends Transporter {
  //...省略其他代码..
  @Override
  public Response sendRequest(Request request) {
    if (StringUtils.isBlank(appId) || StringUtils.isBlank(appToken)) {
      throw new NoAuthorizationRuntimeException(...);
    }
    request.addPayload("app-id", appId);
    request.addPayload("app-token", appToken);
    return super.sendRequest(request);
  }
}
```

代码改造之后，如果传递给`demo.demofunction`的是父类`Transporter`对象，不会抛出异常；如果是`SecurityTransporter`对象，可能会因为`appId`或者`appToken`没有设置抛出运行时异常。

尽管对于上游调用的`Demo`类可以不显式的捕获异常「调用代码不用修改」，但整个程序的逻辑行为有了变化。从设计思路上来讲，SecurityTransporter的设计不符合里氏替换原则。

> 里氏替换原则是一种设计原则，是用来指导继承关系中子类该如何设计的，子类的设计要保证替换父类的时候，不改变原有程序的逻辑以及不破坏原有程序的正确性。

#### 哪些代码明显违背了LSP

> 里氏替换原则还有一个更能落地、更有指导意义的描述，那就是「Design By Contract 按照协议来设计」。

子类设计的时候，要遵守父类的行为约定「协议」。父类定义了函数的行为约定，子类可以可以改变函数的内部实现逻辑，但不能改变函数原有的行为约定「函数声明要实现的功能；对输入输出异常的约定；甚至包含主时钟罗列的任何特殊说明」。

- **子类违背父类声明要实现的功能**

  父类提供`sortOrdersByAmount()`订单排序函数，是按照金额从小到大排序。
  而子类重写了这个函数之后，是按照日期来给订单排序，就违背了里氏替换原则。

- **子类违背父类对输入、输出、异常的约定**

  父类函数约定，运行时出错返回null；获取数据为空的时候返回空集合「empty Collection」。

  子类重写函数之后，运行时出错抛出异常「exception」，使上游数据获取不到null，子类的设计违背了历史替换原则。

  ***

  父类函数约定，输入数据可以是任意整数。

  但子类实现时，只允许输入数据是正整数，也就是说子类对输入数据的校验比父类更加严格，就违背了里氏替换原则。

  ***

  父类约定函数之后抛出`ArgumentNullException`异常。

  子类设计时应该只允许抛出`ArgumentNullException`异常，任何其他异常的抛出，都会导致子类违背里氏替换原则。

- **子类违背父类注释中罗列的任何特殊说明**

  父类定义`withdraw()`提现函数的注释是这么写的：「用于的提现金额不得超过账户余额……」。

  而子类重写之后，针对VIP账号实现了透支提现的功能，这个子类的设计就违背了里氏替换原则。

还有一个窍门，就是用父类的单元测试去验证子类的代码，如果某些测试未通过，说明子类的实现没有完全遵守父类的约定，就可能违背了历史替换原则。

### 接口隔离原则

> 接口隔离原则的英文翻译是Interface Segregation Principle「ISP」：Clients shoud not be forced to depend upon interfaces that they do not use。客户端不应该被强迫依赖他不需要的接口。

接口这个词可以用在很多场合中。生活中可以用它来指公共协议。在软件开发中，我们既可以把它看成一组抽象的约定；也可以具体指系统与系统之间的API接口；也可以特指面向对象编程语言中的接口。

- 一组API接口集合
- 单个API接口或函数
- OOP中的接口概念

接下来，分别按照这三种理解方式，详细看看这个原则的解读和应用。

#### 把『接口』理解为一组API接口集合

> 比如用户微服务提供了一组跟用户相关的API给其他系统使用，比如登录、注册、查询用户信息等。

```java
public interface UserService {
  boolean register(String cellphone, String password);
  boolean login(String cellphone, String password);
  UserInfo getUserInfoById(long id);
  UserInfo getUserInfoByCellphone(String cellphone);
}

public class UserServiceImpl implements UserService {
  //...
}
```

后来，后台管理系统要实现删除用户功能，系统用户提供一个删除用户的接口。

> 很简单，只要在`UserService`中增加`deleteUserByCellphone()`或者`deleteUserById()`不就行了吗？

可以解决问题，但也隐藏了一些安全隐患。

因为删除用户是一个非常慎重的操作，我们只希望通过管理系统来执行，所以这个接口仅限于给后台管理系统使用。如果我们把它放在`UserService`中，那所有使用到`UserService`的系统，都新增了这个接口。不加限制的被其他业务系统调用，就有可能导致误删用户。

当然，最好的解决方案是从架构设计的层面，通过接口鉴权的方式来限制接口的使用。不过，如果暂时没有鉴权框架支持，我们还可以从代码设计的层面，尽量避免接口被误用。把删除接口单独放在另一个`RestrictedUserService`中，只打包提供给后台管理系统用。

```java
public interface UserService {
  boolean register(String cellphone, String password);
  boolean login(String cellphone, String password);
  UserInfo getUserInfoById(long id);
  UserInfo getUserInfoByCellphone(String cellphone);
}

public interface RestrictedUserService {
  boolean deleteUserByCellphone(String cellphone);
  boolean deleteUserById(long id);
}

public class UserServiceImpl implements UserService, RestrictedUserService {
  // ...省略实现代码...
}
```

**在设计微服务或者类库接口的时候，如果部分接口只被部分调用者使用，那我们就需要将这部分接口隔离出来，单独给对应的调用者使用，而不是强迫其他调用者也依赖这部分不会被用到的接口。**

#### 把「接口」理解为单个API接口或函数

如果我们再换一种理解方式，把接口理解为单个接口或函数。那接口隔离原则就可以理解为：**函数的设计要功能单一，不要将多个不同的功能逻辑放在同一个函数中实现。**

```java
public class Statistics {
  private Long max;
  private Long min;
  private Long average;
  private Long sum;
  private Long percentile99;
  private Long percentile999;
  //...省略constructor/getter/setter等方法...
}

public Statistics count(Collection<Long> dataSet) {
  Statistics statistics = new Statistics();
  //...省略计算逻辑...
  return statistics;
}
```

`count()`函数的功能不够单一，包括很多不同的统计功能。按照接口隔离原则，我们应该把`count()`拆分成几个更小粒度的函数，每个函数负责一个独立的统计功能。

```java
public Long max(Collection<Long> dataSet) { //... }
public Long min(Collection<Long> dataSet) { //... } 
public Long average(Colletion<Long> dataSet) { //... }
// ...省略其他统计函数...
```

> 从某种意义上讲`count()`函数也不能算是职责不够单一，毕竟他做的时候只跟统计有关。在之前单一职责原则的时候，也提到过类似的问题。实际上，判断功能是否单一，除了很强的主观性，还需要结合具体的场景。

如果项目中，对**每一个**需继续求，`Statistics`定义的统计信息都有涉及，那`count()`的设计时合理的。

如果每个统计需求只涉及`Statistics`罗列的统计信息的一部分，`count()`函数每次都会把所有的统计指标都计算一遍，就会做很多无用功，势必影响代码的性能，特别是在需要统计的数据量很大的时候。这个时候`count()`的设计就不合理了。

> 从这个角度讲，接口隔离原则跟单一职责原则有点类似，不过稍微有点区别：
>
> 单一职责原则针对的是模块、类、接口的设计。而接口隔离原则相对于单一职责原则，一方面侧重于接口的设计，另一方面思考角度不同。它提供的是一种判断接口是否职责单一的标准：通过调用者如何使用接口间接判断。如果调用者只使用部分接口，那接口的设计就不够职责单一。

#### 把「接口」理解为OOP中的接口概念

假设我们的项目中用到三个外部系统：Redis、MySQL、Kafka。每个系统都有对应一系类配置信息。为了在内存中存储这些配置信息，供项目中的其他模块使用/查看，我们分别设计实现了三个`Configuration`类: `RedisConfig`、`MysqlConfig`、`KafkaConfig`.

```java
public class RedisConfig {
    private ConfigSource configSource; //配置中心（比如zookeeper）
    private String address;
    private int timeout;
    private int maxTotal;
    //省略其他配置: maxWaitMillis,maxIdle,minIdle...

    public RedisConfig(ConfigSource configSource) {
        this.configSource = configSource;
    }

    public String getAddress() {
        return this.address;
    }
    //...省略其他get()、init()方法...

    public void update() {
      //从configSource加载配置到address/timeout/maxTotal...
    }
}

public class KafkaConfig { //...省略... }
public class MysqlConfig { //...省略... }
```

现在有一个新功能需求：支持Redis和Kafka配置信息的热更新「在配置中心更改了配置信息，我们系统不用重启系统的情况下，能够将最新的配置信息加载到内存中。」。注意Mysql的配置信息不进行热更新 。

> 为了实现这样的功能。我们设计实现了一个`ScheduleUpdater`类，以固定时间频率`periodInSeconds`来调用`RedisConfig`、`KafkaConfig`的`update()`方法更新配置信息。

```java

public interface Updater {
  void update();
}

public class RedisConfig implemets Updater {
  //...省略其他属性和方法...
  @Override
  public void update() { //... }
}

public class KafkaConfig implements Updater {
  //...省略其他属性和方法...
  @Override
  public void update() { //... }
}

public class MysqlConfig { //...省略其他属性和方法... }

public class ScheduledUpdater {
    private final ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();;
    private long initialDelayInSeconds;
    private long periodInSeconds;
    private Updater updater;

    public ScheduleUpdater(Updater updater, long initialDelayInSeconds, long periodInSeconds) {
        this.updater = updater;
        this.initialDelayInSeconds = initialDelayInSeconds;
        this.periodInSeconds = periodInSeconds;
    }

    public void run() {
        executor.scheduleAtFixedRate(new Runnable() {
            @Override
            public void run() {
                updater.update();
            }
        }, this.initialDelayInSeconds, this.periodInSeconds, TimeUnit.SECONDS);
    }
}

public class Application {
  ConfigSource configSource = new ZookeeperConfigSource(/*省略参数*/);
  public static final RedisConfig redisConfig = new RedisConfig(configSource);
  public static final KafkaConfig kafkaConfig = new KakfaConfig(configSource);
  public static final MySqlConfig mysqlConfig = new MysqlConfig(configSource);

  public static void main(String[] args) {
    ScheduledUpdater redisConfigUpdater = new ScheduledUpdater(redisConfig, 300, 300);
    redisConfigUpdater.run();
    
    ScheduledUpdater kafkaConfigUpdater = new ScheduledUpdater(kafkaConfig, 60, 60);
    kafkaConfigUpdater.run();
  }
}
```

那又有了一个新的监控功能需求。通过命令行查看Zookeeper中配置的信息比较麻烦，所以希望能有一种更加方便的配置信息查看方式。

> 我们可以在项目中开发一个内嵌的`SimpleHttpServer`，输出项目的配置信息到一个固定的HTTP地址，比如`http://127.0.0.1:2389/config`。我们只需要在浏览器中输入这个地址，就可以显示出系统的配置信息。不过出于某种原因，我们只想暴露Mysql和Redis的配置信息，不像暴露Kafka的配置信息。
>
> 为了实现这样的功能，我们还需要对上面的代码进行改造。

```java

public interface Updater {
  void update();
}

public interface Viewer {
  String outputInPlainText();
  Map<String, String> output();
}

public class RedisConfig implemets Updater, Viewer {
  //...省略其他属性和方法...
  @Override
  public void update() { //... }
  @Override
  public String outputInPlainText() { //... }
  @Override
  public Map<String, String> output() { //...}
}

public class KafkaConfig implements Updater {
  //...省略其他属性和方法...
  @Override
  public void update() { //... }
}

public class MysqlConfig implements Viewer {
  //...省略其他属性和方法...
  @Override
  public String outputInPlainText() { //... }
  @Override
  public Map<String, String> output() { //...}
}

public class SimpleHttpServer {
  private String host;
  private int port;
  private Map<String, List<Viewer>> viewers = new HashMap<>();
  
  public SimpleHttpServer(String host, int port) {//...}
  
  public void addViewers(String urlDirectory, Viewer viewer) {
    if (!viewers.containsKey(urlDirectory)) {
      viewers.put(urlDirectory, new ArrayList<Viewer>());
    }
    this.viewers.get(urlDirectory).add(viewer);
  }
  
  public void run() { //... }
}

public class Application {
    ConfigSource configSource = new ZookeeperConfigSource();
    public static final RedisConfig redisConfig = new RedisConfig(configSource);
    public static final KafkaConfig kafkaConfig = new KakfaConfig(configSource);
    public static final MySqlConfig mysqlConfig = new MySqlConfig(configSource);
    
    public static void main(String[] args) {
        ScheduledUpdater redisConfigUpdater =
            new ScheduledUpdater(redisConfig, 300, 300);
        redisConfigUpdater.run();
        
        ScheduledUpdater kafkaConfigUpdater =
            new ScheduledUpdater(kafkaConfig, 60, 60);
        redisConfigUpdater.run();
        
        SimpleHttpServer simpleHttpServer = new SimpleHttpServer(“127.0.0.1”, 2389);
        simpleHttpServer.addViewer("/config", redisConfig);
        simpleHttpServer.addViewer("/config", mysqlConfig);
        simpleHttpServer.run();
    }
}
```

至此，热更新和监控的需求我们都实现了。

我们设计了两个功能非常单一的接口：`Updater`和`Viewer`。`ScheduledUpdater`只依赖`Updater`这个接口，`SimpleHttpServer`只依赖`Viewer`接口。

> 这是符合接口隔离原则的。
>
> 如果想要通过一个大而全的Config接口，让RedisConfig、KafkaConfig、MysqlConfig都实现这个接口，并且也传递给ScheduledUpdater和SipleHttpServer，就会使下面这样。

```java
public interface Config {
  void update();
  String outputInPlainText();
  Map<String, String> output();
}

public class RedisConfig implements Config {
  //...需要实现Config的三个接口update/outputIn.../output
}

public class KafkaConfig implements Config {
  //...需要实现Config的三个接口update/outputIn.../output
}

public class MysqlConfig implements Config {
  //...需要实现Config的三个接口update/outputIn.../output
}

public class ScheduledUpdater {
  //...省略其他属性和方法..
  private Config config;

  public ScheduleUpdater(Config config, long initialDelayInSeconds, long periodInSeconds) {
      this.config = config;
      //...
  }
  //...
}

public class SimpleHttpServer {
  private String host;
  private int port;
  private Map<String, List<Config>> viewers = new HashMap<>();
 
  public SimpleHttpServer(String host, int port) {//...}
  
  public void addViewer(String urlDirectory, Config config) {
    if (!viewers.containsKey(urlDirectory)) {
      viewers.put(urlDirectory, new ArrayList<Config>());
    }
    viewers.get(urlDirectory).add(config);
  }
  
  public void run() { //... }
}
```

也能工作。但是。

- **第一种设计思路更加灵活、易扩展、易复用。**

  因为 Updater、Viewer 职责更加单一，单一就意味了通用、复用性好。比如，我们现在又有一个新的需求，开发一个 Metrics 性能统计模块，并且希望将 Metrics 也通过 SimpleHttpServer 显示在网页上，以方便查看。这个时候，尽管 Metrics 跟 RedisConfig 等没有任何关系，但我们仍然可以让 Metrics 类实现非常通用的 Viewer 接口，复用 SimpleHttpServer 的代码实现。具体的代码如下所示：

  ```java
  public class ApiMetrics implements Viewer {//...}
  public class DbMetrics implements Viewer {//...}
  
  public class Application {
      ConfigSource configSource = new ZookeeperConfigSource();
      public static final RedisConfig redisConfig = new RedisConfig(configSource);
      public static final KafkaConfig kafkaConfig = new KakfaConfig(configSource);
      public static final MySqlConfig mySqlConfig = new MySqlConfig(configSource);
      public static final ApiMetrics apiMetrics = new ApiMetrics();
      public static final DbMetrics dbMetrics = new DbMetrics();
      
      public static void main(String[] args) {
          SimpleHttpServer simpleHttpServer = new SimpleHttpServer(“127.0.0.1”, 2389);
          simpleHttpServer.addViewer("/config", redisConfig);
          simpleHttpServer.addViewer("/config", mySqlConfig);
          simpleHttpServer.addViewer("/metrics", apiMetrics);
          simpleHttpServer.addViewer("/metrics", dbMetrics);
          simpleHttpServer.run();
      }
  }
  ```

- **第二种设计思路在代码实现上冗余。**

  因为 Config 接口中包含两类不相关的接口，一类是 update()，一类是 output() 和 outputInPlainText()。理论上，KafkaConfig 只需要实现 update() 接口，并不需要实现 output() 相关的接口。同理，MysqlConfig 只需要实现 output() 相关接口，并需要实现 update() 接口。但第二种设计思路要求 RedisConfig、KafkaConfig、MySqlConfig 必须同时实现 Config 的所有接口函数（update、output、outputInPlainText）。除此之外，如果我们要往 Config 中继续添加一个新的接口，那所有的实现类都要改动。相反，如果我们的接口粒度比较小，那涉及改动的类就比较少。