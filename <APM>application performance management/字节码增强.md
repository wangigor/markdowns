

# 字节码增强



## 字节码

> .java文件是程序员能「使用」的文件。.class文件是java虚拟机能「使用」的文件。
>
> .java文件经过编译「javac」之后，转换成.class文件。先来了解一下class文件结构。
>
> 当然，仅供了解。不深。

首先随便写两个java文件。

- 父类

```java
package cn.igor.apm.demo;

public class BaseCode {

    public static final String key="temp_key";

    private int pField;

    public int getpField() {
        return pField;
    }

    public void setpField(int pField) {
        this.pField = pField;
    }

}
```

- 子类

```java
package cn.igor.apm.demo;

public class ByteCode extends BaseCode {

    private String cField;

    public String getcField() {
        return cField;
    }

    public void setcField(String cField) {
        this.cField = cField;
    }

    @Override
    public int getpField() {
        return super.getpField();
    }

    //测试
    public static int test() {
        int a = 1;
        int b = 2;
        return a + b;
    }

    public static void main(String[] args) {
        test();
    }
}
```

通过```javac ByteCode.java BaseCode.java ```编译得到两个对应的class文件。

> 这是两个二进制文件，我们先使用二进制打开它看看他的结构。
>
> 可以使用sublime，也可以使用vi
>
> ```bash
> # -b 以二进制显示
> vi -b baseCode.class
> #全部替换为16进制显示
> :%!xxd 
> ```

```hexadecimal
# BaseCode.class
00000000: cafe babe 0000 0034 001a 0a00 0400 1509  .......4........
00000010: 0003 0016 0700 1707 0018 0100 036b 6579  .............key
00000020: 0100 124c 6a61 7661 2f6c 616e 672f 5374  ...Ljava/lang/St
00000030: 7269 6e67 3b01 000d 436f 6e73 7461 6e74  ring;...Constant
00000040: 5661 6c75 6508 0019 0100 0670 4669 656c  Value......pFiel
00000050: 6401 0001 4901 0006 3c69 6e69 743e 0100  d...I...<init>..
00000060: 0328 2956 0100 0443 6f64 6501 000f 4c69  .()V...Code...Li
00000070: 6e65 4e75 6d62 6572 5461 626c 6501 0009  neNumberTable...
00000080: 6765 7470 4669 656c 6401 0003 2829 4901  getpField...()I.
00000090: 0009 7365 7470 4669 656c 6401 0004 2849  ..setpField...(I
000000a0: 2956 0100 0a53 6f75 7263 6546 696c 6501  )V...SourceFile.
000000b0: 000d 4261 7365 436f 6465 2e6a 6176 610c  ..BaseCode.java.
000000c0: 000b 000c 0c00 0900 0a01 0019 636e 2f69  ............cn/i
000000d0: 676f 722f 6170 6d2f 6465 6d6f 2f42 6173  gor/apm/demo/Bas
000000e0: 6543 6f64 6501 0010 6a61 7661 2f6c 616e  eCode...java/lan
000000f0: 672f 4f62 6a65 6374 0100 0874 656d 705f  g/Object...temp_
00000100: 6b65 7900 2100 0300 0400 0000 0200 1900  key.!...........
00000110: 0500 0600 0100 0700 0000 0200 0800 0200  ................
00000120: 0900 0a00 0000 0300 0100 0b00 0c00 0100  ................
00000130: 0d00 0000 1d00 0100 0100 0000 052a b700  .............*..
00000140: 01b1 0000 0001 000e 0000 0006 0001 0000  ................
00000150: 0003 0001 000f 0010 0001 000d 0000 001d  ................
00000160: 0001 0001 0000 0005 2ab4 0002 ac00 0000  ........*.......
00000170: 0100 0e00 0000 0600 0100 0000 0a00 0100  ................
00000180: 1100 1200 0100 0d00 0000 2200 0200 0200  ..........".....
00000190: 0000 062a 1bb5 0002 b100 0000 0100 0e00  ...*............
000001a0: 0000 0a00 0200 0000 0e00 0500 0f00 0100  ................
000001b0: 1300 0000 0200 14                        .......
```

```hexadecimal
# ByteCode.class
00000000: cafe babe 0000 0034 001e 0a00 0600 1809  .......4........
00000010: 0005 0019 0a00 0600 1a0a 0005 001b 0700  ................
00000020: 1c07 001d 0100 0663 4669 656c 6401 0012  .......cField...
00000030: 4c6a 6176 612f 6c61 6e67 2f53 7472 696e  Ljava/lang/Strin
00000040: 673b 0100 063c 696e 6974 3e01 0003 2829  g;...<init>...()
00000050: 5601 0004 436f 6465 0100 0f4c 696e 654e  V...Code...LineN
00000060: 756d 6265 7254 6162 6c65 0100 0967 6574  umberTable...get
00000070: 6346 6965 6c64 0100 1428 294c 6a61 7661  cField...()Ljava
00000080: 2f6c 616e 672f 5374 7269 6e67 3b01 0009  /lang/String;...
00000090: 7365 7463 4669 656c 6401 0015 284c 6a61  setcField...(Lja
000000a0: 7661 2f6c 616e 672f 5374 7269 6e67 3b29  va/lang/String;)
000000b0: 5601 0009 6765 7470 4669 656c 6401 0003  V...getpField...
000000c0: 2829 4901 0004 7465 7374 0100 046d 6169  ()I...test...mai
000000d0: 6e01 0016 285b 4c6a 6176 612f 6c61 6e67  n...([Ljava/lang
000000e0: 2f53 7472 696e 673b 2956 0100 0a53 6f75  /String;)V...Sou
000000f0: 7263 6546 696c 6501 000d 4279 7465 436f  rceFile...ByteCo
00000100: 6465 2e6a 6176 610c 0009 000a 0c00 0700  de.java.........
00000110: 080c 0011 0012 0c00 1300 1201 0019 636e  ..............cn
00000120: 2f69 676f 722f 6170 6d2f 6465 6d6f 2f42  /igor/apm/demo/B
00000130: 7974 6543 6f64 6501 0019 636e 2f69 676f  yteCode...cn/igo
00000140: 722f 6170 6d2f 6465 6d6f 2f42 6173 6543  r/apm/demo/BaseC
00000150: 6f64 6500 2100 0500 0600 0000 0100 0200  ode.!...........
00000160: 0700 0800 0000 0600 0100 0900 0a00 0100  ................
00000170: 0b00 0000 1d00 0100 0100 0000 052a b700  .............*..
00000180: 01b1 0000 0001 000c 0000 0006 0001 0000  ................
00000190: 0003 0001 000d 000e 0001 000b 0000 001d  ................
000001a0: 0001 0001 0000 0005 2ab4 0002 b000 0000  ........*.......
000001b0: 0100 0c00 0000 0600 0100 0000 0800 0100  ................
000001c0: 0f00 1000 0100 0b00 0000 2200 0200 0200  ..........".....
000001d0: 0000 062a 2bb5 0002 b100 0000 0100 0c00  ...*+...........
000001e0: 0000 0a00 0200 0000 0c00 0500 0d00 0100  ................
000001f0: 1100 1200 0100 0b00 0000 1d00 0100 0100  ................
00000200: 0000 052a b700 03ac 0000 0001 000c 0000  ...*............
00000210: 0006 0001 0000 0011 0009 0013 0012 0001  ................
00000220: 000b 0000 0028 0002 0002 0000 0008 043b  .....(.........;
00000230: 053c 1a1b 60ac 0000 0001 000c 0000 000e  .<..`...........
00000240: 0003 0000 0016 0002 0017 0004 0018 0009  ................
00000250: 0014 0015 0001 000b 0000 0021 0001 0001  ...........!....
00000260: 0000 0005 b800 0457 b100 0000 0100 0c00  .......W........
00000270: 0000 0a00 0200 0000 1c00 0400 1d00 0100  ................
00000280: 1600 0000 0200 17                        .......
```

### 约定结构

> 参考[wiki_java_class_file](https://en.wikipedia.org/wiki/Java_class_file#General_layout)。

<table class="wikitable"><table><tbody><tr>
<th>byte offset
</th>
<th>size
</th>
<th>type or value
</th>
<th>description
</th></tr>
<tr>
<td>0
</td>
<td rowspan="4">4 bytes
</td>
<td>u1 =<br>0xCA hex
</td>
<td rowspan="4"><a href="/wiki/Magic_number_(programming)" title="Magic number (programming)">magic number</a> (CAFEBABE) used to identify file as conforming to the class file format
<br/>前四字节是CAFEBABE的魔数。就像标记了文件类型，这是一个符合jvm规范的class文件的开头。
</td></tr>
<tr>
<td>1
</td>
<td>u1 =<br>0xFE hex
</td></tr>
<tr>
<td>2
</td>
<td>u1 =<br>0xBA hex
</td></tr>
<tr>
<td>3
</td>
<td>u1 =<br>0xBE hex
</td></tr>
<tr>
<td>4
</td>
<td rowspan="2">2 bytes
</td>
<td rowspan="2">u2
</td>
<td rowspan="2">minor version number of the class file format being used
 <br/>这是jdk的小版本号。我们上面两个00000034，前面0000说明没有小版本区别。
</td></tr>
<tr>
<td>5
</td></tr>
<tr>
<td>6
</td>
<td rowspan="2">2 bytes
</td>
<td rowspan="2">u2
</td>
<td rowspan="2">major version number of the class file format being used.<br>
  JDK的主版本号。这里经常会碰到的错误就是「unsupported major.minor version 52.0」说明当前这个class是通过java8编译的，而当前环境的jdk版本低于java8，不能兼容。
<p>Java SE 17 = 61 (0x3D hex)<br> 
Java SE 16 = 60 (0x3C hex),<br>
Java SE 15 = 59 (0x3B hex),<br>
Java SE 14 = 58 (0x3A hex),<br>
Java SE 13 = 57 (0x39 hex),<br>
Java SE 12 = 56 (0x38 hex),<br>
Java SE 11 = 55 (0x37 hex),<br>
Java SE 10 = 54 (0x36 hex),<sup id="cite_ref-3" class="reference"><a href="#cite_note-3">[3]</a></sup><br>
Java SE 9 = 53 (0x35 hex),<sup id="cite_ref-4" class="reference"><a href="#cite_note-4">[4]</a></sup><br>
Java SE 8 = 52 (0x34 hex),<br>Java SE 7 = 51 (0x33 hex),<br>Java SE 6.0 = 50 (0x32 hex),<br>Java SE 5.0 = 49 (0x31 hex),<br>JDK 1.4 = 48 (0x30 hex),<br>JDK 1.3 = 47 (0x2F hex),<br>JDK 1.2 = 46 (0x2E hex),<br>JDK 1.1 = 45 (0x2D hex).<br>For details of earlier version numbers see footnote 1 at <a rel="nofollow" class="external text" href="https://docs.oracle.com/javase/specs/jvms/se6/html/ClassFile.doc.html">The JavaTM Virtual Machine Specification 2nd edition</a>
</p>
</td></tr>
<tr>
<td>7
</td></tr>
<tr>
<td>8
</td>
<td rowspan="2">2 bytes
</td>
<td rowspan="2">u2
</td>
<td rowspan="2">constant pool count, number of entries in the following constant pool table.  This count is at least one greater than the actual number of entries; see following discussion.
<br/>这里标记了常量池的大小。我们看到上面class的一个常量池大小分别是001a「25」和001e「29」。这里似乎有两个违反常识的点。
<br/>一个是「都减了1：1a应该是26；1e应该是30」，wiki百科里说这是因为「文件格式开发过程中的历史选择」，或许可以理解为nextCurrentIndex。
<br/>另一个是「为啥不是+1，因为我们通常的计数都是从0开始」，这是因为索引0标识无效「null」不引用任何索引。
</td></tr>
<tr>
<td>9
</td></tr>
<tr>
<td>10
</td>
<td rowspan="4"><i>cpsize</i> (variable)
</td>
<td rowspan="4">table
</td>
<td rowspan="4">constant pool table, an array of variable-sized constant pool entries, containing items such as literal numbers, strings, and references to classes or methods.  Indexed starting at 1, containing (<i>constant pool count</i> - 1) number of entries in total (see note).
<br/>详见常量池结构
</td></tr>
<tr>
<td>...
</td></tr>
<tr>
<td>...
</td></tr>
<tr>
<td>...
</td></tr>
<tr>
<td>10+<i>cpsize</i>
</td>
<td rowspan="2">2 bytes
</td>
<td rowspan="2">u2
</td>
<td rowspan="2">access flags, a bitmask
<br/>访问标识的config，固定16位，不同的位代表不同的访问控制是否开启
<br/>详见访问标识。
</td></tr>
<tr>
<td>11+<i>cpsize</i>
</td></tr>
<tr>
<td>12+<i>cpsize</i>
</td>
<td rowspan="2">2 bytes
</td>
<td rowspan="2">u2
</td>
<td rowspan="2">identifies <i>this</i> class, index into the constant pool to a "Class"-type entry
<br/>类名对应的常量池索引
</td></tr>
<tr>
<td>13+<i>cpsize</i>
</td></tr>
<tr>
<td>14+<i>cpsize</i>
</td>
<td rowspan="2">2 bytes
</td>
<td rowspan="2">u2
</td>
<td rowspan="2">identifies <i>super</i> class, index into the constant pool to a "Class"-type entry
<br/>父类名对应的常量池索引
</td></tr>
<tr>
<td>15+<i>cpsize</i>
</td></tr>
<tr>
<td>16+<i>cpsize</i>
</td>
<td rowspan="2">2 bytes
</td>
<td rowspan="2">u2
</td>
<td rowspan="2">interface count, number of entries in the following interface table
<br/>接口计数器
</td></tr>
<tr>
<td>17+<i>cpsize</i>
</td></tr>
<tr>
<td>18+<i>cpsize</i>
</td>
<td rowspan="4"><i>isize</i> (variable)
</td>
<td rowspan="4">table
</td>
<td rowspan="4">interface table: a variable-length array of constant pool indexes describing the interfaces implemented by this class
<br/>接口表
</td></tr>
<tr>
<td>...
</td></tr>
<tr>
<td>...
</td></tr>
<tr>
<td>...
</td></tr>
<tr>
<td>18+<i>cpsize</i>+<i>isize</i>
</td>
<td rowspan="2">2 bytes
</td>
<td rowspan="2">u2
</td>
<td rowspan="2">field count, number of entries in the following field table
<br/>字段计数器
</td></tr>
<tr>
<td>19+<i>cpsize</i>+<i>isize</i>
</td></tr>
<tr>
<td>20+<i>cpsize</i>+<i>isize</i>
</td>
<td rowspan="4"><i>fsize</i> (variable)
</td>
<td rowspan="4">table
</td>
<td rowspan="4">field table, variable length array of fields
<p>each element is a field_info structure defined in <a rel="nofollow" class="external free" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.5">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.5</a>
<br/>字段表
</p>
</td></tr>
<tr>
<td>...
</td></tr>
<tr>
<td>...
</td></tr>
<tr>
<td>...
</td></tr>
<tr>
<td>20+<i>cpsize</i>+<i>isize</i>+<i>fsize</i>
</td>
<td rowspan="2">2 bytes
</td>
<td rowspan="2">u2
</td>
<td rowspan="2">method count, number of entries in the following method table
<br/>方法计数器
</td></tr>
<tr>
<td>21+<i>cpsize</i>+<i>isize</i>+<i>fsize</i>
</td></tr>
<tr>
<td>22+<i>cpsize</i>+<i>isize</i>+<i>fsize</i>
</td>
<td rowspan="4"><i>msize</i> (variable)
</td>
<td rowspan="4">table
</td>
<td rowspan="4">method table, variable length array of methods each element is a method_info structure defined in <a rel="nofollow" class="external free" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.6">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.6</a></td></tr>
<br/>方法表
<tr>
<td>...
</td></tr>
<tr>
<td>...
</td></tr>
<tr>
<td>...
</td></tr>
<tr>
<td>22+<i>cpsize</i>+<i>isize</i>+<i>fsize</i>+<i>msize</i>
</td>
<td rowspan="2">2 bytes
</td>
<td rowspan="2">u2
</td>
<td rowspan="2">attribute count, number of entries in the following attribute table
<br/>附加属性计数器
</td></tr>
<tr>
<td>23+<i>cpsize</i>+<i>isize</i>+<i>fsize</i>+<i>msize</i>
</td></tr>
<tr>
<td>24+<i>cpsize</i>+<i>isize</i>+<i>fsize</i>+<i>msize</i>
</td>
<td rowspan="4"><i>asize</i> (variable)
</td>
<td rowspan="4">table
</td>
<td rowspan="4">attribute table, variable length array of attributes<p>each element is an attribute_info structure defined in <a rel="nofollow" class="external free" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7</a>
<br/>附加属性表
</p>
</td></tr>
<tr>
<td>...
</td></tr>
<tr>
<td>...
</td></tr>
<tr>
<td>...
</td></tr></tbody></table>

### 常量池结构

> 资料来自[美团技术团队](https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html)。
>
> 举个例子：BaseCode.class的常量池计数器后面的第一个字节0a「十进制10」,对应CONSTANT_Methodref_info。后面有4个字节，前两个标识CONSTANT_Class_info的常量池索引0004「4」；后两个标识CONSTANT_NameAndType的常量池索引0015「21」。
>
> 这个常量池数据不是固定长度的，要根据具体情况而定。
>
> 在BaseCode.class「因为数据少」里共有25个常量信息，分别是
>
> ```text
> 0a 0004 0015
> 09 0003 0016
> 07 0017
> 07 0018
> 01 0003 6b6579
> 01 0012 4c6a6176612f6c616e672f537472696e673b
> 01 000d 436f6e7374616e7456616c7565
> 08 0019
> 01 0006 6704669656c64
> 01 0001 49
> 01 0006 3c696e69743e
> 01 0003 282956
> 01 0004 436f6465
> 01 000f 4c696e654e756d6265725461626c65
> 01 0009 676574704669656c64
> 01 0003 282949
> 01 0009 736574704669656c64
> 01 0004 28492956
> 01 000a 536f7572636546696c65
> 01 000d 42617365436f64652e6a617661
> 0c 000b 000c
> 0c 0009 000a
> 01 0019 636e2f69676f722f61706d2f64656d6f2f42617365436f6465
> 01 0010 6a6176612f6c616e672f4f626a656374
> 01 0008 74656d705f6b6579
> ```
>
> 了解就好。

![f5bdc7e8203ec666a531fcd19cdbcddc519208](https://wangigor-typora-images.oss-cn-chengdu.aliyuncs.com/111.jpeg)

### 访问标识

> 16位，与16个MASK进行位运算，就知道当前访问控制的组合。

![image-20210728224829661](https://wangigor-typora-images.oss-cn-chengdu.aliyuncs.com/image-20210728224829661.png)

在Modifier.java里有对应的代码。下面只把这16个mask列出来。

```java
/*
 * Access modifier flag constants from tables 4.1, 4.4, 4.5, and 4.7 of
 * <cite>The Java&trade; Virtual Machine Specification</cite>
 */

/**
 * The {@code int} value representing the {@code public}
 * modifier.
 */
public static final int PUBLIC           = 0x00000001;

/**
 * The {@code int} value representing the {@code private}
 * modifier.
 */
public static final int PRIVATE          = 0x00000002;

/**
 * The {@code int} value representing the {@code protected}
 * modifier.
 */
public static final int PROTECTED        = 0x00000004;

/**
 * The {@code int} value representing the {@code static}
 * modifier.
 */
public static final int STATIC           = 0x00000008;

/**
 * The {@code int} value representing the {@code final}
 * modifier.
 */
public static final int FINAL            = 0x00000010;

/**
 * The {@code int} value representing the {@code synchronized}
 * modifier.
 */
public static final int SYNCHRONIZED     = 0x00000020;

/**
 * The {@code int} value representing the {@code volatile}
 * modifier.
 */
public static final int VOLATILE         = 0x00000040;

/**
 * The {@code int} value representing the {@code transient}
 * modifier.
 */
public static final int TRANSIENT        = 0x00000080;

/**
 * The {@code int} value representing the {@code native}
 * modifier.
 */
public static final int NATIVE           = 0x00000100;

/**
 * The {@code int} value representing the {@code interface}
 * modifier.
 */
public static final int INTERFACE        = 0x00000200;

/**
 * The {@code int} value representing the {@code abstract}
 * modifier.
 */
public static final int ABSTRACT         = 0x00000400;

/**
 * The {@code int} value representing the {@code strictfp}
 * modifier.
 */
public static final int STRICT           = 0x00000800;
// Bits not (yet) exposed in the public API either because they
// have different meanings for fields and methods and there is no
// way to distinguish between the two in this class, or because
// they are not Java programming language keywords
static final int BRIDGE    = 0x00000040;
static final int VARARGS   = 0x00000080;
static final int SYNTHETIC = 0x00001000;
static final int ANNOTATION  = 0x00002000;
static final int ENUM      = 0x00004000;
static final int MANDATED  = 0x00008000;
```

那么上面两个class都是0x0021，也就是synchronized+public

### 字段

字段表结构

```info
field_info {
    u2             access_flags; 
    u2             name_index;
    u2             descriptor_index;
    u2             attributes_count;
    attribute_info attributes[attributes_count];
}
```

access_flags这个访问控制符呢，占两个字节，跟类的访问控制符基本一样。

```java
/**
 * Access modifier flags.
 */
static final char
    ACC_PUBLIC                 = 0x0001,
    ACC_PRIVATE                = 0x0002,
    ACC_PROTECTED              = 0x0004,
    ACC_STATIC                 = 0x0008,
    ACC_FINAL                  = 0x0010,
    ACC_SYNCHRONIZED           = 0x0020,
    ACC_VOLATILE               = 0x0040,
    ACC_TRANSIENT              = 0x0080,
    ACC_NATIVE                 = 0x0100,
    ACC_INTERFACE              = 0x0200,
    ACC_ABSTRACT               = 0x0400,
    ACC_STRICT                 = 0x0800,
    ACC_SYNTHETIC              = 0x1000,
    ACC_ANNOTATION             = 0x2000,
    ACC_ENUM                   = 0x4000,
    // aliases:
    ACC_SUPER                  = ACC_SYNCHRONIZED,
    ACC_BRIDGE                 = ACC_VOLATILE,
    ACC_VARARGS                = ACC_TRANSIENT;
```

name_index是字段名称对应的常量池索引，占2个字节。

descriptor_index是字段类型对应的常量池索引，占2个字节。

以BaseCode为例。

```text
0002 有两个字段
第一个 0019 public static final
      0005 名称常量池索引
      0006 类型常量池索引
      0001 有一个属性
      0007 属性名称
      00000002 属性值长度为2
      0008 属性值常量池索引
第二个 0002 private
      0009 名称常量池索引
      000a 类型常量池索引
      0000 没有属性
```

### 方法

方法表结构

```text
method_info {
    u2             access_flags;
    u2             name_index;
    u2             descriptor_index;
    u2             attributes_count;
    attribute_info attributes[attributes_count];
}
```

基本跟属性或者字段一样的。

但是对于Code属性，有很重要的就是操作符。

参考文档：[The Java Virtual Machine Instruction Set](https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-6.html)

### 属性

属性表结构

```text
attribute_info {
    u2 attribute_name_index;
    u4 attribute_length;
    u1 info[attribute_length];
}
```

预置的属性，分为三组：

```text
对于jvm解析class至关重要的5个
 ConstantValue
 Code
 StackMapTable
 Exceptions
 BootstrapMethods
```

```text
对于javase平台解析class重要的12个属性
InnerClasses
 EnclosingMethod
 Synthetic
 Signature
 RuntimeVisibleAnnotations
 RuntimeInvisibleAnnotations
 RuntimeVisibleParameterAnnotations
 RuntimeInvisibleParameterAnnotations
 RuntimeVisibleTypeAnnotations
 RuntimeInvisibleTypeAnnotations
 AnnotationDefault
 MethodParameters
```

```text
对于jvm和javase可以忽略的6个属性
 SourceFile
 SourceDebugExtension
 LineNumberTable
 LocalVariableTable
 LocalVariableTypeTable
 Deprecated
```

详情可以查看oracle 的[class format文档](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7)。

### 可视

> 当然不需要像上面这样按照字符查看，javap已经帮我们都做了。
>
> 命令：```javap -verbose XXXX```

那么上面的两个class文件就是下面这样

```c
Classfile /Users/wangke/IdeaProjects/git/apm-demo/src/main/java/cn/igor/apm/demo/BaseCode.class
  Last modified 2021-7-28; size 439 bytes
  MD5 checksum dfa4999537c5f223c429fc9a90892020
  Compiled from "BaseCode.java"
public class cn.igor.apm.demo.BaseCode
  minor version: 0
  major version: 52
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 = Methodref          #4.#21         // java/lang/Object."<init>":()V
   #2 = Fieldref           #3.#22         // cn/igor/apm/demo/BaseCode.pField:I
   #3 = Class              #23            // cn/igor/apm/demo/BaseCode
   #4 = Class              #24            // java/lang/Object
   #5 = Utf8               key
   #6 = Utf8               Ljava/lang/String;
   #7 = Utf8               ConstantValue
   #8 = String             #25            // temp_key
   #9 = Utf8               pField
  #10 = Utf8               I
  #11 = Utf8               <init>
  #12 = Utf8               ()V
  #13 = Utf8               Code
  #14 = Utf8               LineNumberTable
  #15 = Utf8               getpField
  #16 = Utf8               ()I
  #17 = Utf8               setpField
  #18 = Utf8               (I)V
  #19 = Utf8               SourceFile
  #20 = Utf8               BaseCode.java
  #21 = NameAndType        #11:#12        // "<init>":()V
  #22 = NameAndType        #9:#10         // pField:I
  #23 = Utf8               cn/igor/apm/demo/BaseCode
  #24 = Utf8               java/lang/Object
  #25 = Utf8               temp_key
{
  public static final java.lang.String key;
    descriptor: Ljava/lang/String;
    flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL
    ConstantValue: String temp_key

  public cn.igor.apm.demo.BaseCode();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: return
      LineNumberTable:
        line 3: 0

  public int getpField();
    descriptor: ()I
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: getfield      #2                  // Field pField:I
         4: ireturn
      LineNumberTable:
        line 10: 0

  public void setpField(int);
    descriptor: (I)V
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=2, args_size=2
         0: aload_0
         1: iload_1
         2: putfield      #2                  // Field pField:I
         5: return
      LineNumberTable:
        line 14: 0
        line 15: 5
}
SourceFile: "BaseCode.java"
```

```c
Classfile /Users/wangke/IdeaProjects/git/apm-demo/src/main/java/cn/igor/apm/demo/ByteCode.class
  Last modified 2021-7-28; size 827 bytes
  MD5 checksum 87f71228757b2c77c1561d00d6360ba9
  Compiled from "ByteCode.java"
public class cn.igor.apm.demo.ByteCode extends cn.igor.apm.demo.BaseCode
  minor version: 0
  major version: 52
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 = Methodref          #9.#27         // cn/igor/apm/demo/BaseCode."<init>":()V
   #2 = Fieldref           #6.#28         // cn/igor/apm/demo/ByteCode.cField:Ljava/lang/String;
   #3 = Methodref          #9.#29         // cn/igor/apm/demo/BaseCode.getpField:()I
   #4 = Methodref          #6.#30         // cn/igor/apm/demo/ByteCode.test:()I
   #5 = Fieldref           #31.#32        // java/lang/System.out:Ljava/io/PrintStream;
   #6 = Class              #33            // cn/igor/apm/demo/ByteCode
   #7 = Methodref          #34.#35        // java/lang/Class.isSynthetic:()Z
   #8 = Methodref          #36.#37        // java/io/PrintStream.println:(Z)V
   #9 = Class              #38            // cn/igor/apm/demo/BaseCode
  #10 = Utf8               cField
  #11 = Utf8               Ljava/lang/String;
  #12 = Utf8               <init>
  #13 = Utf8               ()V
  #14 = Utf8               Code
  #15 = Utf8               LineNumberTable
  #16 = Utf8               getcField
  #17 = Utf8               ()Ljava/lang/String;
  #18 = Utf8               setcField
  #19 = Utf8               (Ljava/lang/String;)V
  #20 = Utf8               getpField
  #21 = Utf8               ()I
  #22 = Utf8               test
  #23 = Utf8               main
  #24 = Utf8               ([Ljava/lang/String;)V
  #25 = Utf8               SourceFile
  #26 = Utf8               ByteCode.java
  #27 = NameAndType        #12:#13        // "<init>":()V
  #28 = NameAndType        #10:#11        // cField:Ljava/lang/String;
  #29 = NameAndType        #20:#21        // getpField:()I
  #30 = NameAndType        #22:#21        // test:()I
  #31 = Class              #39            // java/lang/System
  #32 = NameAndType        #40:#41        // out:Ljava/io/PrintStream;
  #33 = Utf8               cn/igor/apm/demo/ByteCode
  #34 = Class              #42            // java/lang/Class
  #35 = NameAndType        #43:#44        // isSynthetic:()Z
  #36 = Class              #45            // java/io/PrintStream
  #37 = NameAndType        #46:#47        // println:(Z)V
  #38 = Utf8               cn/igor/apm/demo/BaseCode
  #39 = Utf8               java/lang/System
  #40 = Utf8               out
  #41 = Utf8               Ljava/io/PrintStream;
  #42 = Utf8               java/lang/Class
  #43 = Utf8               isSynthetic
  #44 = Utf8               ()Z
  #45 = Utf8               java/io/PrintStream
  #46 = Utf8               println
  #47 = Utf8               (Z)V
{
  public cn.igor.apm.demo.ByteCode();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method cn/igor/apm/demo/BaseCode."<init>":()V
         4: return
      LineNumberTable:
        line 3: 0

  public java.lang.String getcField();
    descriptor: ()Ljava/lang/String;
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: getfield      #2                  // Field cField:Ljava/lang/String;
         4: areturn
      LineNumberTable:
        line 8: 0

  public void setcField(java.lang.String);
    descriptor: (Ljava/lang/String;)V
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=2, args_size=2
         0: aload_0
         1: aload_1
         2: putfield      #2                  // Field cField:Ljava/lang/String;
         5: return
      LineNumberTable:
        line 12: 0
        line 13: 5

  public int getpField();
    descriptor: ()I
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #3                  // Method cn/igor/apm/demo/BaseCode.getpField:()I
         4: ireturn
      LineNumberTable:
        line 17: 0

  public static int test();
    descriptor: ()I
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=2, args_size=0
         0: iconst_1
         1: istore_0
         2: iconst_2
         3: istore_1
         4: iload_0
         5: iload_1
         6: iadd
         7: ireturn
      LineNumberTable:
        line 22: 0
        line 23: 2
        line 24: 4

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=1, args_size=1
         0: invokestatic  #4                  // Method test:()I
         3: pop
         4: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;
         7: ldc           #6                  // class cn/igor/apm/demo/ByteCode
         9: invokevirtual #7                  // Method java/lang/Class.isSynthetic:()Z
        12: invokevirtual #8                  // Method java/io/PrintStream.println:(Z)V
        15: return
      LineNumberTable:
        line 28: 0
        line 29: 4
        line 30: 15
}
SourceFile: "ByteCode.java"
```

## 字节码修改

> 字节码增强，是AOP在字节码修改方面的使用，对程序的侵入更小。
>
> 目前有ASM「例：cglib在用」，javaassist「例：dubbo的SPI在用」,ByteBuddy「例：skywalking在用」。
>
> 下面我们一个一个来看。

### ASM

> [ASM4.0官方文档](https://asm.ow2.io/asm4-guide.pdf)
>
> [小博哥的ASM专栏](https://mp.weixin.qq.com/s/hjtBBczJMvt4SDtZvO25rg)
>
> ASM是通过编程方式，生成或修改.class文件，比如常量池数据，字段，方法「方法栈深度，方法执行行号，数据读取、入栈、出栈、方法调用等等」等等。怎么说呢，有些晦涩难懂「或者需要的成本比较高」。我已经放弃了细节得去扣具体怎么实现「业务」。
>
> 且官方提供了插件「ASM Bytecode Outline」.
>
> <img src="https://wangigor-typora-images.oss-cn-chengdu.aliyuncs.com/image-20210729144122929.png" alt="image-20210729144122929" style="zoom:50%;" />

比如你写好了代码，右键「Show Bytecode outline」

<img src="https://wangigor-typora-images.oss-cn-chengdu.aliyuncs.com/image-20210729144354937.png" alt="image-20210729144354937" style="zoom: 50%;" />



<img src="https://wangigor-typora-images.oss-cn-chengdu.aliyuncs.com/image-20210729144557400.png" alt="image-20210729144557400" style="zoom:67%;" />

> ASM采用的是访问者模式，所以我们能看到很多的visit/visitor.

#### 生成字节码执行

> classloader没有暴露出来通过byte[]生成class的方法。
>
> 需要重新封装一个classloader。请看下面代码。

```java
package cn.igor.apm.demo.asm;

import jdk.internal.org.objectweb.asm.*;

import java.lang.reflect.Method;

import static jdk.internal.org.objectweb.asm.Opcodes.*;

/**
 * 新建一个helloworld的ASM测试类
 */
public class HelloWorldASM {

    /**
     * 拷贝来插件生成的「dump」方法
     * 用于生成HelloWorld.class
     * @return
     * @throws Exception
     */
    public static byte[] dump() throws Exception {

        ClassWriter cw = new ClassWriter(0);
        FieldVisitor fv;
        MethodVisitor mv;
        AnnotationVisitor av0;

        cw.visit(52, ACC_PUBLIC + ACC_SUPER, "cn/igor/apm/demo/asm/HelloWorld", null, "java/lang/Object", null);

        cw.visitSource("HelloWorld.java", null);

        {
            fv = cw.visitField(ACC_PUBLIC + ACC_FINAL + ACC_STATIC, "name", "Ljava/lang/String;", null, "world");
            fv.visitEnd();
        }
        {
            mv = cw.visitMethod(ACC_PUBLIC, "<init>", "()V", null, null);
            mv.visitCode();
            Label l0 = new Label();
            mv.visitLabel(l0);
            mv.visitLineNumber(3, l0);
            mv.visitVarInsn(ALOAD, 0);
            mv.visitMethodInsn(INVOKESPECIAL, "java/lang/Object", "<init>", "()V", false);
            mv.visitInsn(RETURN);
            Label l1 = new Label();
            mv.visitLabel(l1);
            mv.visitLocalVariable("this", "Lcn/igor/apm/demo/asm/HelloWorld;", null, l0, l1, 0);
            mv.visitMaxs(1, 1);
            mv.visitEnd();
        }
        {
            mv = cw.visitMethod(ACC_PUBLIC + ACC_STATIC, "main", "([Ljava/lang/String;)V", null, null);
            mv.visitCode();
            Label l0 = new Label();
            mv.visitLabel(l0);
            mv.visitLineNumber(8, l0);
            mv.visitFieldInsn(GETSTATIC, "java/lang/System", "out", "Ljava/io/PrintStream;");
            mv.visitLdcInsn("helloworld");
            mv.visitMethodInsn(INVOKEVIRTUAL, "java/io/PrintStream", "println", "(Ljava/lang/String;)V", false);
            Label l1 = new Label();
            mv.visitLabel(l1);
            mv.visitLineNumber(9, l1);
            mv.visitInsn(RETURN);
            Label l2 = new Label();
            mv.visitLabel(l2);
            mv.visitLocalVariable("args", "[Ljava/lang/String;", null, l0, l2, 0);
            mv.visitMaxs(2, 1);
            mv.visitEnd();
        }
        cw.visitEnd();

        return cw.toByteArray();
    }

    public static void main(String[] args) throws Exception {
        byte[] dump = dump();

        ASMClassLoader asmClassLoader = new ASMClassLoader();
        Class helloworldClass = asmClassLoader.defineClass("cn.igor.apm.demo.asm.HelloWorld", dump);

        //main方法执行
        Method main = helloworldClass.getMethod("main", String[].class);
        main.invoke(null, new Object[]{new String[]{}});

    }


}

/**
 * 自定义classloader
 * 暴露出父接口的通过byte[]生成class的protected方法
 */
class ASMClassLoader extends ClassLoader {
    public Class defineClass(String name, byte[] bytes) {
        return super.defineClass(name, bytes, 0, bytes.length);
    }
}
```

#### 修改字节码执行

> 读取要修改的类，添加修改的vistor。
>
> 代码完全照抄小博哥的。

```java
package cn.igor.apm.demo.asm;

import jdk.internal.org.objectweb.asm.*;
import jdk.internal.org.objectweb.asm.commons.AdviceAdapter;

import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

import static jdk.internal.org.objectweb.asm.Opcodes.ASM5;

public class TestMonitor extends ClassLoader {

    public static void main(String[] args) throws IOException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException, InvocationTargetException {

        ClassReader cr = new ClassReader(MyMethod.class.getName());
        ClassWriter cw = new ClassWriter(cr, ClassWriter.COMPUTE_MAXS);

        {
            MethodVisitor methodVisitor = cw.visitMethod(Opcodes.ACC_PUBLIC, "<init>", "()V", null, null);
            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);
            methodVisitor.visitMethodInsn(Opcodes.INVOKESPECIAL, "java/lang/Object", "<init>", "()V", false);
            methodVisitor.visitInsn(Opcodes.RETURN);
            methodVisitor.visitMaxs(1, 1);
            methodVisitor.visitEnd();
        }

        ClassVisitor cv = new ProfilingClassAdapter(cw, MyMethod.class.getSimpleName());
        cr.accept(cv, ClassReader.EXPAND_FRAMES);

        byte[] bytes = cw.toByteArray();

        Class<?> clazz = new TestMonitor().defineClass("cn.igor.apm.demo.asm.MyMethod", bytes, 0, bytes.length);
        Method queryUserInfo = clazz.getMethod("queryUserInfo", String.class);
        Object obj = queryUserInfo.invoke(clazz.newInstance(), "10001");
        System.out.println("测试结果：" + obj);

    }

    static class ProfilingClassAdapter extends ClassVisitor {

        public ProfilingClassAdapter(final ClassVisitor cv, String innerClassName) {
            super(ASM5, cv);
        }

        public MethodVisitor visitMethod(int access,
                                         String name,
                                         String desc,
                                         String signature,
                                         String[] exceptions) {
            System.out.println("access：" + access);
            System.out.println("name：" + name);
            System.out.println("desc：" + desc);

            if (!"queryUserInfo".equals(name)) return null;

            MethodVisitor mv = cv.visitMethod(access, name, desc, signature, exceptions);

            return new ProfilingMethodVisitor(mv, access, name, desc);
        }

    }

    static class ProfilingMethodVisitor extends AdviceAdapter {

        private String methodName = "";

        protected ProfilingMethodVisitor(MethodVisitor methodVisitor, int access, String name, String descriptor) {
            super(ASM5, methodVisitor, access, name, descriptor);
            this.methodName = name;
        }

        @Override
        protected void onMethodEnter() {
            mv.visitMethodInsn(INVOKESTATIC, "java/lang/System", "nanoTime", "()J", false);
            mv.visitVarInsn(LSTORE, 2);
            mv.visitVarInsn(ALOAD, 1);

            //方法入参
            mv.visitFieldInsn(GETSTATIC, "java/lang/System", "out", "Ljava/io/PrintStream;");
            mv.visitVarInsn(ALOAD, 1);
            mv.visitMethodInsn(INVOKEVIRTUAL, "java/io/PrintStream", "println", "(Ljava/lang/String;)V", false);
        }

        @Override
        protected void onMethodExit(int opcode) {
            if ((IRETURN <= opcode && opcode <= RETURN) || opcode == ATHROW) {
                mv.visitFieldInsn(GETSTATIC, "java/lang/System", "out", "Ljava/io/PrintStream;");

                mv.visitTypeInsn(NEW, "java/lang/StringBuilder");
                mv.visitInsn(DUP);
                mv.visitMethodInsn(INVOKESPECIAL, "java/lang/StringBuilder", "<init>", "()V", false);
                mv.visitLdcInsn("方法执行耗时(纳秒)->" + methodName + "：");
                mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/StringBuilder", "append", "(Ljava/lang/String;)Ljava/lang/StringBuilder;", false);

                mv.visitMethodInsn(INVOKESTATIC, "java/lang/System", "nanoTime", "()J", false);
                mv.visitVarInsn(LLOAD, 2);
                mv.visitInsn(LSUB);

                mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/StringBuilder", "append", "(J)Ljava/lang/StringBuilder;", false);
                mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/StringBuilder", "toString", "()Ljava/lang/String;", false);
                mv.visitMethodInsn(INVOKEVIRTUAL, "java/io/PrintStream", "println", "(Ljava/lang/String;)V", false);

            }
        }
    }

}
```

执行结果

```log
access：1
name：<init>
desc：()V
access：1
name：queryUserInfo
desc：(Ljava/lang/String;)Ljava/lang/String;
10001
xxxx
xxxx
xxxx
xxxx
方法执行耗时(纳秒)->queryUserInfo：273536
测试结果：10001
```

### javaassist

> 如果把ASM理解为操作的是class，那么可以把javaassist理解为操作java文件。
>
> dubbo选择javassist也是因为这个，可以直接写java代码，而不是操作字节码。
>
> 虽然javaassist比ASM慢，但是也是同一个数量级下的慢，可以被接受。
>
> [javassist官网](http://www.javassist.org)
>
> [梁飞-动态代理方案性能对比](https://www.iteye.com/blog/javatar-814426)

添加maven依赖

```xml
        <!-- https://mvnrepository.com/artifact/org.javassist/javassist -->
        <dependency>
            <groupId>org.javassist</groupId>
            <artifactId>javassist</artifactId>
            <version>3.28.0-GA</version>
        </dependency>
```

#### 创建

```java
//先创建一个接口，方便调用
public interface Hello {
    public void hello();
}
```

```java
public class Demo {

    public static void main(String[] args) throws Exception {
      	//创建类并加载得到class
        CtClass helloCtClass = createClass();
        Class<?> helloClass = helloCtClass.toClass();
      
      	//无参构造器实例化
        Hello hello = (Hello) helloClass.newInstance();
        hello.hello();

				//有参构造器实例化
        Constructor constructor = helloClass.getConstructor(String.class);
        Hello hello1= (Hello) constructor.newInstance("小明");
        hello1.hello();
    }




    private static CtClass createClass() throws CannotCompileException, NotFoundException, IOException {
        ClassPool classPool = ClassPool.getDefault();
        CtClass ctClass = classPool.makeClass("cn.igor.apm.demo.javassist.HelloImpl");

        CtClass stringTye = classPool.get("java.lang.String");

      	//添加接口
        ctClass.setInterfaces(new CtClass[]{classPool.get("cn.igor.apm.demo.javassist.Hello")});

        //public static final String salutatory="hello"
        CtField salutatoryField = new CtField(stringTye, "salutatory", ctClass);
        salutatoryField.setModifiers(Modifier.PUBLIC + Modifier.FINAL + Modifier.STATIC);
        ctClass.addField(salutatoryField, CtField.Initializer.constant("hello"));

        //private final String name
        CtField nameField = new CtField(stringTye, "name", ctClass);
        nameField.setModifiers(Modifier.PRIVATE + Modifier.FINAL);
        ctClass.addField(nameField);

        //无参构造器
        CtConstructor noArgConstructor = new CtConstructor(new CtClass[]{}, ctClass);
        noArgConstructor.setBody("{$0.name=\"igor\";}");
        ctClass.addConstructor(noArgConstructor);

        //单参构造器
        CtConstructor allArgConstructor = new CtConstructor(new CtClass[]{stringTye}, ctClass);
        allArgConstructor.setBody("{$0.name=$1;}");
        ctClass.addConstructor(allArgConstructor);

        //name的get/set方法
        ctClass.addMethod(CtNewMethod.getter("getName", nameField));
        ctClass.addMethod(CtNewMethod.setter("setName", nameField));

        //实现hello方法
        CtMethod helloMethod = new CtMethod(CtClass.voidType, "hello", new CtClass[]{}, ctClass);
        helloMethod.setModifiers(Modifier.PUBLIC);
        helloMethod.setBody("{System.out.println(salutatory+\" \"+getName());}");
        ctClass.addMethod(helloMethod);
        
        return ctClass;
    }
}
```

#### 前置修改

> 修改类有一个前提：那就是这个类没有被类加载器加载过「会报ClassCastException：类重复」。

先写一个待修改的类。

```java
//接口
public interface IUserService {
    public String queryUserInfo(String id);
}
```

```java
//实现类
public class UserService implements IUserService {

    public String queryUserInfo(String id) {
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return "null";
    }
}
```

进行简单的修改。

```java
public class UpdateDemo {
    public static void main(String[] args) throws Exception {
        ClassPool classPool = ClassPool.getDefault();
        CtClass ctClass = classPool.get("cn.igor.apm.demo.javassist.UserService");
        CtMethod method = ctClass.getDeclaredMethod("queryUserInfo", new CtClass[]{classPool.get("java.lang.String")});
      
      	//打印入参
        method.insertBefore("System.out.println(\"queryUserInfo方法入参\"+$1);");
      	//设置方法本地变量
        method.addLocalVariable("start", CtClass.longType);
      	//添加方法计时
        method.insertBefore("start = System.currentTimeMillis();");
        method.insertAfter("System.out.println(\"方法执行时间\"+(System.currentTimeMillis()-start)+\"ms\");");

      	//加载并执行
        IUserService userService = (IUserService) ctClass.toClass().newInstance();
        System.out.println(
                userService.queryUserInfo("1")
        );
    }
}
```

> 当然。javassist也提供了对于字节码的操作。emmmmmmmm暂时对我没有必要。

#### 运行期修改

> 运行期修改需要用到**javassist.tools.HotSwapper**和java提供的调试工具JPDA「需要引入```$JAVA_HOME$/lib/tools.jar```」。
>
> java5以后```command line options```选项增加 ```-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=8000```
>
> - jdwp调试线协议采用socket。
> - server : y「yes」 作为服务端等待调试器连接。
> - suspend：n「no」不是在vm启动之后就暂停等待连接。
> - 开放端口8000：这也就是HotSwapper需要连接的端口。
> - 如果是本地的话，会影响debug「使用run」。

先写一个简单的查询方法

```java
//一直返回1
public class QueryService {
    public int query() {
        return 1;
    }
}
```

```java
public class HotSwapperDemo {

    public static void main(String[] args) throws Exception {

        QueryService queryService = new QueryService();

        System.out.println("修改前返回：" + queryService.query());

        // VM options : -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=8000
        HotSwapper hotSwapper = new HotSwapper(8000);

        ClassPool pool = ClassPool.getDefault();
        CtClass ctClass = pool.get(QueryService.class.getName());

        //改为返回2
        CtMethod queryMethod = ctClass.getDeclaredMethod("query");
        queryMethod.setBody("{return 2;}");

        hotSwapper.reload(QueryService.class.getName(), ctClass.toBytecode());
        System.out.println("修改完成。");
        System.out.println("修改后返回：" + queryService.query());
    }
}
```

```log
Listening for transport dt_socket at address: 8000
修改前返回：1
修改完成。
修改后返回：2
```

### ByteBuddy

> 他是基于ASM的封装，更加方便。
>
> [github](https://github.com/raphw/byte-buddy)
>
> [stackoverflow问题集](https://stackoverflow.com/questions/tagged/byte-buddy)

添加依赖

```xml
<!-- https://mvnrepository.com/artifact/net.bytebuddy/byte-buddy -->
<dependency>
    <groupId>net.bytebuddy</groupId>
    <artifactId>byte-buddy</artifactId>
    <version>1.11.9</version>
</dependency>
```

#### HelloWorld

下面是参照官网的HelloWorld

```java
public class HelloDemo {

    @org.junit.Test
		public void test(){

        //创建一个随机类
        DynamicType.Unloaded<Object> dynamicType = new ByteBuddy()
                .subclass(Object.class)
                .method(named("toString"))
                .intercept(FixedValue.value("hello world."))
                .make();

        //字节码class输出成文件
        dynamicType.saveIn(new File("/Users/XXX/IdeaProjects/git/apm-demo/src/main/java/cn/igor/apm/demo/byteBuddy"));

        //加载、实例化、执行toString()
        String toString = dynamicType.load(HelloDemo.class.getClassLoader())
                .getLoaded()
                .newInstance()
                .toString();

        System.out.println(toString);
    }
}
```

生成的随机类

```java
//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by FernFlower decompiler)
//

package net.bytebuddy.renamed.java.lang;

public class Object$ByteBuddy$7WfYAwY8 {
    public String toString() {
        return "hello world.";
    }

    public Object$ByteBuddy$7WfYAwY8() {
    }
}
```

#### 类

> 之前的类名是随机的『前缀为net.bytebuddy.renamed』，也可以手动指定类名```DynamicType.name()```.

创建一个指定类名的新类

```java
		@org.junit.Test
		public void test(){
        new ByteBuddy()
          			//设置为顶级父类
                .subclass(Object.class)
          			//全类名
                .name("Test")
          			//生成字节码
                .make();
    }
```

生成的样子

```java
public class Test {
    public Test() {
    }
}
```

> 类名也可以通过提供的命名策略或者自定义命名策略产生。
>
> 提供的是```NamingStrategy.SuffixingRandom```和```NamingStrategy.PrefixingRandom```

自定义的是实现NamingStrategy.AbstractBase抽象类

```java
@org.junit.Test
public void test(){

      	//父类$0 父类$1
        NamingStrategy.AbstractBase customNamingStrategy = new NamingStrategy.AbstractBase() {
            private int i;

            @Override
            protected String name(TypeDescription superClass) {

                return superClass.getName() + "$" + i++;
            }
        };

        new ByteBuddy()
                .with(customNamingStrategy)
                .subclass(Object.class)
                .make()
                .saveIn(new File("/Users/wangke/IdeaProjects/git/apm-demo/src/main/java/cn/igor/apm/demo/byteBuddy"));
        new ByteBuddy()
                .with(customNamingStrategy)
                .subclass(Object.class)
                .make()
                .saveIn(new File("/Users/wangke/IdeaProjects/git/apm-demo/src/main/java/cn/igor/apm/demo/byteBuddy"));
    }
```

上面这种```subclass```的方式是**继承**。还有一些类似模板的生成子类的方式

比如一个父类Parent

```java
public class Parent {
    private String name = "parent";

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
```

- 使用subclass结果是

  ```java
  import cn.igor.apm.demo.byteBuddy.Parent;
  
  public class Child extends Parent {
      public Child() {
      }
  }
  ```

- 使用rebase或者redefine，是以Parent为模板，全复制的进行改造。

  ```java
  public class Child {
      private String name = "parent";
  
      public Child() {
      }
  
      public String getName() {
          return this.name;
      }
  
      public void setName(String name) {
          this.name = name;
      }
  }
  ```

稍有不同的是redefine是完全覆盖。

> 比如方法修改，那```从父类中拷贝过来的方法签名相同的方法```会被完全覆盖。

rebase则不同，他会把```从父类中拷贝过来的方法签名相同的方法```重命名一个```$original```为后缀的方法，依旧可以调用。

##### 类加载

> 生成的类make执行之后，是一个DynamicType.Unloaded未加载类型。
>
> 类加载器策略也有各种不同。

- 「默认」 ClassLoadingStrategy.Default.**WRAPPER**

> 通过默认的```dynamicType.load(classLoader)```。是默认调用了```dynamicType.load(classLoader, ClassLoadingStrategy.Default.WRAPPER)```

以传入的classLoader为父加载器，生成一个新加载器。

确保被加载类能看到所有父加载器的类。但是如果父加载器中有重名类，那就不会被加载。

- ClassLoadingStrategy.Default.**CHILD_FIRST**

WRAPPER的修改版，是有子构造器优先加载「破坏双亲委派」。

- ClassLoadingStrategy.Default.**INJECTION**「适合java9之前的版本。」

通过反射由传入的类加载器加载「不创建新的类加载器」。

***

> 以上是加载「未被加载过的类」的情况。
>
> 但是如果要对原有类进行修改，需要引入```ByteBuddyAgent```

```xml
<!-- https://mvnrepository.com/artifact/net.bytebuddy/byte-buddy-agent -->
<dependency>
    <groupId>net.bytebuddy</groupId>
    <artifactId>byte-buddy-agent</artifactId>
    <version>1.11.9</version>
</dependency>
```

```java
@org.junit.Test
public void test(){

    ByteBuddyAgent.install();
  	//生成一个以Parent为模板的类
    Class<? extends Parent> loaded = new ByteBuddy()
            .rebase(Parent.class)
      			//跟Parent使用同样的类名
            .name(Parent.class.getName())
            .make()
      			//重新加载
            .load(Parent.class.getClassLoader(), ClassReloadingStrategy.fromInstalledAgent())
            .getLoaded();
    assert loaded == Parent.class;

}
```

#### 方法

- ```defineMethod```定义一个方法

以创建接口为例

```java
@org.junit.Test
public void test() {
    new ByteBuddy()
      			//创建接口
            .makeInterface()
            .name("cn.igor.amp.demo.byteBuddy.IService")
						
      			//定义一个 public void(String var1);抽象方法
            .defineMethod("test0", Void.class, Modifier.PUBLIC)
            .withParameters(String.class)
            .withoutCode()

      			//指定入参详细
            .defineMethod("test1", Void.class, Modifier.PUBLIC)
            .withParameter(String.class, "arg1")
            .withParameter(String.class, "arg2")
            .withoutCode()

            .make().saveIn(new File("/Users/wangke/IdeaProjects/git/apm-demo/src/main/java/cn/igor/apm/demo/byteBuddy"));
}
```

- ```method```匹配一个方法

```java
@Test
public void methodMatch() throws IOException {
    new ByteBuddy()
            .subclass(Object.class)
            .name("MethodMatch")
            //名称
            .method(ElementMatchers.named("toString"))
            .intercept(FixedValue.value("toString method has changed."))
            .make()
            .saveIn(new File("/Users/wangke/IdeaProjects/git/apm-demo/src/main/java/cn/igor/apm/demo/byteBuddy"));
}
```

还有很多组合形式

比如```named("toString").and(isPublic()).and(returns(String.class)).and(takesArguments(0))```表示「名称为toString」「允许public访问」「返回String类型」「无参数」的方式

> 可以从[ElementMatchers的api文档](https://javadoc.io/static/net.bytebuddy/byte-buddy/1.11.12/net/bytebuddy/matcher/ElementMatchers.html)查找。

- ```intercept```方法委托

在helloword里使用了```FixedValue.value("hello world.")```，也就是将被拦截方法重写为直接返回字符串的方法。

但是这并不够，下面介绍的是将被拦截方法重写为指定类指定方法执行，这就是**方法委托「MethodDelegation」**。

比如，先写好一个简单类

```java
public class ToStringInterceptor {
    public String redirectForToString(){
        return "redirect toString";
    }
}
```

再把新类的toString方法拦截到委托中执行

```java
@Test
public void simpleIntercept() throws InstantiationException, IllegalAccessException {

    Object o = new ByteBuddy()
            .subclass(Object.class)
            .method(named("toString"))
            .intercept(MethodDelegation.to(ToStringInterceptor.class))
            .make()
            .load(getClass().getClassLoader())
            .getLoaded()
            .newInstance();

    assertEquals("redirect toString", o.toString());
}
```

这是委托到一个类的静态方法上。但是如果类有多个不同的方法，就会出现```ambiguous delegation```委托模糊的问题。

参见[stackoverflow](https://stackoverflow.com/questions/62103929/ambiguity-in-method-resolution-and-how-to-solve-it)：不使用```MethodDelegation```，而使用```MethodCall```。

```java
@Test
public void simpleIntercept() throws InstantiationException, IllegalAccessException, NoSuchMethodException {


    Object o = new ByteBuddy()
            .subclass(Object.class)
            .method(named("toString"))
      			//指定方法
            .intercept(MethodCall.call(ToStringInterceptor::redirectForToString1))
            .make()
            .load(getClass().getClassLoader())
            .getLoaded()
            .newInstance();

    assertEquals("redirect toString1", o.toString());
}
```

- 参数绑定

上面是最简单的方法拦截。还可以给拦截方法增加其他入参。

| 注解          | 说明                                                         |
| :------------ | :----------------------------------------------------------- |
| @Argument     | 绑定单个参数                                                 |
| @AllArguments | 绑定所有参数的数组                                           |
| @This         | 当前被拦截的、动态生成的那个对象                             |
| @Super        | 当前被拦截的、动态生成的那个对象的父类对象                   |
| @Origin       | 可以绑定到以下类型的参数：Method 被调用的原始方法 Constructor 被调用的原始构造器 Class 当前动态创建的类 MethodHandle MethodType String  动态类的toString()的返回值 int  动态方法的修饰符 |
| @DefaultCall  | 调用默认方法而非super的方法                                  |
| @SuperCall    | 用于调用父类版本的方法                                       |
| @Super        | 注入父类型对象，可以是接口，从而调用它的任何方法             |
| @RuntimeType  | 可以用在返回值、参数上，提示ByteBuddy禁用严格的类型检查      |
| @Empty        | 注入参数的类型的默认值                                       |
| @StubValue    | 注入一个存根值。对于返回引用、void的方法，注入null；对于返回原始类型的方法，注入0 |
| @FieldValue   | 注入被拦截对象的一个字段的值                                 |
| @Morph        | 类似于@SuperCall，但是允许指定调用参数                       |

假设我们需要调用日志存储：记录「简单console输出」调用方法、入参、返回。

> 以之前的UserService为例。增加一个方法。
>
> ```java
> public class UserService implements IUserService {
> 
>     public String queryUserInfo(String id) {
>         try {
>             TimeUnit.SECONDS.sleep(1);
>         } catch (InterruptedException e) {
>             e.printStackTrace();
>         }
>         return "test user";
>     }
> 
>     public String load(String id) {
>         try {
>             TimeUnit.SECONDS.sleep(2);
>         } catch (InterruptedException e) {
>             e.printStackTrace();
>         }
>         return "user load.";
>     }
> }
> ```

增加日志监控拦截器。

```java
public class LogMonitorIntercept {

  	//ByteBuddy不进行类型检查
  	//方法签名不一样是需要添加，否则报错「None of [interceptor methods]  allows for delegation from [target method]」
    @RuntimeType
    public static Object logIntercept(@SuperCall Callable callable, @AllArguments Object[] args, @Origin Method method) throws Exception {
        long startNanoTime = System.nanoTime();
        long endNanoTime = 0l;
        Object result = null;
        try {
          	//原方法调用
            result = callable.call();
            endNanoTime = System.nanoTime();
            return result;
        } catch (Exception e) {
            throw e;
        } finally {
            System.out.println("调用方法：" + method.getDeclaringClass() + "." + method.getName());
            System.out.println("============入参===========");
            for (Object arg : args) {
                System.out.println(arg.getClass() + ":" + arg);
            }
            System.out.println("方法调用时间：" + (endNanoTime - startNanoTime) / 1000 / 1000 + "/ms");
            System.out.println("返回：" + method.getReturnType() + ":" + result);
        }
    }
}
```

测试方法

```java
@Test
public void logIntercept() throws InstantiationException, IllegalAccessException {
    UserService userService = new ByteBuddy()
            .subclass(UserService.class)
            .method(ElementMatchers.any())
            .intercept(MethodDelegation.to(LogMonitorIntercept.class))
            .make()
            .load(getClass().getClassLoader())
            .getLoaded()
            .newInstance();

    userService.queryUserInfo("1");
    userService.load("2");
}
```

测试结果

```log
调用方法：class cn.igor.apm.demo.javassist.UserService.queryUserInfo
============入参===========
class java.lang.String:1
方法调用时间：1004/ms
返回：class java.lang.String:test user

调用方法：class cn.igor.apm.demo.javassist.UserService.load
============入参===========
class java.lang.String:2
方法调用时间：2000/ms
返回：class java.lang.String:user load.
```

#### 字段

> 这种定义字段的方式，只能对静态public的字段赋默认值。
>
> 当然，也可以通过方法拦截的方式进行类似相同的操作。
>
> 这里就不展开了。

```java
@Test
public void addField() throws IOException {
    new ByteBuddy()
            .subclass(Parent.class)
            .defineField("firstName", String.class, Modifier.PUBLIC + Modifier.STATIC + Modifier.FINAL)
            .value("John")
            .make()
            .saveIn(new File("/Users/wangke/IdeaProjects/git/apm-demo/src/main/java/cn/igor/apm/demo/byteBuddy"));
}
```

## Java Agent

> 上面介绍了对字节码修改的三种技术，那么这样的技术用在哪里呢？javaagent boom！
>
> 参考：[java安全之javaagent](https://www.cnblogs.com/nice0e3/p/14086165.html)   [javaagent技术原理及简单实现](https://www.jianshu.com/p/d573456401eb)   [javaagent基础原理](https://blog.csdn.net/ancinsdn/article/details/58276945)   [javaagent极简教程](https://www.jianshu.com/p/f9f2e81b4235)

从JDK1.5开始，增加了```Instrumentation(Java Agent Api)```和```JVMTI(JVM Tool Interface)```功能。实现了**字节码修改**和**类重新加载**、**运行期数据收集**的功能。

从JDK1.6开始，增加了attach方式，可以**对运行期的java进行添加agent**。

### agent hello world

插件项目目录结构

```tree
project module「javaagent-demo」
    |- src
        |- main
            |- java
                |- Agent.java
            |- resources
                |- MANIFEST.MF
        |- test
            |- java
                |- MainTest.java
                |- AttachTest.java
    |- pom.xml
    |- target
```

Agent.java类就提供两个方法

- premain方法
- agentmain方法

他们都是通过反射调用的方式，优先找方法签名是```public static void XXX(String agentArgs, Instrumentation inst)```的方法，没有再去找```public static void premain(String agentArgs)```的方法。「如果两个都没有就会报错```Agent JAR loaded but agent failed to initialize```」

```java
public class Agent {

    //premain优先搜索方法
    public static void premain(String agentArgs, Instrumentation inst) {
        System.out.println("hello pre " + agentArgs);
    }

    //premain重载方法
    public static void premain(String agentArgs) {
        System.out.println("hello pre 「default」" + agentArgs);
    }

    //attach 优先搜索方法
    public static void agentmain(String agentArgs, Instrumentation inst) {
        System.out.println("hello attach " + agentArgs);
    }

    //attach重载方法
    public static void agentmain(String agentArgs) {
        System.out.println("hello attach 「default」 " + agentArgs);
    }

}
```

MainTest.java是premain的测试和agent要attach的jvm进程。

```java
public class MainTest {
    public static void main(String[] args) throws InterruptedException {
				
      	//当前进程的pid
        String name = ManagementFactory.getRuntimeMXBean().getName();
        String pid = name.split("@")[0];
        System.out.println("pid:" + pid);
      	//一秒一个helloworld
        while (true) {
            TimeUnit.SECONDS.sleep(1);
            System.out.println("hello world.");
        }

    }
}
```

AttachTest.java是要在MainTest的运行期attach进来，执行agentmain方法的一个启动类。

```java
public class AttachTest {

    public static void main(String[] args) throws IOException, AttachNotSupportedException, InterruptedException, AgentLoadException, AgentInitializationException {
        //MainTest的pid
      	VirtualMachine virtualMachine = VirtualMachine.attach("62934");

        while (true) {
          	//加载agent.jar，传参「attach agent.」
            virtualMachine.loadAgent("/Users/wangke/IdeaProjects/git/javaagent-demo/target/javaagent-demo-1.0-SNAPSHOT.jar","attach agent.");
            TimeUnit.SECONDS.sleep(3);
        }
    }
}
```

Javaagent-demo是整个『插件』的项目目录。

他还需要一个MANIFEST.MF「src/main/resources」来指定程序入口。结构如下：

```yaml
Manifest-Version: 1.0
Premain-Class: cn.igor.javaagent.demo.Agent
Archiver-Version: Plexus Archiver
Built-By: wangigor
Agent-Class: cn.igor.javaagent.demo.Agent
Can-Redefine-Classes: true
Created-By: Apache Maven 3.6.3
Build-Jdk: 1.8.0_231
```

这不需要手动生成，只要在maven打包之后生成在jar包里就行。所以这个文件不需要写在上述未知，只修改pom.xml

```xml
<properties>
    <maven.compiler.source>8</maven.compiler.source>
    <maven.compiler.target>8</maven.compiler.target>
    <!-- Build args -->
    <argline>-Xms512m -Xmx512m</argline>
    <skip_maven_deploy>false</skip_maven_deploy>
    <updateReleaseInfo>true</updateReleaseInfo>
    <project.build.sourceEncoding>utf-8</project.build.sourceEncoding>
    <maven.test.skip>true</maven.test.skip>
</properties>

<build>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-compiler-plugin</artifactId>
            <configuration>
                <source>1.8</source>
                <target>1.8</target>
                <encoding>utf-8</encoding>
            </configuration>
        </plugin>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-shade-plugin</artifactId>
            <version>3.0.0</version>
            <executions>
                <execution>
                    <phase>package</phase>
                    <goals>
                        <goal>shade</goal>
                    </goals>
                    <configuration>
                        <transformers>
                            <transformer
                                    implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer">
                                <manifestEntries>
                                    <Premain-Class>cn.igor.javaagent.demo.Agent</Premain-Class>
                                    <Agent-Class>cn.igor.javaagent.demo.Agent</Agent-Class>
                                    <Can-Redefine-Classes>true</Can-Redefine-Classes>
                                    <Can-Retransform-Classes>true</Can-Retransform-Classes>
                                </manifestEntries>
                            </transformer>
                        </transformers>
                    </configuration>
                </execution>
            </executions>
        </plugin>
    </plugins>
</build>
```

打包```mvn clean package```。

增加MainTest的启动参数```-javaagent:/Users/wangke/IdeaProjects/git/javaagent-demo/target/javaagent-demo-1.0-SNAPSHOT.jar=argTest```。启动。

<img src="https://wangigor-typora-images.oss-cn-chengdu.aliyuncs.com/image-20210810094050984.png" alt="image-20210810094050984" style="zoom: 67%;" />

- premain方法执行。
- argTest参数正常输出。
- pid是63853。
- 一秒一个helloword

修改AttachTest的pid，启动。观察MainTest的console。

<img src="https://wangigor-typora-images.oss-cn-chengdu.aliyuncs.com/image-20210810094436525.png" alt="image-20210810094436525" style="zoom:67%;" />

- 每3秒执行了一次agentmain方法。
- 入参「attach agent」输出正常。

***

> 先来看Transformer和agent的加载流程。

**premain加载前修改**：

- 在jvm启动时，执行native的方法```Agent_OnLoad```
  - 创建```InstrumentationImpl```实例
  - 监听```ClassFileLoadedHook```事件
  - 调用```InstrumentationImpl.loadClassAndCallPremain```方法「通过反射在```MANIFEST.MF```指定的```premain-class```中查找」
  - 添加```Transformer```。

- 在类请求加载时，有对应类加载器读取class文件
  - 触发```ClassFileLoadedHook```事件
  - 尝试通过```TransFromClassFile```调用```Transformer```进行字节码修改
  - 如果有修改，加载修改之后的。如果没有，加载原文件。

**agentmain运行时修改**：

- 通过jvm的attach机制，请求执行native的方法```Agent_OnAttach```
  - 创建```InstrumentationImpl```实例
  - 监听```ClassFileLoadedHook```事件
  - 调用```InstrumentationImpl.loadClassAndCallAgentmain```方法「通过反射在```MANIFEST.MF```指定的```agentmain-class```中查找」
  - 添加```Transformer```。
- 跟premain第二步一样。



### Instrumentation接口

> 此类提供检测 Java 编程语言代码所需的服务。检测是将字节码添加到方法中，以收集工具使用的数据。由于更改纯粹是附加的，因此这些工具不会修改应用程序状态或行为。此类良性工具的示例包括监控代理、分析器、覆盖分析器和事件记录器。

```java
public interface Instrumentation {
    //注册类加载的转换器，在未来类加载时对被加载类进行转换
  	//canRetransform 是否允许类重新加载时进行转换 默认false
    void addTransformer(ClassFileTransformer transformer, boolean canRetransform);

   	//注册转换器
    void addTransformer(ClassFileTransformer transformer);

    //移除转换器
    boolean removeTransformer(ClassFileTransformer transformer);

    //查看当前jvm是否支持类的重新转换
    boolean isRetransformClassesSupported();

    //重新转换类
    void retransformClasses(Class<?>... classes) throws UnmodifiableClassException;

  	//查看当前jvm是否支持类的重新定义
    boolean isRedefineClassesSupported();

    //重新定义类
    void redefineClasses(ClassDefinition... definitions) throws  ClassNotFoundException, UnmodifiableClassException;

		//确定这个类是否可以被重新转换和重新定义修改
    boolean isModifiableClass(Class<?> theClass);

    //查看所有已加载类
    Class[] getAllLoadedClasses();

    //查看某个类加载器已加载的类
    Class[] getInitiatedClasses(ClassLoader loader);

		//查看对象大小
    long getObjectSize(Object objectToSize);

		//把jar包添加到BootstrapClassLoader的搜索路径里
    void appendToBootstrapClassLoaderSearch(JarFile jarfile);

    //把jar包添加到SystemClassLoader的搜索路径里
    void appendToSystemClassLoaderSearch(JarFile jarfile);

    //查看当前JVM配置是否支持设置native方法前缀
    boolean isNativeMethodPrefixSupported();

    //native方法没有字节码，不支持检测。
  	//需要进行以prefix为前缀的方法包裹
  	// For example, if we had:
    //    native boolean foo(int x);
    // We could transform the class file (with the ClassFileTransformer during the initial definition of the class) so that this becomes:
    //    boolean foo(int x) {
    //      ... record entry to foo ...
    //      return wrapped_foo(x);
    //    }
    //    native boolean wrapped_foo(int x);
    void setNativeMethodPrefix(ClassFileTransformer transformer, String prefix);
}
```

### ClassFileTransformer接口

<img src="https://wangigor-typora-images.oss-cn-chengdu.aliyuncs.com/image-20210810142224671.png" alt="image-20210810142224671" style="zoom:67%;" />

ClassFileTransformer是类文件转换接口。可以通过以下两种方式添加：

- 带有```Instrumentation```参数的```premain```方法。通过```addTransformer```添加。
- 带有```Instrumentation```参数的```agentmain```方法。通过```addTransformer```添加。

当类请求加载，读取完成触发```ClassFileLoadedHook```事件后，调用```ClassFileTransFormer```接口。

他只定义了一个接口。

```java
public interface ClassFileTransformer {
    
    byte[]
    transform(  ClassLoader         loader, //要转换的classloader,如果是BootstrapClassLoader则为null
                String              className,//加载的类名「路径格式：java/lang/String」
                Class<?>            classBeingRedefined,//重新定义或者重新加载的类，定义类时是null
                ProtectionDomain    protectionDomain,//类的保护域
                byte[]              classfileBuffer)//class文件的字节缓冲区
        throws IllegalClassFormatException;
}
```

### Transformer hello world-javassist

重写一个新的入口类

```java
public class Agent1 {
    public static void premain(String arg, Instrumentation instrumentation) {
        instrumentation.addTransformer(new CustomTransformerAdapter());
    }

    public static void agentmain(String arg, Instrumentation instrumentation) {
        instrumentation.addTransformer(new CustomTransformerAdapter(),true);
        //retransform demoTest
        try {
            Class<?> aClass = Class.forName("cn.igor.javaagent.demo.DemoTest");
            instrumentation.retransformClasses(aClass);
            System.out.println("修改完成");
        } catch (ClassNotFoundException | UnmodifiableClassException e) {
            System.err.println("转换失败");
        }

    }
}
```

自定义一个简单的类转换适配器

```java
public class CustomTransformerAdapter implements ClassFileTransformer {
    @Override
    public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {

        System.out.println("transform class:" + className + "「" + loader.toString() + "」");

        //simple派发器
        if ("cn/igor/javaagent/demo/DemoTest".equals(className)) {
            return transformDemoTest();
        }

        return null;
    }

    public byte[] transformDemoTest() {
        //使用javassist修改，返回byte[]
        ClassPool pool = ClassPool.getDefault();
        try {
            CtClass ctClass = pool.get("cn.igor.javaagent.demo.DemoTest");
            CtMethod helloMethod = ctClass.getDeclaredMethod("hello");
          	//改成 hello agent
            helloMethod.setBody("{return \"hello agent\";}");
            return ctClass.toBytecode();
        } catch (NotFoundException | CannotCompileException | IOException e) {
            e.printStackTrace();
        }
        return null;
    }
}
```

测试app运行main方法

```java
public class DemoTest {

    public static String hello() {
        return "hello world";
    }

    public static void main(String[] args) throws InterruptedException {

        String name = ManagementFactory.getRuntimeMXBean().getName();
        String pid = name.split("@")[0];
        System.out.println("pid:" + pid);

        while (true) {
            TimeUnit.SECONDS.sleep(1);
            System.out.println(hello());
        }
    }
}
```

- 测试premain

打包。添加vm javaagent参数```-javaagent:/Users/wangke/IdeaProjects/git/javaagent-demo/target/javaagent-demo-1.0-SNAPSHOT.jar```

执行结果

```log
transform class:com/intellij/rt/execution/application/AppMainV2$Agent「sun.misc.Launcher$AppClassLoader@18b4aac2」
transform class:com/intellij/rt/execution/application/AppMainV2「sun.misc.Launcher$AppClassLoader@18b4aac2」
transform class:com/intellij/rt/execution/application/AppMainV2$1「sun.misc.Launcher$AppClassLoader@18b4aac2」
transform class:cn/igor/javaagent/demo/DemoTest「sun.misc.Launcher$AppClassLoader@18b4aac2」
pid:39377
hello agent
hello agent
hello agent
hello agent
hello agent
```

- 测试agentmain

去掉javaagent参数，重新启动。

再启动AttachTest类

```java
public class AttachTest {

    public static void main(String[] args) throws IOException, AttachNotSupportedException, InterruptedException, AgentLoadException, AgentInitializationException {
        VirtualMachine virtualMachine = VirtualMachine.attach("37750");

        virtualMachine.loadAgent("/Users/wangke/IdeaProjects/git/javaagent-demo/target/javaagent-demo-1.0-SNAPSHOT.jar", "attach agent.");
    }
}
```

执行结果

```log
pid:41005
hello world
hello world
hello world
hello world
hello world
hello world
hello world
hello world
hello world
hello world
transform class:cn/igor/javaagent/demo/DemoTest「sun.misc.Launcher$AppClassLoader@18b4aac2」
修改完成
hello agent
hello agent
hello agent
hello agent
hello agent
hello agent
```

### Transformer hello world-ByteBuddy

> 对所有方法执行，添加执行计时。

增加ByteBuddy依赖

```xml
        <!-- https://mvnrepository.com/artifact/net.bytebuddy/byte-buddy -->
        <dependency>
            <groupId>net.bytebuddy</groupId>
            <artifactId>byte-buddy</artifactId>
            <version>1.11.9</version>
        </dependency>
        <!-- https://mvnrepository.com/artifact/net.bytebuddy/byte-buddy -->
        <dependency>
            <groupId>net.bytebuddy</groupId>
            <artifactId>byte-buddy</artifactId>
            <version>1.11.9</version>
        </dependency>
```

创建premain的入口类

```java
public class ByteBuddyAgent {

    public static void premain(String arg, Instrumentation instrumentation) {
        AgentBuilder.Transformer transformer = new AgentBuilder.Transformer() {
            @Override
            public DynamicType.Builder<?> transform(DynamicType.Builder<?> builder, TypeDescription typeDescription, ClassLoader classLoader, JavaModule module) {
                return builder
                  			//所有方法
                        .method(ElementMatchers.any())
                  			//加载计时拦截器
                        .intercept(MethodDelegation.to(MonitorInterceptor.class));
            }
        };
      	//拦截cn.igor.javaagent包下的所有类
        new AgentBuilder.Default()
                .type(ElementMatchers.nameStartsWith("cn.igor.javaagent"))
                .transform(transformer)
                .installOn(instrumentation);
    }
}
```

修改pom文件里的```Can-Redefine-Classes```和```Can-Retransform-Classes```

还是使用之前DemoTest的测试方法，简单修改。

> ```-javaagent:/Users/wangke/IdeaProjects/git/javaagent-demo/target/javaagent-demo-1.0-SNAPSHOT.jar```

```java
public class DemoTest {

    public static String hello() throws InterruptedException {
        TimeUnit.SECONDS.sleep(1);
        return "hello world";
    }

    public static void main(String[] args) throws InterruptedException {

        String name = ManagementFactory.getRuntimeMXBean().getName();
        String pid = name.split("@")[0];
        System.out.println("pid:" + pid);

        while (true) {
            System.out.println(hello());
        }
    }
}
```

执行结果

```log
pid:71026
public static java.lang.String cn.igor.javaagent.demo.DemoTest.hello() throws java.lang.InterruptedException执行耗时:  1003ms
hello world
public static java.lang.String cn.igor.javaagent.demo.DemoTest.hello() throws java.lang.InterruptedException执行耗时:  1003ms
hello world
public static java.lang.String cn.igor.javaagent.demo.DemoTest.hello() throws java.lang.InterruptedException执行耗时:  1002ms
hello world
public static java.lang.String cn.igor.javaagent.demo.DemoTest.hello() throws java.lang.InterruptedException执行耗时:  1003ms
hello world
public static java.lang.String cn.igor.javaagent.demo.DemoTest.hello() throws java.lang.InterruptedException执行耗时:  1003ms
hello world
public static java.lang.String cn.igor.javaagent.demo.DemoTest.hello() throws java.lang.InterruptedException执行耗时:  1002ms
hello world
public static java.lang.String cn.igor.javaagent.demo.DemoTest.hello() throws java.lang.InterruptedException执行耗时:  1003ms
hello world
public static java.lang.String cn.igor.javaagent.demo.DemoTest.hello() throws java.lang.InterruptedException执行耗时:  1003ms
hello world
public static java.lang.String cn.igor.javaagent.demo.DemoTest.hello() throws java.lang.InterruptedException执行耗时:  1002ms
hello world
```

