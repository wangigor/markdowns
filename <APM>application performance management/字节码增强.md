# 字节码增强



## 字节码

> .java文件是程序员能「使用」的文件。.class文件是java虚拟机能「使用」的文件。
>
> .java文件经过编译「javac」之后，转换成.class文件。先来了解一下class文件结构。
>
> 当然，仅供了解。不深。

首先随便写两个java文件。

- 父类

```java
package cn.igor.apm.demo;

public class BaseCode {

    public static final String key="temp_key";

    private int pField;

    public int getpField() {
        return pField;
    }

    public void setpField(int pField) {
        this.pField = pField;
    }

}
```

- 子类

```java
package cn.igor.apm.demo;

public class ByteCode extends BaseCode {

    private String cField;

    public String getcField() {
        return cField;
    }

    public void setcField(String cField) {
        this.cField = cField;
    }

    @Override
    public int getpField() {
        return super.getpField();
    }

    //测试
    public static int test() {
        int a = 1;
        int b = 2;
        return a + b;
    }

    public static void main(String[] args) {
        test();
    }
}
```

通过```javac ByteCode.java BaseCode.java ```编译得到两个对应的class文件。

> 这是两个二进制文件，我们先使用二进制打开它看看他的结构。
>
> 可以使用sublime，也可以使用vi
>
> ```bash
> # -b 以二进制显示
> vi -b baseCode.class
> #全部替换为16进制显示
> :%!xxd 
> ```

```hexadecimal
# BaseCode.class
00000000: cafe babe 0000 0034 001a 0a00 0400 1509  .......4........
00000010: 0003 0016 0700 1707 0018 0100 036b 6579  .............key
00000020: 0100 124c 6a61 7661 2f6c 616e 672f 5374  ...Ljava/lang/St
00000030: 7269 6e67 3b01 000d 436f 6e73 7461 6e74  ring;...Constant
00000040: 5661 6c75 6508 0019 0100 0670 4669 656c  Value......pFiel
00000050: 6401 0001 4901 0006 3c69 6e69 743e 0100  d...I...<init>..
00000060: 0328 2956 0100 0443 6f64 6501 000f 4c69  .()V...Code...Li
00000070: 6e65 4e75 6d62 6572 5461 626c 6501 0009  neNumberTable...
00000080: 6765 7470 4669 656c 6401 0003 2829 4901  getpField...()I.
00000090: 0009 7365 7470 4669 656c 6401 0004 2849  ..setpField...(I
000000a0: 2956 0100 0a53 6f75 7263 6546 696c 6501  )V...SourceFile.
000000b0: 000d 4261 7365 436f 6465 2e6a 6176 610c  ..BaseCode.java.
000000c0: 000b 000c 0c00 0900 0a01 0019 636e 2f69  ............cn/i
000000d0: 676f 722f 6170 6d2f 6465 6d6f 2f42 6173  gor/apm/demo/Bas
000000e0: 6543 6f64 6501 0010 6a61 7661 2f6c 616e  eCode...java/lan
000000f0: 672f 4f62 6a65 6374 0100 0874 656d 705f  g/Object...temp_
00000100: 6b65 7900 2100 0300 0400 0000 0200 1900  key.!...........
00000110: 0500 0600 0100 0700 0000 0200 0800 0200  ................
00000120: 0900 0a00 0000 0300 0100 0b00 0c00 0100  ................
00000130: 0d00 0000 1d00 0100 0100 0000 052a b700  .............*..
00000140: 01b1 0000 0001 000e 0000 0006 0001 0000  ................
00000150: 0003 0001 000f 0010 0001 000d 0000 001d  ................
00000160: 0001 0001 0000 0005 2ab4 0002 ac00 0000  ........*.......
00000170: 0100 0e00 0000 0600 0100 0000 0a00 0100  ................
00000180: 1100 1200 0100 0d00 0000 2200 0200 0200  ..........".....
00000190: 0000 062a 1bb5 0002 b100 0000 0100 0e00  ...*............
000001a0: 0000 0a00 0200 0000 0e00 0500 0f00 0100  ................
000001b0: 1300 0000 0200 14                        .......
```

```hexadecimal
# ByteCode.class
00000000: cafe babe 0000 0034 001e 0a00 0600 1809  .......4........
00000010: 0005 0019 0a00 0600 1a0a 0005 001b 0700  ................
00000020: 1c07 001d 0100 0663 4669 656c 6401 0012  .......cField...
00000030: 4c6a 6176 612f 6c61 6e67 2f53 7472 696e  Ljava/lang/Strin
00000040: 673b 0100 063c 696e 6974 3e01 0003 2829  g;...<init>...()
00000050: 5601 0004 436f 6465 0100 0f4c 696e 654e  V...Code...LineN
00000060: 756d 6265 7254 6162 6c65 0100 0967 6574  umberTable...get
00000070: 6346 6965 6c64 0100 1428 294c 6a61 7661  cField...()Ljava
00000080: 2f6c 616e 672f 5374 7269 6e67 3b01 0009  /lang/String;...
00000090: 7365 7463 4669 656c 6401 0015 284c 6a61  setcField...(Lja
000000a0: 7661 2f6c 616e 672f 5374 7269 6e67 3b29  va/lang/String;)
000000b0: 5601 0009 6765 7470 4669 656c 6401 0003  V...getpField...
000000c0: 2829 4901 0004 7465 7374 0100 046d 6169  ()I...test...mai
000000d0: 6e01 0016 285b 4c6a 6176 612f 6c61 6e67  n...([Ljava/lang
000000e0: 2f53 7472 696e 673b 2956 0100 0a53 6f75  /String;)V...Sou
000000f0: 7263 6546 696c 6501 000d 4279 7465 436f  rceFile...ByteCo
00000100: 6465 2e6a 6176 610c 0009 000a 0c00 0700  de.java.........
00000110: 080c 0011 0012 0c00 1300 1201 0019 636e  ..............cn
00000120: 2f69 676f 722f 6170 6d2f 6465 6d6f 2f42  /igor/apm/demo/B
00000130: 7974 6543 6f64 6501 0019 636e 2f69 676f  yteCode...cn/igo
00000140: 722f 6170 6d2f 6465 6d6f 2f42 6173 6543  r/apm/demo/BaseC
00000150: 6f64 6500 2100 0500 0600 0000 0100 0200  ode.!...........
00000160: 0700 0800 0000 0600 0100 0900 0a00 0100  ................
00000170: 0b00 0000 1d00 0100 0100 0000 052a b700  .............*..
00000180: 01b1 0000 0001 000c 0000 0006 0001 0000  ................
00000190: 0003 0001 000d 000e 0001 000b 0000 001d  ................
000001a0: 0001 0001 0000 0005 2ab4 0002 b000 0000  ........*.......
000001b0: 0100 0c00 0000 0600 0100 0000 0800 0100  ................
000001c0: 0f00 1000 0100 0b00 0000 2200 0200 0200  ..........".....
000001d0: 0000 062a 2bb5 0002 b100 0000 0100 0c00  ...*+...........
000001e0: 0000 0a00 0200 0000 0c00 0500 0d00 0100  ................
000001f0: 1100 1200 0100 0b00 0000 1d00 0100 0100  ................
00000200: 0000 052a b700 03ac 0000 0001 000c 0000  ...*............
00000210: 0006 0001 0000 0011 0009 0013 0012 0001  ................
00000220: 000b 0000 0028 0002 0002 0000 0008 043b  .....(.........;
00000230: 053c 1a1b 60ac 0000 0001 000c 0000 000e  .<..`...........
00000240: 0003 0000 0016 0002 0017 0004 0018 0009  ................
00000250: 0014 0015 0001 000b 0000 0021 0001 0001  ...........!....
00000260: 0000 0005 b800 0457 b100 0000 0100 0c00  .......W........
00000270: 0000 0a00 0200 0000 1c00 0400 1d00 0100  ................
00000280: 1600 0000 0200 17                        .......
```

### 约定结构

> 参考[wiki_java_class_file](https://en.wikipedia.org/wiki/Java_class_file#General_layout)。

<table class="wikitable"><table><tbody><tr>
<th>byte offset
</th>
<th>size
</th>
<th>type or value
</th>
<th>description
</th></tr>
<tr>
<td>0
</td>
<td rowspan="4">4 bytes
</td>
<td>u1 =<br>0xCA hex
</td>
<td rowspan="4"><a href="/wiki/Magic_number_(programming)" title="Magic number (programming)">magic number</a> (CAFEBABE) used to identify file as conforming to the class file format
<br/>前四字节是CAFEBABE的魔数。就像标记了文件类型，这是一个符合jvm规范的class文件的开头。
</td></tr>
<tr>
<td>1
</td>
<td>u1 =<br>0xFE hex
</td></tr>
<tr>
<td>2
</td>
<td>u1 =<br>0xBA hex
</td></tr>
<tr>
<td>3
</td>
<td>u1 =<br>0xBE hex
</td></tr>
<tr>
<td>4
</td>
<td rowspan="2">2 bytes
</td>
<td rowspan="2">u2
</td>
<td rowspan="2">minor version number of the class file format being used
 <br/>这是jdk的小版本号。我们上面两个00000034，前面0000说明没有小版本区别。
</td></tr>
<tr>
<td>5
</td></tr>
<tr>
<td>6
</td>
<td rowspan="2">2 bytes
</td>
<td rowspan="2">u2
</td>
<td rowspan="2">major version number of the class file format being used.<br>
  JDK的主版本号。这里经常会碰到的错误就是「unsupported major.minor version 52.0」说明当前这个class是通过java8编译的，而当前环境的jdk版本低于java8，不能兼容。
<p>Java SE 17 = 61 (0x3D hex)<br> 
Java SE 16 = 60 (0x3C hex),<br>
Java SE 15 = 59 (0x3B hex),<br>
Java SE 14 = 58 (0x3A hex),<br>
Java SE 13 = 57 (0x39 hex),<br>
Java SE 12 = 56 (0x38 hex),<br>
Java SE 11 = 55 (0x37 hex),<br>
Java SE 10 = 54 (0x36 hex),<sup id="cite_ref-3" class="reference"><a href="#cite_note-3">[3]</a></sup><br>
Java SE 9 = 53 (0x35 hex),<sup id="cite_ref-4" class="reference"><a href="#cite_note-4">[4]</a></sup><br>
Java SE 8 = 52 (0x34 hex),<br>Java SE 7 = 51 (0x33 hex),<br>Java SE 6.0 = 50 (0x32 hex),<br>Java SE 5.0 = 49 (0x31 hex),<br>JDK 1.4 = 48 (0x30 hex),<br>JDK 1.3 = 47 (0x2F hex),<br>JDK 1.2 = 46 (0x2E hex),<br>JDK 1.1 = 45 (0x2D hex).<br>For details of earlier version numbers see footnote 1 at <a rel="nofollow" class="external text" href="https://docs.oracle.com/javase/specs/jvms/se6/html/ClassFile.doc.html">The JavaTM Virtual Machine Specification 2nd edition</a>
</p>
</td></tr>
<tr>
<td>7
</td></tr>
<tr>
<td>8
</td>
<td rowspan="2">2 bytes
</td>
<td rowspan="2">u2
</td>
<td rowspan="2">constant pool count, number of entries in the following constant pool table.  This count is at least one greater than the actual number of entries; see following discussion.
<br/>这里标记了常量池的大小。我们看到上面class的一个常量池大小分别是001a「25」和001e「29」。这里似乎有两个违反常识的点。
<br/>一个是「都减了1：1a应该是26；1e应该是30」，wiki百科里说这是因为「文件格式开发过程中的历史选择」，或许可以理解为nextCurrentIndex。
<br/>另一个是「为啥不是+1，因为我们通常的计数都是从0开始」，这是因为索引0标识无效「null」不引用任何索引。
</td></tr>
<tr>
<td>9
</td></tr>
<tr>
<td>10
</td>
<td rowspan="4"><i>cpsize</i> (variable)
</td>
<td rowspan="4">table
</td>
<td rowspan="4">constant pool table, an array of variable-sized constant pool entries, containing items such as literal numbers, strings, and references to classes or methods.  Indexed starting at 1, containing (<i>constant pool count</i> - 1) number of entries in total (see note).
<br/>详见常量池结构
</td></tr>
<tr>
<td>...
</td></tr>
<tr>
<td>...
</td></tr>
<tr>
<td>...
</td></tr>
<tr>
<td>10+<i>cpsize</i>
</td>
<td rowspan="2">2 bytes
</td>
<td rowspan="2">u2
</td>
<td rowspan="2">access flags, a bitmask
<br/>访问标识的config，固定16位，不同的位代表不同的访问控制是否开启
<br/>详见访问标识。
</td></tr>
<tr>
<td>11+<i>cpsize</i>
</td></tr>
<tr>
<td>12+<i>cpsize</i>
</td>
<td rowspan="2">2 bytes
</td>
<td rowspan="2">u2
</td>
<td rowspan="2">identifies <i>this</i> class, index into the constant pool to a "Class"-type entry
<br/>类名对应的常量池索引
</td></tr>
<tr>
<td>13+<i>cpsize</i>
</td></tr>
<tr>
<td>14+<i>cpsize</i>
</td>
<td rowspan="2">2 bytes
</td>
<td rowspan="2">u2
</td>
<td rowspan="2">identifies <i>super</i> class, index into the constant pool to a "Class"-type entry
<br/>父类名对应的常量池索引
</td></tr>
<tr>
<td>15+<i>cpsize</i>
</td></tr>
<tr>
<td>16+<i>cpsize</i>
</td>
<td rowspan="2">2 bytes
</td>
<td rowspan="2">u2
</td>
<td rowspan="2">interface count, number of entries in the following interface table
<br/>接口计数器
</td></tr>
<tr>
<td>17+<i>cpsize</i>
</td></tr>
<tr>
<td>18+<i>cpsize</i>
</td>
<td rowspan="4"><i>isize</i> (variable)
</td>
<td rowspan="4">table
</td>
<td rowspan="4">interface table: a variable-length array of constant pool indexes describing the interfaces implemented by this class
<br/>接口表
</td></tr>
<tr>
<td>...
</td></tr>
<tr>
<td>...
</td></tr>
<tr>
<td>...
</td></tr>
<tr>
<td>18+<i>cpsize</i>+<i>isize</i>
</td>
<td rowspan="2">2 bytes
</td>
<td rowspan="2">u2
</td>
<td rowspan="2">field count, number of entries in the following field table
<br/>字段计数器
</td></tr>
<tr>
<td>19+<i>cpsize</i>+<i>isize</i>
</td></tr>
<tr>
<td>20+<i>cpsize</i>+<i>isize</i>
</td>
<td rowspan="4"><i>fsize</i> (variable)
</td>
<td rowspan="4">table
</td>
<td rowspan="4">field table, variable length array of fields
<p>each element is a field_info structure defined in <a rel="nofollow" class="external free" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.5">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.5</a>
<br/>字段表
</p>
</td></tr>
<tr>
<td>...
</td></tr>
<tr>
<td>...
</td></tr>
<tr>
<td>...
</td></tr>
<tr>
<td>20+<i>cpsize</i>+<i>isize</i>+<i>fsize</i>
</td>
<td rowspan="2">2 bytes
</td>
<td rowspan="2">u2
</td>
<td rowspan="2">method count, number of entries in the following method table
<br/>方法计数器
</td></tr>
<tr>
<td>21+<i>cpsize</i>+<i>isize</i>+<i>fsize</i>
</td></tr>
<tr>
<td>22+<i>cpsize</i>+<i>isize</i>+<i>fsize</i>
</td>
<td rowspan="4"><i>msize</i> (variable)
</td>
<td rowspan="4">table
</td>
<td rowspan="4">method table, variable length array of methods each element is a method_info structure defined in <a rel="nofollow" class="external free" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.6">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.6</a></td></tr>
<br/>方法表
<tr>
<td>...
</td></tr>
<tr>
<td>...
</td></tr>
<tr>
<td>...
</td></tr>
<tr>
<td>22+<i>cpsize</i>+<i>isize</i>+<i>fsize</i>+<i>msize</i>
</td>
<td rowspan="2">2 bytes
</td>
<td rowspan="2">u2
</td>
<td rowspan="2">attribute count, number of entries in the following attribute table
<br/>附加属性计数器
</td></tr>
<tr>
<td>23+<i>cpsize</i>+<i>isize</i>+<i>fsize</i>+<i>msize</i>
</td></tr>
<tr>
<td>24+<i>cpsize</i>+<i>isize</i>+<i>fsize</i>+<i>msize</i>
</td>
<td rowspan="4"><i>asize</i> (variable)
</td>
<td rowspan="4">table
</td>
<td rowspan="4">attribute table, variable length array of attributes<p>each element is an attribute_info structure defined in <a rel="nofollow" class="external free" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7</a>
<br/>附加属性表
</p>
</td></tr>
<tr>
<td>...
</td></tr>
<tr>
<td>...
</td></tr>
<tr>
<td>...
</td></tr></tbody></table>

### 常量池结构

> 资料来自[美团技术团队](https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html)。
>
> 举个例子：BaseCode.class的常量池计数器后面的第一个字节0a「十进制10」,对应CONSTANT_Methodref_info。后面有4个字节，前两个标识CONSTANT_Class_info的常量池索引0004「4」；后两个标识CONSTANT_NameAndType的常量池索引0015「21」。
>
> 这个常量池数据不是固定长度的，要根据具体情况而定。
>
> 在BaseCode.class「因为数据少」里共有25个常量信息，分别是
>
> ```text
> 0a 0004 0015
> 09 0003 0016
> 07 0017
> 07 0018
> 01 0003 6b6579
> 01 0012 4c6a6176612f6c616e672f537472696e673b
> 01 000d 436f6e7374616e7456616c7565
> 08 0019
> 01 0006 6704669656c64
> 01 0001 49
> 01 0006 3c696e69743e
> 01 0003 282956
> 01 0004 436f6465
> 01 000f 4c696e654e756d6265725461626c65
> 01 0009 676574704669656c64
> 01 0003 282949
> 01 0009 736574704669656c64
> 01 0004 28492956
> 01 000a 536f7572636546696c65
> 01 000d 42617365436f64652e6a617661
> 0c 000b 000c
> 0c 0009 000a
> 01 0019 636e2f69676f722f61706d2f64656d6f2f42617365436f6465
> 01 0010 6a6176612f6c616e672f4f626a656374
> 01 0008 74656d705f6b6579
> ```
>
> 了解就好。

![图6 各类型的cp_info](https://gitee.com/wangigor/typora-images/raw/master/f5bdc7e8203ec666a531fcd19cdbcddc519208.png)

### 访问标识

> 16位，与16个MASK进行位运算，就知道当前访问控制的组合。

![image-20210728224829661](https://gitee.com/wangigor/typora-images/raw/master/image-20210728224829661.png)

在Modifier.java里有对应的代码。下面只把这16个mask列出来。

```java
/*
 * Access modifier flag constants from tables 4.1, 4.4, 4.5, and 4.7 of
 * <cite>The Java&trade; Virtual Machine Specification</cite>
 */

/**
 * The {@code int} value representing the {@code public}
 * modifier.
 */
public static final int PUBLIC           = 0x00000001;

/**
 * The {@code int} value representing the {@code private}
 * modifier.
 */
public static final int PRIVATE          = 0x00000002;

/**
 * The {@code int} value representing the {@code protected}
 * modifier.
 */
public static final int PROTECTED        = 0x00000004;

/**
 * The {@code int} value representing the {@code static}
 * modifier.
 */
public static final int STATIC           = 0x00000008;

/**
 * The {@code int} value representing the {@code final}
 * modifier.
 */
public static final int FINAL            = 0x00000010;

/**
 * The {@code int} value representing the {@code synchronized}
 * modifier.
 */
public static final int SYNCHRONIZED     = 0x00000020;

/**
 * The {@code int} value representing the {@code volatile}
 * modifier.
 */
public static final int VOLATILE         = 0x00000040;

/**
 * The {@code int} value representing the {@code transient}
 * modifier.
 */
public static final int TRANSIENT        = 0x00000080;

/**
 * The {@code int} value representing the {@code native}
 * modifier.
 */
public static final int NATIVE           = 0x00000100;

/**
 * The {@code int} value representing the {@code interface}
 * modifier.
 */
public static final int INTERFACE        = 0x00000200;

/**
 * The {@code int} value representing the {@code abstract}
 * modifier.
 */
public static final int ABSTRACT         = 0x00000400;

/**
 * The {@code int} value representing the {@code strictfp}
 * modifier.
 */
public static final int STRICT           = 0x00000800;
// Bits not (yet) exposed in the public API either because they
// have different meanings for fields and methods and there is no
// way to distinguish between the two in this class, or because
// they are not Java programming language keywords
static final int BRIDGE    = 0x00000040;
static final int VARARGS   = 0x00000080;
static final int SYNTHETIC = 0x00001000;
static final int ANNOTATION  = 0x00002000;
static final int ENUM      = 0x00004000;
static final int MANDATED  = 0x00008000;
```

那么上面两个class都是0x0021，也就是synchronized+public

### 字段

字段表结构

```info
field_info {
    u2             access_flags; 
    u2             name_index;
    u2             descriptor_index;
    u2             attributes_count;
    attribute_info attributes[attributes_count];
}
```

access_flags这个访问控制符呢，占两个字节，跟类的访问控制符基本一样。

```java
/**
 * Access modifier flags.
 */
static final char
    ACC_PUBLIC                 = 0x0001,
    ACC_PRIVATE                = 0x0002,
    ACC_PROTECTED              = 0x0004,
    ACC_STATIC                 = 0x0008,
    ACC_FINAL                  = 0x0010,
    ACC_SYNCHRONIZED           = 0x0020,
    ACC_VOLATILE               = 0x0040,
    ACC_TRANSIENT              = 0x0080,
    ACC_NATIVE                 = 0x0100,
    ACC_INTERFACE              = 0x0200,
    ACC_ABSTRACT               = 0x0400,
    ACC_STRICT                 = 0x0800,
    ACC_SYNTHETIC              = 0x1000,
    ACC_ANNOTATION             = 0x2000,
    ACC_ENUM                   = 0x4000,
    // aliases:
    ACC_SUPER                  = ACC_SYNCHRONIZED,
    ACC_BRIDGE                 = ACC_VOLATILE,
    ACC_VARARGS                = ACC_TRANSIENT;
```

name_index是字段名称对应的常量池索引，占2个字节。

descriptor_index是字段类型对应的常量池索引，占2个字节。

以BaseCode为例。

```text
0002 有两个字段
第一个 0019 public static final
      0005 名称常量池索引
      0006 类型常量池索引
      0001 有一个属性
      0007 属性名称
      00000002 属性值长度为2
      0008 属性值常量池索引
第二个 0002 private
      0009 名称常量池索引
      000a 类型常量池索引
      0000 没有属性
```

### 方法

方法表结构

```text
method_info {
    u2             access_flags;
    u2             name_index;
    u2             descriptor_index;
    u2             attributes_count;
    attribute_info attributes[attributes_count];
}
```

基本跟属性或者字段一样的。

但是对于Code属性，有很重要的就是操作符。

参考文档：[The Java Virtual Machine Instruction Set](https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-6.html)

### 属性

属性表结构

```text
attribute_info {
    u2 attribute_name_index;
    u4 attribute_length;
    u1 info[attribute_length];
}
```

预置的属性，分为三组：

```text
对于jvm解析class至关重要的5个
 ConstantValue
 Code
 StackMapTable
 Exceptions
 BootstrapMethods
```

```text
对于javase平台解析class重要的12个属性
InnerClasses
 EnclosingMethod
 Synthetic
 Signature
 RuntimeVisibleAnnotations
 RuntimeInvisibleAnnotations
 RuntimeVisibleParameterAnnotations
 RuntimeInvisibleParameterAnnotations
 RuntimeVisibleTypeAnnotations
 RuntimeInvisibleTypeAnnotations
 AnnotationDefault
 MethodParameters
```

```text
对于jvm和javase可以忽略的6个属性
 SourceFile
 SourceDebugExtension
 LineNumberTable
 LocalVariableTable
 LocalVariableTypeTable
 Deprecated
```

详情可以查看oracle 的[class format文档](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7)。

### 可视

> 当然不需要像上面这样按照字符查看，javap已经帮我们都做了。
>
> 命令：```javap -verbose XXXX```

那么上面的两个class文件就是下面这样

```c
Classfile /Users/wangke/IdeaProjects/git/apm-demo/src/main/java/cn/igor/apm/demo/BaseCode.class
  Last modified 2021-7-28; size 439 bytes
  MD5 checksum dfa4999537c5f223c429fc9a90892020
  Compiled from "BaseCode.java"
public class cn.igor.apm.demo.BaseCode
  minor version: 0
  major version: 52
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 = Methodref          #4.#21         // java/lang/Object."<init>":()V
   #2 = Fieldref           #3.#22         // cn/igor/apm/demo/BaseCode.pField:I
   #3 = Class              #23            // cn/igor/apm/demo/BaseCode
   #4 = Class              #24            // java/lang/Object
   #5 = Utf8               key
   #6 = Utf8               Ljava/lang/String;
   #7 = Utf8               ConstantValue
   #8 = String             #25            // temp_key
   #9 = Utf8               pField
  #10 = Utf8               I
  #11 = Utf8               <init>
  #12 = Utf8               ()V
  #13 = Utf8               Code
  #14 = Utf8               LineNumberTable
  #15 = Utf8               getpField
  #16 = Utf8               ()I
  #17 = Utf8               setpField
  #18 = Utf8               (I)V
  #19 = Utf8               SourceFile
  #20 = Utf8               BaseCode.java
  #21 = NameAndType        #11:#12        // "<init>":()V
  #22 = NameAndType        #9:#10         // pField:I
  #23 = Utf8               cn/igor/apm/demo/BaseCode
  #24 = Utf8               java/lang/Object
  #25 = Utf8               temp_key
{
  public static final java.lang.String key;
    descriptor: Ljava/lang/String;
    flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL
    ConstantValue: String temp_key

  public cn.igor.apm.demo.BaseCode();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: return
      LineNumberTable:
        line 3: 0

  public int getpField();
    descriptor: ()I
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: getfield      #2                  // Field pField:I
         4: ireturn
      LineNumberTable:
        line 10: 0

  public void setpField(int);
    descriptor: (I)V
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=2, args_size=2
         0: aload_0
         1: iload_1
         2: putfield      #2                  // Field pField:I
         5: return
      LineNumberTable:
        line 14: 0
        line 15: 5
}
SourceFile: "BaseCode.java"
```

```c
Classfile /Users/wangke/IdeaProjects/git/apm-demo/src/main/java/cn/igor/apm/demo/ByteCode.class
  Last modified 2021-7-28; size 827 bytes
  MD5 checksum 87f71228757b2c77c1561d00d6360ba9
  Compiled from "ByteCode.java"
public class cn.igor.apm.demo.ByteCode extends cn.igor.apm.demo.BaseCode
  minor version: 0
  major version: 52
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 = Methodref          #9.#27         // cn/igor/apm/demo/BaseCode."<init>":()V
   #2 = Fieldref           #6.#28         // cn/igor/apm/demo/ByteCode.cField:Ljava/lang/String;
   #3 = Methodref          #9.#29         // cn/igor/apm/demo/BaseCode.getpField:()I
   #4 = Methodref          #6.#30         // cn/igor/apm/demo/ByteCode.test:()I
   #5 = Fieldref           #31.#32        // java/lang/System.out:Ljava/io/PrintStream;
   #6 = Class              #33            // cn/igor/apm/demo/ByteCode
   #7 = Methodref          #34.#35        // java/lang/Class.isSynthetic:()Z
   #8 = Methodref          #36.#37        // java/io/PrintStream.println:(Z)V
   #9 = Class              #38            // cn/igor/apm/demo/BaseCode
  #10 = Utf8               cField
  #11 = Utf8               Ljava/lang/String;
  #12 = Utf8               <init>
  #13 = Utf8               ()V
  #14 = Utf8               Code
  #15 = Utf8               LineNumberTable
  #16 = Utf8               getcField
  #17 = Utf8               ()Ljava/lang/String;
  #18 = Utf8               setcField
  #19 = Utf8               (Ljava/lang/String;)V
  #20 = Utf8               getpField
  #21 = Utf8               ()I
  #22 = Utf8               test
  #23 = Utf8               main
  #24 = Utf8               ([Ljava/lang/String;)V
  #25 = Utf8               SourceFile
  #26 = Utf8               ByteCode.java
  #27 = NameAndType        #12:#13        // "<init>":()V
  #28 = NameAndType        #10:#11        // cField:Ljava/lang/String;
  #29 = NameAndType        #20:#21        // getpField:()I
  #30 = NameAndType        #22:#21        // test:()I
  #31 = Class              #39            // java/lang/System
  #32 = NameAndType        #40:#41        // out:Ljava/io/PrintStream;
  #33 = Utf8               cn/igor/apm/demo/ByteCode
  #34 = Class              #42            // java/lang/Class
  #35 = NameAndType        #43:#44        // isSynthetic:()Z
  #36 = Class              #45            // java/io/PrintStream
  #37 = NameAndType        #46:#47        // println:(Z)V
  #38 = Utf8               cn/igor/apm/demo/BaseCode
  #39 = Utf8               java/lang/System
  #40 = Utf8               out
  #41 = Utf8               Ljava/io/PrintStream;
  #42 = Utf8               java/lang/Class
  #43 = Utf8               isSynthetic
  #44 = Utf8               ()Z
  #45 = Utf8               java/io/PrintStream
  #46 = Utf8               println
  #47 = Utf8               (Z)V
{
  public cn.igor.apm.demo.ByteCode();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method cn/igor/apm/demo/BaseCode."<init>":()V
         4: return
      LineNumberTable:
        line 3: 0

  public java.lang.String getcField();
    descriptor: ()Ljava/lang/String;
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: getfield      #2                  // Field cField:Ljava/lang/String;
         4: areturn
      LineNumberTable:
        line 8: 0

  public void setcField(java.lang.String);
    descriptor: (Ljava/lang/String;)V
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=2, args_size=2
         0: aload_0
         1: aload_1
         2: putfield      #2                  // Field cField:Ljava/lang/String;
         5: return
      LineNumberTable:
        line 12: 0
        line 13: 5

  public int getpField();
    descriptor: ()I
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #3                  // Method cn/igor/apm/demo/BaseCode.getpField:()I
         4: ireturn
      LineNumberTable:
        line 17: 0

  public static int test();
    descriptor: ()I
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=2, args_size=0
         0: iconst_1
         1: istore_0
         2: iconst_2
         3: istore_1
         4: iload_0
         5: iload_1
         6: iadd
         7: ireturn
      LineNumberTable:
        line 22: 0
        line 23: 2
        line 24: 4

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=1, args_size=1
         0: invokestatic  #4                  // Method test:()I
         3: pop
         4: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;
         7: ldc           #6                  // class cn/igor/apm/demo/ByteCode
         9: invokevirtual #7                  // Method java/lang/Class.isSynthetic:()Z
        12: invokevirtual #8                  // Method java/io/PrintStream.println:(Z)V
        15: return
      LineNumberTable:
        line 28: 0
        line 29: 4
        line 30: 15
}
SourceFile: "ByteCode.java"
```

## 字节码修改

> 字节码增强，是AOP在字节码修改方面的使用，对程序的侵入更小。
>
> 目前有ASM「例：cglib在用」，javaassist「例：dubbo的SPI在用」,ByteBuddy「例：skywalking在用」。
>
> 下面我们一个一个来看。

### ASM

> [ASM4.0官方文档](https://asm.ow2.io/asm4-guide.pdf)
>
> ASM是通过编程方式，生成或修改.class文件，比如常量池数据，字段，方法「方法栈深度，方法执行行号，数据读取、入栈、出栈、方法调用等等」等等。怎么说呢，有些晦涩难懂「或者需要的成本比较高」。我已经放弃了细节得去扣具体怎么实现「业务」。
>
> 且官方提供了插件「ASM Bytecode Outline」.
>
> <img src="https://gitee.com/wangigor/typora-images/raw/master/image-20210729144122929.png" alt="image-20210729144122929" style="zoom:50%;" />

比如你写好了代码，右键「Show Bytecode outline」

<img src="https://gitee.com/wangigor/typora-images/raw/master/image-20210729144354937.png" alt="image-20210729144354937" style="zoom: 50%;" />



<img src="https://gitee.com/wangigor/typora-images/raw/master/image-20210729144557400.png" alt="image-20210729144557400" style="zoom:67%;" />

> ASM采用的是访问者模式，所以我们能看到很多的visit/visitor.

#### 生成字节码执行

> classloader没有暴露出来通过byte[]生成class的方法。
>
> 需要重新封装一个classloader。请看下面代码。

```java
package cn.igor.apm.demo.asm;

import jdk.internal.org.objectweb.asm.*;

import java.lang.reflect.Method;

import static jdk.internal.org.objectweb.asm.Opcodes.*;

/**
 * 新建一个helloworld的ASM测试类
 */
public class HelloWorldASM {

    /**
     * 拷贝来插件生成的「dump」方法
     * 用于生成HelloWorld.class
     * @return
     * @throws Exception
     */
    public static byte[] dump() throws Exception {

        ClassWriter cw = new ClassWriter(0);
        FieldVisitor fv;
        MethodVisitor mv;
        AnnotationVisitor av0;

        cw.visit(52, ACC_PUBLIC + ACC_SUPER, "cn/igor/apm/demo/asm/HelloWorld", null, "java/lang/Object", null);

        cw.visitSource("HelloWorld.java", null);

        {
            fv = cw.visitField(ACC_PUBLIC + ACC_FINAL + ACC_STATIC, "name", "Ljava/lang/String;", null, "world");
            fv.visitEnd();
        }
        {
            mv = cw.visitMethod(ACC_PUBLIC, "<init>", "()V", null, null);
            mv.visitCode();
            Label l0 = new Label();
            mv.visitLabel(l0);
            mv.visitLineNumber(3, l0);
            mv.visitVarInsn(ALOAD, 0);
            mv.visitMethodInsn(INVOKESPECIAL, "java/lang/Object", "<init>", "()V", false);
            mv.visitInsn(RETURN);
            Label l1 = new Label();
            mv.visitLabel(l1);
            mv.visitLocalVariable("this", "Lcn/igor/apm/demo/asm/HelloWorld;", null, l0, l1, 0);
            mv.visitMaxs(1, 1);
            mv.visitEnd();
        }
        {
            mv = cw.visitMethod(ACC_PUBLIC + ACC_STATIC, "main", "([Ljava/lang/String;)V", null, null);
            mv.visitCode();
            Label l0 = new Label();
            mv.visitLabel(l0);
            mv.visitLineNumber(8, l0);
            mv.visitFieldInsn(GETSTATIC, "java/lang/System", "out", "Ljava/io/PrintStream;");
            mv.visitLdcInsn("helloworld");
            mv.visitMethodInsn(INVOKEVIRTUAL, "java/io/PrintStream", "println", "(Ljava/lang/String;)V", false);
            Label l1 = new Label();
            mv.visitLabel(l1);
            mv.visitLineNumber(9, l1);
            mv.visitInsn(RETURN);
            Label l2 = new Label();
            mv.visitLabel(l2);
            mv.visitLocalVariable("args", "[Ljava/lang/String;", null, l0, l2, 0);
            mv.visitMaxs(2, 1);
            mv.visitEnd();
        }
        cw.visitEnd();

        return cw.toByteArray();
    }

    public static void main(String[] args) throws Exception {
        byte[] dump = dump();

        ASMClassLoader asmClassLoader = new ASMClassLoader();
        Class helloworldClass = asmClassLoader.defineClass("cn.igor.apm.demo.asm.HelloWorld", dump);

        //main方法执行
        Method main = helloworldClass.getMethod("main", String[].class);
        main.invoke(null, new Object[]{new String[]{}});

    }


}

/**
 * 自定义classloader
 * 暴露出父接口的通过byte[]生成class的protected方法
 */
class ASMClassLoader extends ClassLoader {
    public Class defineClass(String name, byte[] bytes) {
        return super.defineClass(name, bytes, 0, bytes.length);
    }
}
```

#### 修改字节码执行



### javaassist

### ByteBuddy

> [github](https://github.com/raphw/byte-buddy)
>
> [stackoverflow问题集](https://stackoverflow.com/questions/tagged/byte-buddy)

