

# 字节码增强



## 字节码

> .java文件是程序员能「使用」的文件。.class文件是java虚拟机能「使用」的文件。
>
> .java文件经过编译「javac」之后，转换成.class文件。先来了解一下class文件结构。
>
> 当然，仅供了解。不深。

首先随便写两个java文件。

- 父类

```java
package cn.igor.apm.demo;

public class BaseCode {

    public static final String key="temp_key";

    private int pField;

    public int getpField() {
        return pField;
    }

    public void setpField(int pField) {
        this.pField = pField;
    }

}
```

- 子类

```java
package cn.igor.apm.demo;

public class ByteCode extends BaseCode {

    private String cField;

    public String getcField() {
        return cField;
    }

    public void setcField(String cField) {
        this.cField = cField;
    }

    @Override
    public int getpField() {
        return super.getpField();
    }

    //测试
    public static int test() {
        int a = 1;
        int b = 2;
        return a + b;
    }

    public static void main(String[] args) {
        test();
    }
}
```

通过```javac ByteCode.java BaseCode.java ```编译得到两个对应的class文件。

> 这是两个二进制文件，我们先使用二进制打开它看看他的结构。
>
> 可以使用sublime，也可以使用vi
>
> ```bash
> # -b 以二进制显示
> vi -b baseCode.class
> #全部替换为16进制显示
> :%!xxd 
> ```

```hexadecimal
# BaseCode.class
00000000: cafe babe 0000 0034 001a 0a00 0400 1509  .......4........
00000010: 0003 0016 0700 1707 0018 0100 036b 6579  .............key
00000020: 0100 124c 6a61 7661 2f6c 616e 672f 5374  ...Ljava/lang/St
00000030: 7269 6e67 3b01 000d 436f 6e73 7461 6e74  ring;...Constant
00000040: 5661 6c75 6508 0019 0100 0670 4669 656c  Value......pFiel
00000050: 6401 0001 4901 0006 3c69 6e69 743e 0100  d...I...<init>..
00000060: 0328 2956 0100 0443 6f64 6501 000f 4c69  .()V...Code...Li
00000070: 6e65 4e75 6d62 6572 5461 626c 6501 0009  neNumberTable...
00000080: 6765 7470 4669 656c 6401 0003 2829 4901  getpField...()I.
00000090: 0009 7365 7470 4669 656c 6401 0004 2849  ..setpField...(I
000000a0: 2956 0100 0a53 6f75 7263 6546 696c 6501  )V...SourceFile.
000000b0: 000d 4261 7365 436f 6465 2e6a 6176 610c  ..BaseCode.java.
000000c0: 000b 000c 0c00 0900 0a01 0019 636e 2f69  ............cn/i
000000d0: 676f 722f 6170 6d2f 6465 6d6f 2f42 6173  gor/apm/demo/Bas
000000e0: 6543 6f64 6501 0010 6a61 7661 2f6c 616e  eCode...java/lan
000000f0: 672f 4f62 6a65 6374 0100 0874 656d 705f  g/Object...temp_
00000100: 6b65 7900 2100 0300 0400 0000 0200 1900  key.!...........
00000110: 0500 0600 0100 0700 0000 0200 0800 0200  ................
00000120: 0900 0a00 0000 0300 0100 0b00 0c00 0100  ................
00000130: 0d00 0000 1d00 0100 0100 0000 052a b700  .............*..
00000140: 01b1 0000 0001 000e 0000 0006 0001 0000  ................
00000150: 0003 0001 000f 0010 0001 000d 0000 001d  ................
00000160: 0001 0001 0000 0005 2ab4 0002 ac00 0000  ........*.......
00000170: 0100 0e00 0000 0600 0100 0000 0a00 0100  ................
00000180: 1100 1200 0100 0d00 0000 2200 0200 0200  ..........".....
00000190: 0000 062a 1bb5 0002 b100 0000 0100 0e00  ...*............
000001a0: 0000 0a00 0200 0000 0e00 0500 0f00 0100  ................
000001b0: 1300 0000 0200 14                        .......
```

```hexadecimal
# ByteCode.class
00000000: cafe babe 0000 0034 001e 0a00 0600 1809  .......4........
00000010: 0005 0019 0a00 0600 1a0a 0005 001b 0700  ................
00000020: 1c07 001d 0100 0663 4669 656c 6401 0012  .......cField...
00000030: 4c6a 6176 612f 6c61 6e67 2f53 7472 696e  Ljava/lang/Strin
00000040: 673b 0100 063c 696e 6974 3e01 0003 2829  g;...<init>...()
00000050: 5601 0004 436f 6465 0100 0f4c 696e 654e  V...Code...LineN
00000060: 756d 6265 7254 6162 6c65 0100 0967 6574  umberTable...get
00000070: 6346 6965 6c64 0100 1428 294c 6a61 7661  cField...()Ljava
00000080: 2f6c 616e 672f 5374 7269 6e67 3b01 0009  /lang/String;...
00000090: 7365 7463 4669 656c 6401 0015 284c 6a61  setcField...(Lja
000000a0: 7661 2f6c 616e 672f 5374 7269 6e67 3b29  va/lang/String;)
000000b0: 5601 0009 6765 7470 4669 656c 6401 0003  V...getpField...
000000c0: 2829 4901 0004 7465 7374 0100 046d 6169  ()I...test...mai
000000d0: 6e01 0016 285b 4c6a 6176 612f 6c61 6e67  n...([Ljava/lang
000000e0: 2f53 7472 696e 673b 2956 0100 0a53 6f75  /String;)V...Sou
000000f0: 7263 6546 696c 6501 000d 4279 7465 436f  rceFile...ByteCo
00000100: 6465 2e6a 6176 610c 0009 000a 0c00 0700  de.java.........
00000110: 080c 0011 0012 0c00 1300 1201 0019 636e  ..............cn
00000120: 2f69 676f 722f 6170 6d2f 6465 6d6f 2f42  /igor/apm/demo/B
00000130: 7974 6543 6f64 6501 0019 636e 2f69 676f  yteCode...cn/igo
00000140: 722f 6170 6d2f 6465 6d6f 2f42 6173 6543  r/apm/demo/BaseC
00000150: 6f64 6500 2100 0500 0600 0000 0100 0200  ode.!...........
00000160: 0700 0800 0000 0600 0100 0900 0a00 0100  ................
00000170: 0b00 0000 1d00 0100 0100 0000 052a b700  .............*..
00000180: 01b1 0000 0001 000c 0000 0006 0001 0000  ................
00000190: 0003 0001 000d 000e 0001 000b 0000 001d  ................
000001a0: 0001 0001 0000 0005 2ab4 0002 b000 0000  ........*.......
000001b0: 0100 0c00 0000 0600 0100 0000 0800 0100  ................
000001c0: 0f00 1000 0100 0b00 0000 2200 0200 0200  ..........".....
000001d0: 0000 062a 2bb5 0002 b100 0000 0100 0c00  ...*+...........
000001e0: 0000 0a00 0200 0000 0c00 0500 0d00 0100  ................
000001f0: 1100 1200 0100 0b00 0000 1d00 0100 0100  ................
00000200: 0000 052a b700 03ac 0000 0001 000c 0000  ...*............
00000210: 0006 0001 0000 0011 0009 0013 0012 0001  ................
00000220: 000b 0000 0028 0002 0002 0000 0008 043b  .....(.........;
00000230: 053c 1a1b 60ac 0000 0001 000c 0000 000e  .<..`...........
00000240: 0003 0000 0016 0002 0017 0004 0018 0009  ................
00000250: 0014 0015 0001 000b 0000 0021 0001 0001  ...........!....
00000260: 0000 0005 b800 0457 b100 0000 0100 0c00  .......W........
00000270: 0000 0a00 0200 0000 1c00 0400 1d00 0100  ................
00000280: 1600 0000 0200 17                        .......
```

### 约定结构

> 参考[wiki_java_class_file](https://en.wikipedia.org/wiki/Java_class_file#General_layout)。

<table class="wikitable"><table><tbody><tr>
<th>byte offset
</th>
<th>size
</th>
<th>type or value
</th>
<th>description
</th></tr>
<tr>
<td>0
</td>
<td rowspan="4">4 bytes
</td>
<td>u1 =<br>0xCA hex
</td>
<td rowspan="4"><a href="/wiki/Magic_number_(programming)" title="Magic number (programming)">magic number</a> (CAFEBABE) used to identify file as conforming to the class file format
<br/>前四字节是CAFEBABE的魔数。就像标记了文件类型，这是一个符合jvm规范的class文件的开头。
</td></tr>
<tr>
<td>1
</td>
<td>u1 =<br>0xFE hex
</td></tr>
<tr>
<td>2
</td>
<td>u1 =<br>0xBA hex
</td></tr>
<tr>
<td>3
</td>
<td>u1 =<br>0xBE hex
</td></tr>
<tr>
<td>4
</td>
<td rowspan="2">2 bytes
</td>
<td rowspan="2">u2
</td>
<td rowspan="2">minor version number of the class file format being used
 <br/>这是jdk的小版本号。我们上面两个00000034，前面0000说明没有小版本区别。
</td></tr>
<tr>
<td>5
</td></tr>
<tr>
<td>6
</td>
<td rowspan="2">2 bytes
</td>
<td rowspan="2">u2
</td>
<td rowspan="2">major version number of the class file format being used.<br>
  JDK的主版本号。这里经常会碰到的错误就是「unsupported major.minor version 52.0」说明当前这个class是通过java8编译的，而当前环境的jdk版本低于java8，不能兼容。
<p>Java SE 17 = 61 (0x3D hex)<br> 
Java SE 16 = 60 (0x3C hex),<br>
Java SE 15 = 59 (0x3B hex),<br>
Java SE 14 = 58 (0x3A hex),<br>
Java SE 13 = 57 (0x39 hex),<br>
Java SE 12 = 56 (0x38 hex),<br>
Java SE 11 = 55 (0x37 hex),<br>
Java SE 10 = 54 (0x36 hex),<sup id="cite_ref-3" class="reference"><a href="#cite_note-3">[3]</a></sup><br>
Java SE 9 = 53 (0x35 hex),<sup id="cite_ref-4" class="reference"><a href="#cite_note-4">[4]</a></sup><br>
Java SE 8 = 52 (0x34 hex),<br>Java SE 7 = 51 (0x33 hex),<br>Java SE 6.0 = 50 (0x32 hex),<br>Java SE 5.0 = 49 (0x31 hex),<br>JDK 1.4 = 48 (0x30 hex),<br>JDK 1.3 = 47 (0x2F hex),<br>JDK 1.2 = 46 (0x2E hex),<br>JDK 1.1 = 45 (0x2D hex).<br>For details of earlier version numbers see footnote 1 at <a rel="nofollow" class="external text" href="https://docs.oracle.com/javase/specs/jvms/se6/html/ClassFile.doc.html">The JavaTM Virtual Machine Specification 2nd edition</a>
</p>
</td></tr>
<tr>
<td>7
</td></tr>
<tr>
<td>8
</td>
<td rowspan="2">2 bytes
</td>
<td rowspan="2">u2
</td>
<td rowspan="2">constant pool count, number of entries in the following constant pool table.  This count is at least one greater than the actual number of entries; see following discussion.
<br/>这里标记了常量池的大小。我们看到上面class的一个常量池大小分别是001a「25」和001e「29」。这里似乎有两个违反常识的点。
<br/>一个是「都减了1：1a应该是26；1e应该是30」，wiki百科里说这是因为「文件格式开发过程中的历史选择」，或许可以理解为nextCurrentIndex。
<br/>另一个是「为啥不是+1，因为我们通常的计数都是从0开始」，这是因为索引0标识无效「null」不引用任何索引。
</td></tr>
<tr>
<td>9
</td></tr>
<tr>
<td>10
</td>
<td rowspan="4"><i>cpsize</i> (variable)
</td>
<td rowspan="4">table
</td>
<td rowspan="4">constant pool table, an array of variable-sized constant pool entries, containing items such as literal numbers, strings, and references to classes or methods.  Indexed starting at 1, containing (<i>constant pool count</i> - 1) number of entries in total (see note).
<br/>详见常量池结构
</td></tr>
<tr>
<td>...
</td></tr>
<tr>
<td>...
</td></tr>
<tr>
<td>...
</td></tr>
<tr>
<td>10+<i>cpsize</i>
</td>
<td rowspan="2">2 bytes
</td>
<td rowspan="2">u2
</td>
<td rowspan="2">access flags, a bitmask
<br/>访问标识的config，固定16位，不同的位代表不同的访问控制是否开启
<br/>详见访问标识。
</td></tr>
<tr>
<td>11+<i>cpsize</i>
</td></tr>
<tr>
<td>12+<i>cpsize</i>
</td>
<td rowspan="2">2 bytes
</td>
<td rowspan="2">u2
</td>
<td rowspan="2">identifies <i>this</i> class, index into the constant pool to a "Class"-type entry
<br/>类名对应的常量池索引
</td></tr>
<tr>
<td>13+<i>cpsize</i>
</td></tr>
<tr>
<td>14+<i>cpsize</i>
</td>
<td rowspan="2">2 bytes
</td>
<td rowspan="2">u2
</td>
<td rowspan="2">identifies <i>super</i> class, index into the constant pool to a "Class"-type entry
<br/>父类名对应的常量池索引
</td></tr>
<tr>
<td>15+<i>cpsize</i>
</td></tr>
<tr>
<td>16+<i>cpsize</i>
</td>
<td rowspan="2">2 bytes
</td>
<td rowspan="2">u2
</td>
<td rowspan="2">interface count, number of entries in the following interface table
<br/>接口计数器
</td></tr>
<tr>
<td>17+<i>cpsize</i>
</td></tr>
<tr>
<td>18+<i>cpsize</i>
</td>
<td rowspan="4"><i>isize</i> (variable)
</td>
<td rowspan="4">table
</td>
<td rowspan="4">interface table: a variable-length array of constant pool indexes describing the interfaces implemented by this class
<br/>接口表
</td></tr>
<tr>
<td>...
</td></tr>
<tr>
<td>...
</td></tr>
<tr>
<td>...
</td></tr>
<tr>
<td>18+<i>cpsize</i>+<i>isize</i>
</td>
<td rowspan="2">2 bytes
</td>
<td rowspan="2">u2
</td>
<td rowspan="2">field count, number of entries in the following field table
<br/>字段计数器
</td></tr>
<tr>
<td>19+<i>cpsize</i>+<i>isize</i>
</td></tr>
<tr>
<td>20+<i>cpsize</i>+<i>isize</i>
</td>
<td rowspan="4"><i>fsize</i> (variable)
</td>
<td rowspan="4">table
</td>
<td rowspan="4">field table, variable length array of fields
<p>each element is a field_info structure defined in <a rel="nofollow" class="external free" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.5">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.5</a>
<br/>字段表
</p>
</td></tr>
<tr>
<td>...
</td></tr>
<tr>
<td>...
</td></tr>
<tr>
<td>...
</td></tr>
<tr>
<td>20+<i>cpsize</i>+<i>isize</i>+<i>fsize</i>
</td>
<td rowspan="2">2 bytes
</td>
<td rowspan="2">u2
</td>
<td rowspan="2">method count, number of entries in the following method table
<br/>方法计数器
</td></tr>
<tr>
<td>21+<i>cpsize</i>+<i>isize</i>+<i>fsize</i>
</td></tr>
<tr>
<td>22+<i>cpsize</i>+<i>isize</i>+<i>fsize</i>
</td>
<td rowspan="4"><i>msize</i> (variable)
</td>
<td rowspan="4">table
</td>
<td rowspan="4">method table, variable length array of methods each element is a method_info structure defined in <a rel="nofollow" class="external free" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.6">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.6</a></td></tr>
<br/>方法表
<tr>
<td>...
</td></tr>
<tr>
<td>...
</td></tr>
<tr>
<td>...
</td></tr>
<tr>
<td>22+<i>cpsize</i>+<i>isize</i>+<i>fsize</i>+<i>msize</i>
</td>
<td rowspan="2">2 bytes
</td>
<td rowspan="2">u2
</td>
<td rowspan="2">attribute count, number of entries in the following attribute table
<br/>附加属性计数器
</td></tr>
<tr>
<td>23+<i>cpsize</i>+<i>isize</i>+<i>fsize</i>+<i>msize</i>
</td></tr>
<tr>
<td>24+<i>cpsize</i>+<i>isize</i>+<i>fsize</i>+<i>msize</i>
</td>
<td rowspan="4"><i>asize</i> (variable)
</td>
<td rowspan="4">table
</td>
<td rowspan="4">attribute table, variable length array of attributes<p>each element is an attribute_info structure defined in <a rel="nofollow" class="external free" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7</a>
<br/>附加属性表
</p>
</td></tr>
<tr>
<td>...
</td></tr>
<tr>
<td>...
</td></tr>
<tr>
<td>...
</td></tr></tbody></table>

### 常量池结构

> 资料来自[美团技术团队](https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html)。
>
> 举个例子：BaseCode.class的常量池计数器后面的第一个字节0a「十进制10」,对应CONSTANT_Methodref_info。后面有4个字节，前两个标识CONSTANT_Class_info的常量池索引0004「4」；后两个标识CONSTANT_NameAndType的常量池索引0015「21」。
>
> 这个常量池数据不是固定长度的，要根据具体情况而定。
>
> 在BaseCode.class「因为数据少」里共有25个常量信息，分别是
>
> ```text
> 0a 0004 0015
> 09 0003 0016
> 07 0017
> 07 0018
> 01 0003 6b6579
> 01 0012 4c6a6176612f6c616e672f537472696e673b
> 01 000d 436f6e7374616e7456616c7565
> 08 0019
> 01 0006 6704669656c64
> 01 0001 49
> 01 0006 3c696e69743e
> 01 0003 282956
> 01 0004 436f6465
> 01 000f 4c696e654e756d6265725461626c65
> 01 0009 676574704669656c64
> 01 0003 282949
> 01 0009 736574704669656c64
> 01 0004 28492956
> 01 000a 536f7572636546696c65
> 01 000d 42617365436f64652e6a617661
> 0c 000b 000c
> 0c 0009 000a
> 01 0019 636e2f69676f722f61706d2f64656d6f2f42617365436f6465
> 01 0010 6a6176612f6c616e672f4f626a656374
> 01 0008 74656d705f6b6579
> ```
>
> 了解就好。

![图6 各类型的cp_info](https://gitee.com/wangigor/typora-images/raw/master/f5bdc7e8203ec666a531fcd19cdbcddc519208.png)

### 访问标识

> 16位，与16个MASK进行位运算，就知道当前访问控制的组合。

![image-20210728224829661](https://gitee.com/wangigor/typora-images/raw/master/image-20210728224829661.png)

在Modifier.java里有对应的代码。下面只把这16个mask列出来。

```java
/*
 * Access modifier flag constants from tables 4.1, 4.4, 4.5, and 4.7 of
 * <cite>The Java&trade; Virtual Machine Specification</cite>
 */

/**
 * The {@code int} value representing the {@code public}
 * modifier.
 */
public static final int PUBLIC           = 0x00000001;

/**
 * The {@code int} value representing the {@code private}
 * modifier.
 */
public static final int PRIVATE          = 0x00000002;

/**
 * The {@code int} value representing the {@code protected}
 * modifier.
 */
public static final int PROTECTED        = 0x00000004;

/**
 * The {@code int} value representing the {@code static}
 * modifier.
 */
public static final int STATIC           = 0x00000008;

/**
 * The {@code int} value representing the {@code final}
 * modifier.
 */
public static final int FINAL            = 0x00000010;

/**
 * The {@code int} value representing the {@code synchronized}
 * modifier.
 */
public static final int SYNCHRONIZED     = 0x00000020;

/**
 * The {@code int} value representing the {@code volatile}
 * modifier.
 */
public static final int VOLATILE         = 0x00000040;

/**
 * The {@code int} value representing the {@code transient}
 * modifier.
 */
public static final int TRANSIENT        = 0x00000080;

/**
 * The {@code int} value representing the {@code native}
 * modifier.
 */
public static final int NATIVE           = 0x00000100;

/**
 * The {@code int} value representing the {@code interface}
 * modifier.
 */
public static final int INTERFACE        = 0x00000200;

/**
 * The {@code int} value representing the {@code abstract}
 * modifier.
 */
public static final int ABSTRACT         = 0x00000400;

/**
 * The {@code int} value representing the {@code strictfp}
 * modifier.
 */
public static final int STRICT           = 0x00000800;
// Bits not (yet) exposed in the public API either because they
// have different meanings for fields and methods and there is no
// way to distinguish between the two in this class, or because
// they are not Java programming language keywords
static final int BRIDGE    = 0x00000040;
static final int VARARGS   = 0x00000080;
static final int SYNTHETIC = 0x00001000;
static final int ANNOTATION  = 0x00002000;
static final int ENUM      = 0x00004000;
static final int MANDATED  = 0x00008000;
```

那么上面两个class都是0x0021，也就是synchronized+public

### 字段

字段表结构

```info
field_info {
    u2             access_flags; 
    u2             name_index;
    u2             descriptor_index;
    u2             attributes_count;
    attribute_info attributes[attributes_count];
}
```

access_flags这个访问控制符呢，占两个字节，跟类的访问控制符基本一样。

```java
/**
 * Access modifier flags.
 */
static final char
    ACC_PUBLIC                 = 0x0001,
    ACC_PRIVATE                = 0x0002,
    ACC_PROTECTED              = 0x0004,
    ACC_STATIC                 = 0x0008,
    ACC_FINAL                  = 0x0010,
    ACC_SYNCHRONIZED           = 0x0020,
    ACC_VOLATILE               = 0x0040,
    ACC_TRANSIENT              = 0x0080,
    ACC_NATIVE                 = 0x0100,
    ACC_INTERFACE              = 0x0200,
    ACC_ABSTRACT               = 0x0400,
    ACC_STRICT                 = 0x0800,
    ACC_SYNTHETIC              = 0x1000,
    ACC_ANNOTATION             = 0x2000,
    ACC_ENUM                   = 0x4000,
    // aliases:
    ACC_SUPER                  = ACC_SYNCHRONIZED,
    ACC_BRIDGE                 = ACC_VOLATILE,
    ACC_VARARGS                = ACC_TRANSIENT;
```

name_index是字段名称对应的常量池索引，占2个字节。

descriptor_index是字段类型对应的常量池索引，占2个字节。

以BaseCode为例。

```text
0002 有两个字段
第一个 0019 public static final
      0005 名称常量池索引
      0006 类型常量池索引
      0001 有一个属性
      0007 属性名称
      00000002 属性值长度为2
      0008 属性值常量池索引
第二个 0002 private
      0009 名称常量池索引
      000a 类型常量池索引
      0000 没有属性
```

### 方法

方法表结构

```text
method_info {
    u2             access_flags;
    u2             name_index;
    u2             descriptor_index;
    u2             attributes_count;
    attribute_info attributes[attributes_count];
}
```

基本跟属性或者字段一样的。

但是对于Code属性，有很重要的就是操作符。

参考文档：[The Java Virtual Machine Instruction Set](https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-6.html)

### 属性

属性表结构

```text
attribute_info {
    u2 attribute_name_index;
    u4 attribute_length;
    u1 info[attribute_length];
}
```

预置的属性，分为三组：

```text
对于jvm解析class至关重要的5个
 ConstantValue
 Code
 StackMapTable
 Exceptions
 BootstrapMethods
```

```text
对于javase平台解析class重要的12个属性
InnerClasses
 EnclosingMethod
 Synthetic
 Signature
 RuntimeVisibleAnnotations
 RuntimeInvisibleAnnotations
 RuntimeVisibleParameterAnnotations
 RuntimeInvisibleParameterAnnotations
 RuntimeVisibleTypeAnnotations
 RuntimeInvisibleTypeAnnotations
 AnnotationDefault
 MethodParameters
```

```text
对于jvm和javase可以忽略的6个属性
 SourceFile
 SourceDebugExtension
 LineNumberTable
 LocalVariableTable
 LocalVariableTypeTable
 Deprecated
```

详情可以查看oracle 的[class format文档](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7)。

### 可视

> 当然不需要像上面这样按照字符查看，javap已经帮我们都做了。
>
> 命令：```javap -verbose XXXX```

那么上面的两个class文件就是下面这样

```c
Classfile /Users/wangke/IdeaProjects/git/apm-demo/src/main/java/cn/igor/apm/demo/BaseCode.class
  Last modified 2021-7-28; size 439 bytes
  MD5 checksum dfa4999537c5f223c429fc9a90892020
  Compiled from "BaseCode.java"
public class cn.igor.apm.demo.BaseCode
  minor version: 0
  major version: 52
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 = Methodref          #4.#21         // java/lang/Object."<init>":()V
   #2 = Fieldref           #3.#22         // cn/igor/apm/demo/BaseCode.pField:I
   #3 = Class              #23            // cn/igor/apm/demo/BaseCode
   #4 = Class              #24            // java/lang/Object
   #5 = Utf8               key
   #6 = Utf8               Ljava/lang/String;
   #7 = Utf8               ConstantValue
   #8 = String             #25            // temp_key
   #9 = Utf8               pField
  #10 = Utf8               I
  #11 = Utf8               <init>
  #12 = Utf8               ()V
  #13 = Utf8               Code
  #14 = Utf8               LineNumberTable
  #15 = Utf8               getpField
  #16 = Utf8               ()I
  #17 = Utf8               setpField
  #18 = Utf8               (I)V
  #19 = Utf8               SourceFile
  #20 = Utf8               BaseCode.java
  #21 = NameAndType        #11:#12        // "<init>":()V
  #22 = NameAndType        #9:#10         // pField:I
  #23 = Utf8               cn/igor/apm/demo/BaseCode
  #24 = Utf8               java/lang/Object
  #25 = Utf8               temp_key
{
  public static final java.lang.String key;
    descriptor: Ljava/lang/String;
    flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL
    ConstantValue: String temp_key

  public cn.igor.apm.demo.BaseCode();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: return
      LineNumberTable:
        line 3: 0

  public int getpField();
    descriptor: ()I
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: getfield      #2                  // Field pField:I
         4: ireturn
      LineNumberTable:
        line 10: 0

  public void setpField(int);
    descriptor: (I)V
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=2, args_size=2
         0: aload_0
         1: iload_1
         2: putfield      #2                  // Field pField:I
         5: return
      LineNumberTable:
        line 14: 0
        line 15: 5
}
SourceFile: "BaseCode.java"
```

```c
Classfile /Users/wangke/IdeaProjects/git/apm-demo/src/main/java/cn/igor/apm/demo/ByteCode.class
  Last modified 2021-7-28; size 827 bytes
  MD5 checksum 87f71228757b2c77c1561d00d6360ba9
  Compiled from "ByteCode.java"
public class cn.igor.apm.demo.ByteCode extends cn.igor.apm.demo.BaseCode
  minor version: 0
  major version: 52
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 = Methodref          #9.#27         // cn/igor/apm/demo/BaseCode."<init>":()V
   #2 = Fieldref           #6.#28         // cn/igor/apm/demo/ByteCode.cField:Ljava/lang/String;
   #3 = Methodref          #9.#29         // cn/igor/apm/demo/BaseCode.getpField:()I
   #4 = Methodref          #6.#30         // cn/igor/apm/demo/ByteCode.test:()I
   #5 = Fieldref           #31.#32        // java/lang/System.out:Ljava/io/PrintStream;
   #6 = Class              #33            // cn/igor/apm/demo/ByteCode
   #7 = Methodref          #34.#35        // java/lang/Class.isSynthetic:()Z
   #8 = Methodref          #36.#37        // java/io/PrintStream.println:(Z)V
   #9 = Class              #38            // cn/igor/apm/demo/BaseCode
  #10 = Utf8               cField
  #11 = Utf8               Ljava/lang/String;
  #12 = Utf8               <init>
  #13 = Utf8               ()V
  #14 = Utf8               Code
  #15 = Utf8               LineNumberTable
  #16 = Utf8               getcField
  #17 = Utf8               ()Ljava/lang/String;
  #18 = Utf8               setcField
  #19 = Utf8               (Ljava/lang/String;)V
  #20 = Utf8               getpField
  #21 = Utf8               ()I
  #22 = Utf8               test
  #23 = Utf8               main
  #24 = Utf8               ([Ljava/lang/String;)V
  #25 = Utf8               SourceFile
  #26 = Utf8               ByteCode.java
  #27 = NameAndType        #12:#13        // "<init>":()V
  #28 = NameAndType        #10:#11        // cField:Ljava/lang/String;
  #29 = NameAndType        #20:#21        // getpField:()I
  #30 = NameAndType        #22:#21        // test:()I
  #31 = Class              #39            // java/lang/System
  #32 = NameAndType        #40:#41        // out:Ljava/io/PrintStream;
  #33 = Utf8               cn/igor/apm/demo/ByteCode
  #34 = Class              #42            // java/lang/Class
  #35 = NameAndType        #43:#44        // isSynthetic:()Z
  #36 = Class              #45            // java/io/PrintStream
  #37 = NameAndType        #46:#47        // println:(Z)V
  #38 = Utf8               cn/igor/apm/demo/BaseCode
  #39 = Utf8               java/lang/System
  #40 = Utf8               out
  #41 = Utf8               Ljava/io/PrintStream;
  #42 = Utf8               java/lang/Class
  #43 = Utf8               isSynthetic
  #44 = Utf8               ()Z
  #45 = Utf8               java/io/PrintStream
  #46 = Utf8               println
  #47 = Utf8               (Z)V
{
  public cn.igor.apm.demo.ByteCode();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method cn/igor/apm/demo/BaseCode."<init>":()V
         4: return
      LineNumberTable:
        line 3: 0

  public java.lang.String getcField();
    descriptor: ()Ljava/lang/String;
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: getfield      #2                  // Field cField:Ljava/lang/String;
         4: areturn
      LineNumberTable:
        line 8: 0

  public void setcField(java.lang.String);
    descriptor: (Ljava/lang/String;)V
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=2, args_size=2
         0: aload_0
         1: aload_1
         2: putfield      #2                  // Field cField:Ljava/lang/String;
         5: return
      LineNumberTable:
        line 12: 0
        line 13: 5

  public int getpField();
    descriptor: ()I
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #3                  // Method cn/igor/apm/demo/BaseCode.getpField:()I
         4: ireturn
      LineNumberTable:
        line 17: 0

  public static int test();
    descriptor: ()I
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=2, args_size=0
         0: iconst_1
         1: istore_0
         2: iconst_2
         3: istore_1
         4: iload_0
         5: iload_1
         6: iadd
         7: ireturn
      LineNumberTable:
        line 22: 0
        line 23: 2
        line 24: 4

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=1, args_size=1
         0: invokestatic  #4                  // Method test:()I
         3: pop
         4: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;
         7: ldc           #6                  // class cn/igor/apm/demo/ByteCode
         9: invokevirtual #7                  // Method java/lang/Class.isSynthetic:()Z
        12: invokevirtual #8                  // Method java/io/PrintStream.println:(Z)V
        15: return
      LineNumberTable:
        line 28: 0
        line 29: 4
        line 30: 15
}
SourceFile: "ByteCode.java"
```

## 字节码修改

> 字节码增强，是AOP在字节码修改方面的使用，对程序的侵入更小。
>
> 目前有ASM「例：cglib在用」，javaassist「例：dubbo的SPI在用」,ByteBuddy「例：skywalking在用」。
>
> 下面我们一个一个来看。

### ASM

> [ASM4.0官方文档](https://asm.ow2.io/asm4-guide.pdf)
>
> [小博哥的ASM专栏](https://mp.weixin.qq.com/s/hjtBBczJMvt4SDtZvO25rg)
>
> ASM是通过编程方式，生成或修改.class文件，比如常量池数据，字段，方法「方法栈深度，方法执行行号，数据读取、入栈、出栈、方法调用等等」等等。怎么说呢，有些晦涩难懂「或者需要的成本比较高」。我已经放弃了细节得去扣具体怎么实现「业务」。
>
> 且官方提供了插件「ASM Bytecode Outline」.
>
> <img src="https://gitee.com/wangigor/typora-images/raw/master/image-20210729144122929.png" alt="image-20210729144122929" style="zoom:50%;" />

比如你写好了代码，右键「Show Bytecode outline」

<img src="https://gitee.com/wangigor/typora-images/raw/master/image-20210729144354937.png" alt="image-20210729144354937" style="zoom: 50%;" />



<img src="https://gitee.com/wangigor/typora-images/raw/master/image-20210729144557400.png" alt="image-20210729144557400" style="zoom:67%;" />

> ASM采用的是访问者模式，所以我们能看到很多的visit/visitor.

#### 生成字节码执行

> classloader没有暴露出来通过byte[]生成class的方法。
>
> 需要重新封装一个classloader。请看下面代码。

```java
package cn.igor.apm.demo.asm;

import jdk.internal.org.objectweb.asm.*;

import java.lang.reflect.Method;

import static jdk.internal.org.objectweb.asm.Opcodes.*;

/**
 * 新建一个helloworld的ASM测试类
 */
public class HelloWorldASM {

    /**
     * 拷贝来插件生成的「dump」方法
     * 用于生成HelloWorld.class
     * @return
     * @throws Exception
     */
    public static byte[] dump() throws Exception {

        ClassWriter cw = new ClassWriter(0);
        FieldVisitor fv;
        MethodVisitor mv;
        AnnotationVisitor av0;

        cw.visit(52, ACC_PUBLIC + ACC_SUPER, "cn/igor/apm/demo/asm/HelloWorld", null, "java/lang/Object", null);

        cw.visitSource("HelloWorld.java", null);

        {
            fv = cw.visitField(ACC_PUBLIC + ACC_FINAL + ACC_STATIC, "name", "Ljava/lang/String;", null, "world");
            fv.visitEnd();
        }
        {
            mv = cw.visitMethod(ACC_PUBLIC, "<init>", "()V", null, null);
            mv.visitCode();
            Label l0 = new Label();
            mv.visitLabel(l0);
            mv.visitLineNumber(3, l0);
            mv.visitVarInsn(ALOAD, 0);
            mv.visitMethodInsn(INVOKESPECIAL, "java/lang/Object", "<init>", "()V", false);
            mv.visitInsn(RETURN);
            Label l1 = new Label();
            mv.visitLabel(l1);
            mv.visitLocalVariable("this", "Lcn/igor/apm/demo/asm/HelloWorld;", null, l0, l1, 0);
            mv.visitMaxs(1, 1);
            mv.visitEnd();
        }
        {
            mv = cw.visitMethod(ACC_PUBLIC + ACC_STATIC, "main", "([Ljava/lang/String;)V", null, null);
            mv.visitCode();
            Label l0 = new Label();
            mv.visitLabel(l0);
            mv.visitLineNumber(8, l0);
            mv.visitFieldInsn(GETSTATIC, "java/lang/System", "out", "Ljava/io/PrintStream;");
            mv.visitLdcInsn("helloworld");
            mv.visitMethodInsn(INVOKEVIRTUAL, "java/io/PrintStream", "println", "(Ljava/lang/String;)V", false);
            Label l1 = new Label();
            mv.visitLabel(l1);
            mv.visitLineNumber(9, l1);
            mv.visitInsn(RETURN);
            Label l2 = new Label();
            mv.visitLabel(l2);
            mv.visitLocalVariable("args", "[Ljava/lang/String;", null, l0, l2, 0);
            mv.visitMaxs(2, 1);
            mv.visitEnd();
        }
        cw.visitEnd();

        return cw.toByteArray();
    }

    public static void main(String[] args) throws Exception {
        byte[] dump = dump();

        ASMClassLoader asmClassLoader = new ASMClassLoader();
        Class helloworldClass = asmClassLoader.defineClass("cn.igor.apm.demo.asm.HelloWorld", dump);

        //main方法执行
        Method main = helloworldClass.getMethod("main", String[].class);
        main.invoke(null, new Object[]{new String[]{}});

    }


}

/**
 * 自定义classloader
 * 暴露出父接口的通过byte[]生成class的protected方法
 */
class ASMClassLoader extends ClassLoader {
    public Class defineClass(String name, byte[] bytes) {
        return super.defineClass(name, bytes, 0, bytes.length);
    }
}
```

#### 修改字节码执行

> 读取要修改的类，添加修改的vistor。
>
> 代码完全照抄小博哥的。

```java
package cn.igor.apm.demo.asm;

import jdk.internal.org.objectweb.asm.*;
import jdk.internal.org.objectweb.asm.commons.AdviceAdapter;

import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

import static jdk.internal.org.objectweb.asm.Opcodes.ASM5;

public class TestMonitor extends ClassLoader {

    public static void main(String[] args) throws IOException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException, InvocationTargetException {

        ClassReader cr = new ClassReader(MyMethod.class.getName());
        ClassWriter cw = new ClassWriter(cr, ClassWriter.COMPUTE_MAXS);

        {
            MethodVisitor methodVisitor = cw.visitMethod(Opcodes.ACC_PUBLIC, "<init>", "()V", null, null);
            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);
            methodVisitor.visitMethodInsn(Opcodes.INVOKESPECIAL, "java/lang/Object", "<init>", "()V", false);
            methodVisitor.visitInsn(Opcodes.RETURN);
            methodVisitor.visitMaxs(1, 1);
            methodVisitor.visitEnd();
        }

        ClassVisitor cv = new ProfilingClassAdapter(cw, MyMethod.class.getSimpleName());
        cr.accept(cv, ClassReader.EXPAND_FRAMES);

        byte[] bytes = cw.toByteArray();

        Class<?> clazz = new TestMonitor().defineClass("cn.igor.apm.demo.asm.MyMethod", bytes, 0, bytes.length);
        Method queryUserInfo = clazz.getMethod("queryUserInfo", String.class);
        Object obj = queryUserInfo.invoke(clazz.newInstance(), "10001");
        System.out.println("测试结果：" + obj);

    }

    static class ProfilingClassAdapter extends ClassVisitor {

        public ProfilingClassAdapter(final ClassVisitor cv, String innerClassName) {
            super(ASM5, cv);
        }

        public MethodVisitor visitMethod(int access,
                                         String name,
                                         String desc,
                                         String signature,
                                         String[] exceptions) {
            System.out.println("access：" + access);
            System.out.println("name：" + name);
            System.out.println("desc：" + desc);

            if (!"queryUserInfo".equals(name)) return null;

            MethodVisitor mv = cv.visitMethod(access, name, desc, signature, exceptions);

            return new ProfilingMethodVisitor(mv, access, name, desc);
        }

    }

    static class ProfilingMethodVisitor extends AdviceAdapter {

        private String methodName = "";

        protected ProfilingMethodVisitor(MethodVisitor methodVisitor, int access, String name, String descriptor) {
            super(ASM5, methodVisitor, access, name, descriptor);
            this.methodName = name;
        }

        @Override
        protected void onMethodEnter() {
            mv.visitMethodInsn(INVOKESTATIC, "java/lang/System", "nanoTime", "()J", false);
            mv.visitVarInsn(LSTORE, 2);
            mv.visitVarInsn(ALOAD, 1);

            //方法入参
            mv.visitFieldInsn(GETSTATIC, "java/lang/System", "out", "Ljava/io/PrintStream;");
            mv.visitVarInsn(ALOAD, 1);
            mv.visitMethodInsn(INVOKEVIRTUAL, "java/io/PrintStream", "println", "(Ljava/lang/String;)V", false);
        }

        @Override
        protected void onMethodExit(int opcode) {
            if ((IRETURN <= opcode && opcode <= RETURN) || opcode == ATHROW) {
                mv.visitFieldInsn(GETSTATIC, "java/lang/System", "out", "Ljava/io/PrintStream;");

                mv.visitTypeInsn(NEW, "java/lang/StringBuilder");
                mv.visitInsn(DUP);
                mv.visitMethodInsn(INVOKESPECIAL, "java/lang/StringBuilder", "<init>", "()V", false);
                mv.visitLdcInsn("方法执行耗时(纳秒)->" + methodName + "：");
                mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/StringBuilder", "append", "(Ljava/lang/String;)Ljava/lang/StringBuilder;", false);

                mv.visitMethodInsn(INVOKESTATIC, "java/lang/System", "nanoTime", "()J", false);
                mv.visitVarInsn(LLOAD, 2);
                mv.visitInsn(LSUB);

                mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/StringBuilder", "append", "(J)Ljava/lang/StringBuilder;", false);
                mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/StringBuilder", "toString", "()Ljava/lang/String;", false);
                mv.visitMethodInsn(INVOKEVIRTUAL, "java/io/PrintStream", "println", "(Ljava/lang/String;)V", false);

            }
        }
    }

}
```

执行结果

```log
access：1
name：<init>
desc：()V
access：1
name：queryUserInfo
desc：(Ljava/lang/String;)Ljava/lang/String;
10001
xxxx
xxxx
xxxx
xxxx
方法执行耗时(纳秒)->queryUserInfo：273536
测试结果：10001
```

### javaassist

> 如果把ASM理解为操作的是class，那么可以把javaassist理解为操作java文件。
>
> dubbo选择javassist也是因为这个，可以直接写java代码，而不是操作字节码。
>
> 虽然javaassist比ASM慢，但是也是同一个数量级下的慢，可以被接受。
>
> [javassist官网](http://www.javassist.org)
>
> [梁飞-动态代理方案性能对比](https://www.iteye.com/blog/javatar-814426)

添加maven依赖

```xml
        <!-- https://mvnrepository.com/artifact/org.javassist/javassist -->
        <dependency>
            <groupId>org.javassist</groupId>
            <artifactId>javassist</artifactId>
            <version>3.28.0-GA</version>
        </dependency>
```

#### 创建

```java
//先创建一个接口，方便调用
public interface Hello {
    public void hello();
}
```

```java
public class Demo {

    public static void main(String[] args) throws Exception {
      	//创建类并加载得到class
        CtClass helloCtClass = createClass();
        Class<?> helloClass = helloCtClass.toClass();
      
      	//无参构造器实例化
        Hello hello = (Hello) helloClass.newInstance();
        hello.hello();

				//有参构造器实例化
        Constructor constructor = helloClass.getConstructor(String.class);
        Hello hello1= (Hello) constructor.newInstance("小明");
        hello1.hello();
    }




    private static CtClass createClass() throws CannotCompileException, NotFoundException, IOException {
        ClassPool classPool = ClassPool.getDefault();
        CtClass ctClass = classPool.makeClass("cn.igor.apm.demo.javassist.HelloImpl");

        CtClass stringTye = classPool.get("java.lang.String");

      	//添加接口
        ctClass.setInterfaces(new CtClass[]{classPool.get("cn.igor.apm.demo.javassist.Hello")});

        //public static final String salutatory="hello"
        CtField salutatoryField = new CtField(stringTye, "salutatory", ctClass);
        salutatoryField.setModifiers(Modifier.PUBLIC + Modifier.FINAL + Modifier.STATIC);
        ctClass.addField(salutatoryField, CtField.Initializer.constant("hello"));

        //private final String name
        CtField nameField = new CtField(stringTye, "name", ctClass);
        nameField.setModifiers(Modifier.PRIVATE + Modifier.FINAL);
        ctClass.addField(nameField);

        //无参构造器
        CtConstructor noArgConstructor = new CtConstructor(new CtClass[]{}, ctClass);
        noArgConstructor.setBody("{$0.name=\"igor\";}");
        ctClass.addConstructor(noArgConstructor);

        //单参构造器
        CtConstructor allArgConstructor = new CtConstructor(new CtClass[]{stringTye}, ctClass);
        allArgConstructor.setBody("{$0.name=$1;}");
        ctClass.addConstructor(allArgConstructor);

        //name的get/set方法
        ctClass.addMethod(CtNewMethod.getter("getName", nameField));
        ctClass.addMethod(CtNewMethod.setter("setName", nameField));

        //实现hello方法
        CtMethod helloMethod = new CtMethod(CtClass.voidType, "hello", new CtClass[]{}, ctClass);
        helloMethod.setModifiers(Modifier.PUBLIC);
        helloMethod.setBody("{System.out.println(salutatory+\" \"+getName());}");
        ctClass.addMethod(helloMethod);
        
        return ctClass;
    }
}
```

#### 前置修改

> 修改类有一个前提：那就是这个类没有被类加载器加载过「会报ClassCastException：类重复」。

先写一个待修改的类。

```java
//接口
public interface IUserService {
    public String queryUserInfo(String id);
}
```

```java
//实现类
public class UserService implements IUserService {

    public String queryUserInfo(String id) {
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return "null";
    }
}
```

进行简单的修改。

```java
public class UpdateDemo {
    public static void main(String[] args) throws Exception {
        ClassPool classPool = ClassPool.getDefault();
        CtClass ctClass = classPool.get("cn.igor.apm.demo.javassist.UserService");
        CtMethod method = ctClass.getDeclaredMethod("queryUserInfo", new CtClass[]{classPool.get("java.lang.String")});
      
      	//打印入参
        method.insertBefore("System.out.println(\"queryUserInfo方法入参\"+$1);");
      	//设置方法本地变量
        method.addLocalVariable("start", CtClass.longType);
      	//添加方法计时
        method.insertBefore("start = System.currentTimeMillis();");
        method.insertAfter("System.out.println(\"方法执行时间\"+(System.currentTimeMillis()-start)+\"ms\");");

      	//加载并执行
        IUserService userService = (IUserService) ctClass.toClass().newInstance();
        System.out.println(
                userService.queryUserInfo("1")
        );
    }
}
```

> 当然。javassist也提供了对于字节码的操作。emmmmmmmm暂时对我没有必要。

#### 运行期修改

> 运行期修改需要用到**javassist.tools.HotSwapper**和java提供的调试工具JPDA「需要引入```$JAVA_HOME$/lib/tools.jar```」。
>
> java5以后```command line options```选项增加 ```-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=8000```
>
> - jdwp调试线协议采用socket。
> - server : y「yes」 作为服务端等待调试器连接。
> - suspend：n「no」不是在vm启动之后就暂停等待连接。
> - 开放端口8000：这也就是HotSwapper需要连接的端口。
> - 如果是本地的话，会影响debug「使用run」。

先写一个简单的查询方法

```java
//一直返回1
public class QueryService {
    public int query() {
        return 1;
    }
}
```

```java
public class HotSwapperDemo {

    public static void main(String[] args) throws Exception {

        QueryService queryService = new QueryService();

        System.out.println("修改前返回：" + queryService.query());

        // VM options : -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=8000
        HotSwapper hotSwapper = new HotSwapper(8000);

        ClassPool pool = ClassPool.getDefault();
        CtClass ctClass = pool.get(QueryService.class.getName());

        //改为返回2
        CtMethod queryMethod = ctClass.getDeclaredMethod("query");
        queryMethod.setBody("{return 2;}");

        hotSwapper.reload(QueryService.class.getName(), ctClass.toBytecode());
        System.out.println("修改完成。");
        System.out.println("修改后返回：" + queryService.query());
    }
}
```

```log
Listening for transport dt_socket at address: 8000
修改前返回：1
修改完成。
修改后返回：2
```

### ByteBuddy

> 他是基于ASM的封装，更加方便。
>
> [github](https://github.com/raphw/byte-buddy)
>
> [stackoverflow问题集](https://stackoverflow.com/questions/tagged/byte-buddy)

添加依赖

```xml
<!-- https://mvnrepository.com/artifact/net.bytebuddy/byte-buddy -->
<dependency>
    <groupId>net.bytebuddy</groupId>
    <artifactId>byte-buddy</artifactId>
    <version>1.11.9</version>
</dependency>
```

#### HelloWorld

下面是参照官网的HelloWorld

```java
public class HelloDemo {

    public static void main(String[] args) throws InstantiationException, IllegalAccessException, IOException {

        //创建一个随机类
        DynamicType.Unloaded<Object> dynamicType = new ByteBuddy()
                .subclass(Object.class)
                .method(named("toString"))
                .intercept(FixedValue.value("hello world."))
                .make();

        //字节码class输出成文件
        dynamicType.saveIn(new File("/Users/XXX/IdeaProjects/git/apm-demo/src/main/java/cn/igor/apm/demo/byteBuddy"));

        //加载、实例化、执行toString()
        String toString = dynamicType.load(HelloDemo.class.getClassLoader())
                .getLoaded()
                .newInstance()
                .toString();

        System.out.println(toString);
    }
}
```

生成的随机类

```java
//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by FernFlower decompiler)
//

package net.bytebuddy.renamed.java.lang;

public class Object$ByteBuddy$7WfYAwY8 {
    public String toString() {
        return "hello world.";
    }

    public Object$ByteBuddy$7WfYAwY8() {
    }
}
```

#### 类

> 之前的类名是随机的『前缀为net.bytebuddy.renamed』，也可以手动指定类名```DynamicType.name()```.

创建一个指定类名的新类

```java
    public static void main(String[] args) throws Exception {
        new ByteBuddy()
          			//设置为顶级父类
                .subclass(Object.class)
          			//全类名
                .name("Test")
          			//生成字节码
                .make();
    }
```

生成的样子

```java
public class Test {
    public Test() {
    }
}
```

> 类名也可以通过提供的命名策略或者自定义命名策略产生。
>
> 提供的是```NamingStrategy.SuffixingRandom```和```NamingStrategy.PrefixingRandom```

自定义的是实现NamingStrategy.AbstractBase抽象类

```java
    public static void main(String[] args) throws Exception {

      	//父类$0 父类$1
        NamingStrategy.AbstractBase customNamingStrategy = new NamingStrategy.AbstractBase() {
            private int i;

            @Override
            protected String name(TypeDescription superClass) {

                return superClass.getName() + "$" + i++;
            }
        };

        new ByteBuddy()
                .with(customNamingStrategy)
                .subclass(Object.class)
                .make()
                .saveIn(new File("/Users/wangke/IdeaProjects/git/apm-demo/src/main/java/cn/igor/apm/demo/byteBuddy"));
        new ByteBuddy()
                .with(customNamingStrategy)
                .subclass(Object.class)
                .make()
                .saveIn(new File("/Users/wangke/IdeaProjects/git/apm-demo/src/main/java/cn/igor/apm/demo/byteBuddy"));
    }
```

上面这种```subclass```的方式是**继承**。还有一些类似模板的生成子类的方式

比如一个父类Parent

```java
public class Parent {
    private String name = "parent";

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
```

- 使用subclass结果是

  ```java
  import cn.igor.apm.demo.byteBuddy.Parent;
  
  public class Child extends Parent {
      public Child() {
      }
  }
  ```

- 使用rebase或者redefine，是以Parent为模板，全复制的进行改造。

  ```java
  public class Child {
      private String name = "parent";
  
      public Child() {
      }
  
      public String getName() {
          return this.name;
      }
  
      public void setName(String name) {
          this.name = name;
      }
  }
  ```

稍有不同的是redefine是完全覆盖。

> 比如方法修改，那```从父类中拷贝过来的方法签名相同的方法```会被完全覆盖。

rebase则不同，他会把```从父类中拷贝过来的方法签名相同的方法```重命名一个```$original```为后缀的方法，依旧可以调用。

##### 类加载

> 生成的类make执行之后，是一个DynamicType.Unloaded未加载类型。
>
> 类加载器策略也有各种不同。

- 「默认」 ClassLoadingStrategy.Default.**WRAPPER**

> 通过默认的```dynamicType.load(classLoader)```。是默认调用了```dynamicType.load(classLoader, ClassLoadingStrategy.Default.WRAPPER)```

以传入的classLoader为父加载器，生成一个新加载器。

确保被加载类能看到所有父加载器的类。但是如果父加载器中有重名类，那就不会被加载。

- ClassLoadingStrategy.Default.**CHILD_FIRST**

WRAPPER的修改版，是有子构造器优先加载「破坏双亲委派」。

- ClassLoadingStrategy.Default.**INJECTION**「适合java9之前的版本。」

通过反射由传入的类加载器加载「不创建新的类加载器」。

***

> 以上是加载「未被加载过的类」的情况。
>
> 但是如果要对原有类进行修改，需要引入```ByteBuddyAgent```

```xml
<!-- https://mvnrepository.com/artifact/net.bytebuddy/byte-buddy-agent -->
<dependency>
    <groupId>net.bytebuddy</groupId>
    <artifactId>byte-buddy-agent</artifactId>
    <version>1.11.9</version>
</dependency>
```

```java
public static void main(String[] args) throws Exception {

    ByteBuddyAgent.install();
  	//生成一个以Parent为模板的类
    Class<? extends Parent> loaded = new ByteBuddy()
            .rebase(Parent.class)
      			//跟Parent使用同样的类名
            .name(Parent.class.getName())
            .make()
      			//重新加载
            .load(Parent.class.getClassLoader(), ClassReloadingStrategy.fromInstalledAgent())
            .getLoaded();
    assert loaded == Parent.class;

}
```



